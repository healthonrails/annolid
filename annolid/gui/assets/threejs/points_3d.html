<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Mouse Brain Visualization with Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"
        crossorigin="anonymous"></script>
    <style>
        /* Base and UI styles */
        body {
            margin: 0;
            overflow: hidden;
            font-family: sans-serif;
            background-color: #111;
            color: #eee;
        }

        /* --- White Background Mode Styles --- */
        body.white-background-mode {
            color: #111;
            /* Dark text for UI by default */
        }

        body.white-background-mode .ui-panel {
            background: rgba(240, 240, 240, 0.85);
            /* Light panel background */
            color: #111;
            /* Dark text inside panel */
            border: 1px solid #ccc;
        }

        body.white-background-mode #controls button {
            background-color: #e0e0e0;
            color: #111;
            border: 1px solid #999;
        }

        body.white-background-mode #controls button:hover {
            background-color: #d0d0d0;
        }

        body.white-background-mode #usageHints {
            background: rgba(235, 235, 235, 0.8);
            color: #333;
        }

        body.white-background-mode #downloadContainer a {
            background-color: #006600;
            /* Darker green */
        }

        body.white-background-mode #toggleControls .toggle-container span {
            color: #111;
            /* Ensure toggle text is dark */
        }

        body.white-background-mode #leftSidebar {
            background-color: #e0e0e0;
        }

        body.white-background-mode #toggleSidebarButton {
            background-color: #e0e0e0;
            color: #111;
        }

        body.white-background-mode #cameraControls {
            background: rgba(240, 240, 240, 0.8);
        }

        body.white-background-mode #cameraControls button {
            background-color: #ccc;
            color: #111;
        }

        body.white-background-mode #cameraControls button:hover {
            background-color: #bbb;
        }

        body.white-background-mode .control-label {
            color: #111;
        }

        /* --- Isolate dat.GUI from the White Background theme --- */
        /* Force the main dat.GUI panel to keep its dark background and light text */
        body.white-background-mode .dg.main {
            background-color: #1a1a1a;
            color: #eee;
        }

        /* Ensure folder titles also remain dark with light text */
        body.white-background-mode .dg.main .folder .title {
            background: #000;
            color: #eee;
        }

        /* Ensure list items inside keep their dark background and borders */
        body.white-background-mode .dg.main li:not(.folder) {
            background: #1a1a1a;
            border-bottom: 1px solid #2c2c2c;
        }

        /* Force text input fields (like the region search) to use a dark theme */
        body.white-background-mode .dg.main .c input[type=text] {
            background: #303030;
            color: #eee;
        }

        /* Keep the function buttons (like Select All) in the dark theme */
        body.white-background-mode .dg.main .c .button {
            background: #1a1a1a;
            color: #eee;
            border-bottom: 1px solid #2c2c2c;
        }

        body.white-background-mode .dg.main .c .button:hover {
            background: #333;
        }


        canvas {
            display: block;
        }

        .ui-panel {
            position: absolute;
            background: rgba(40, 40, 40, 0.85);
            padding: 10px;
            border-radius: 4px;
            z-index: 10;
            backdrop-filter: blur(2px);
            max-width: 350px;
            max-height: 90vh;
            overflow-y: auto;
        }

        #fileInputContainer {
            top: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        #fileInputContainer .loader-tip {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 4px;
        }

        .tooltip-icon {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            width: 18px;
            height: 18px;
            margin-left: 8px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            color: #fff;
            font-size: 12px;
            cursor: help;
            position: relative;
        }

        .tooltip-icon::after {
            content: attr(data-tooltip);
            white-space: normal;
            max-width: 250px;
            font-size: 12px;
            color: #fff;
            background: rgba(0, 0, 0, 0.85);
            padding: 6px 10px;
            border-radius: 6px;
            position: absolute;
            top: calc(100% + 6px);
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.15s ease;
            z-index: 20;
        }

        .tooltip-icon::before {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translate(-50%, -20%);
            border: 6px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.85);
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        .tooltip-icon:hover::after,
        .tooltip-icon:hover::before {
            opacity: 1;
        }

        #fileInputContainer label {
            display: block;
            font-weight: 700;
            margin-top: 6px;
            color: #fff;
        }

        #fileInputContainer input[type="file"] {
            width: 100%;
            margin-top: 4px;
            margin-bottom: 6px;
        }

        #yamlAtlasContainer {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.15);
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .yaml-header {
            font-size: 14px;
            font-weight: 600;
            color: #f5f5f5;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        #yamlAtlasContainer .yaml-subtext {
            font-size: 12px;
            color: #bbb;
            margin: 0;
        }

        #yamlAtlasContainer label {
            font-weight: 600;
        }

        #yamlAtlasContainer input[type="file"] {
            width: 100%;
        }

        #yamlAtlasContainer button {
            padding: 10px;
            font-size: 15px;
            border-radius: 4px;
            border: none;
            background: linear-gradient(135deg, #3475ff, #1d54c1);
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        #yamlAtlasContainer button:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.45);
        }

        #openInBrowser {
            margin: 10px 0;
            padding: 10px;
            font-size: 15px;
            border-radius: 4px;
            border: none;
            background: linear-gradient(135deg, #28a745, #218838);
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            width: 100%;
        }

        #openInBrowser:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.45);
            background: linear-gradient(135deg, #218838, #1e7e34);
        }

        #controls {
            top: 365px;
            left: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        #controls button {
            padding: 8px 12px;
            font-size: 14px;
            background-color: #444;
            color: #eee;
            border: 1px solid #666;
            border-radius: 3px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        #controls button:hover {
            background-color: #555;
        }

        #controls button:active {
            background-color: #333;
        }

        #usageHints {
            margin-top: 10px;
            background: rgba(0, 0, 0, 0.75);
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            color: #ddd;
            line-height: 1.4;
        }

        /* Download link container */
        #downloadContainer {
            margin-top: 10px;
        }

        #downloadContainer a {
            display: inline-block;
            padding: 5px 10px;
            background-color: #008800;
            color: #fff;
            text-decoration: none;
            font-family: sans-serif;
            font-size: 14px;
            border-radius: 4px;
            cursor: pointer;
        }

        /* Tutorial modal */
        #tutorialModal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 20, 0.95);
            padding: 20px;
            border-radius: 8px;
            width: 80%;
            max-width: 600px;
            color: #eee;
            font-size: 14px;
            line-height: 1.6;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            display: none;
            z-index: 2000;
        }

        #tutorialModal h2 {
            margin-top: 0;
            font-size: 18px;
            color: #ffa;
        }

        #tutorialModal button {
            margin-top: 10px;
            padding: 6px 12px;
            font-size: 14px;
            background-color: #444;
            color: #eee;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }

        /* Tutorial Modal Container */
        #tutorialModal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            background: #222;
            color: #eee;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.8);
            overflow-y: auto;
            z-index: 3000;
        }

        /* Ensures the modal's content area has proper spacing */
        #tutorialModal .modal-content {
            padding-top: 40px;
            /* extra space for the close button */
        }

        /* Close Button (sticky at the top) */
        #closeTutorial {
            position: sticky;
            top: 0;
            float: right;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            font-size: 16px;
            cursor: pointer;
            z-index: 3100;
            margin-bottom: 10px;
        }

        /* Hover effect for the Close Button */
        #closeTutorial:hover {
            background: #d32f2f;
        }

        /* Icon styling */
        #tutorialModal .icon {
            display: inline-block;
            margin-right: 8px;
            vertical-align: middle;
        }

        /* Tooltip styles */
        .tooltip {
            position: absolute;
            padding: 5px 10px;
            border-radius: 4px;
            pointer-events: none;
            font-size: 12px;
            z-index: 20;
            display: none;
            max-width: 250px;
            white-space: normal;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        #hoverTooltip {
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
        }

        #selectedTooltip {
            background: rgba(80, 80, 0, 0.9);
            color: #ff5;
            border: 1px solid #ff5;
            pointer-events: auto;
            cursor: grab;
        }

        #selectedTooltip .close-btn {
            position: absolute;
            top: 0px;
            right: 3px;
            font-size: 14px;
            color: #ff5;
            cursor: pointer;
            font-weight: bold;
            text-shadow: 0 0 2px black;
        }

        #selectedTooltip .close-btn:hover {
            color: #fff;
        }

        #loadingIndicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 30px;
            border-radius: 8px;
            z-index: 100;
            display: none;
            font-size: 16px;
            text-align: center;
        }

        #loadingIndicator progress {
            width: 100%;
            margin-top: 10px;
            height: 10px;
        }

        /* Region filtering: color square, text, and a single checkbox that controls both visibility and fly-through */
        .region-filter-row {
            display: flex;
            align-items: center;
            margin-bottom: 3px;
            padding: 2px 0;
        }

        .region-filter-colorbox {
            width: 14px;
            height: 14px;
            margin-right: 5px;
            border: 1px solid #888;
            cursor: pointer;
            flex-shrink: 0;
        }

        .region-filter-colorbox input[type=color] {
            display: none;
        }

        .region-filter-text {
            flex-grow: 1;
            font-size: 12px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-right: 5px;
            cursor: default;
        }

        .region-filter-checkbox {
            flex-shrink: 0;
            margin-left: 4px;
        }

        /* Recording indicator style */
        #recordingIndicator {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            background-color: rgba(255, 0, 0, 0.8);
            color: #fff;
            font-family: sans-serif;
            font-size: 14px;
            border-radius: 4px;
            display: none;
            z-index: 1000;
        }

        /* Custom Toggle Switch Styling (only applies to elements within #toggleControls) */
        #toggleControls .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 30px;
            vertical-align: middle;
        }

        #toggleControls .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        #toggleControls .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            border-radius: 30px;
            transition: 0.4s;
        }

        #toggleControls .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            border-radius: 50%;
            transition: 0.4s;
        }

        #toggleControls .switch input:checked+.slider {
            background-color: #4cd137;
        }

        #toggleControls .switch input:checked+.slider:before {
            transform: translateX(20px);
        }

        /* Style the container for the toggle along with a little spacing */
        #toggleControls .toggle-container {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        /* Sidebar Container */
        #leftSidebar {
            position: fixed;
            top: 0;
            left: 0;
            bottom: 0;
            width: 300px;
            /* Adjust width as needed */
            background-color: #222;
            /* Dark background */
            padding: 10px;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.5);
            transition: transform 0.3s ease;
            z-index: 999;
        }

        /* Hidden state for the sidebar; slide it completely out to the left */
        #leftSidebar.hidden {
            transform: translateX(-100%);
        }

        /* Toggle Button styling */
        #toggleSidebarButton {
            position: fixed;
            top: 20px;
            /* Adjust vertical placement */
            left: 310px;
            /* Align to the right edge of the sidebar (300px + 10px margin) */
            z-index: 1000;
            background-color: #222;
            border: none;
            color: #eee;
            padding: 2px;
            cursor: pointer;
            transition: left 0.3s ease, transform 0.3s ease;
            border-radius: 2px;
            box-shadow: 0 2px 2px rgba(0, 0, 0, 0.3);
        }

        /* Move the toggle button when sidebar is hidden */
        #toggleSidebarButton.hidden {
            left: 10px;
            transform: rotate(180deg);
            /* Optionally, rotate the icon */
        }

        /* Container for the entire control panel */
        #cameraControls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            background: rgba(34, 34, 34, 0.8);
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
            z-index: 1500;
        }

        /* Each control item: a column that centers its content */
        .control-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Style for the control buttons */
        #cameraControls button {
            background-color: #555;
            border: none;
            color: #eee;
            font-size: 18px;
            padding: 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        /* Hover style for buttons */
        #cameraControls button:hover {
            background-color: #777;
        }

        /* Labels below the buttons */
        .control-label {
            font-family: 'Roboto', sans-serif;
            font-size: 14px;
            color: #eee;
            margin-top: 4px;
            white-space: nowrap;
        }

        /* Spinner styling */
        .button-spinner {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top: 2px solid #fff;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-right: 5px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>
    <link href="https://fonts.googleapis.com/css?family=Roboto:400,500&display=swap" rel="stylesheet">
    <!-- Physics Engine -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <!-- Three.js, OrbitControls, dat.GUI -->
    <!-- Three.js core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Three.js examples -->
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>

</head>

<body>
    <!-- UI Elements -->
    <!-- Left Panel Container -->
    <div id="leftSidebar">
        <div id="fileInputContainer" class="ui-panel">
            <div id="yamlAtlasContainer">
                <div class="yaml-header">
                    Convert a YAML candidate list with its atlas mapping
                    <span class="tooltip-icon"
                        data-tooltip="Provide the candidate .yml/.yaml file along with the Kim atlas CSV so region IDs can be mapped to acronyms/names via RegionLevel_* fields.">i</span>
                </div>
                <p class="loader-tip">Load YAML + atlas mapping or use a CSV with [x,y,z,region_acronym...] data.</p>
                <label for="yamlInput">
                    Load Candidate YAML:
                    <span class="tooltip-icon"
                        data-tooltip="The YAML should include candidate_cells entries with x, y, z coordinates, metadata.region_id for matching the atlas, and optional center_intensity or intensity keys.">i</span>
                </label>
                <input type="file" id="yamlInput" accept=".yml,.yaml" />
                <label for="atlasInput">
                    Atlas CSV (region mapping):
                    <span class="tooltip-icon"
                        data-tooltip="Use the Kim 25um v1.1 atlas CSV that contains ID, Abbreviation, and RegionLevel_* names to translate region IDs into acronyms/full names.">i</span>
                </label>
                <input type="file" id="atlasInput" accept=".csv" />
                <button id="loadYamlWithAtlas">Load YAML + Atlas</button>
            </div>
            <label for="fileInput">
                Load Brain Data (CSV):
                <span class="tooltip-icon"
                    data-tooltip="Upload a CSV with columns x, y, z, region_acronym[, region_name[, intensity]]. The worker uses these fields directly to create colors and region metadata.">i</span>
            </label>
            <input type="file" id="fileInput" accept=".csv" />
            <button id="openInBrowser">Open in Web Browser</button>
        </div>

        <!-- Camera Control Buttons Panel -->
        <div id="cameraControls">
            <div class="control-item">
                <button id="yawLeftButton" title="Yaw Left">&#x25C0;</button>
                <span class="control-label">Yaw Left</span>
            </div>
            <div class="control-item">
                <button id="pitchUpButton" title="Pitch Up">&#x25B2;</button>
                <span class="control-label">Pitch Up</span>
            </div>
            <div class="control-item">
                <button id="rollLeftButton" title="Roll Left">&#8634;</button>
                <span class="control-label">Roll Left</span>
            </div>
            <div class="control-item">
                <button id="resetCameraButton" title="Reset Camera">&#x21BA;</button>
                <span class="control-label">Reset</span>
            </div>
            <div class="control-item">
                <button id="rollRightButton" title="Roll Right">&#8635;</button>
                <span class="control-label">Roll Right</span>
            </div>
            <div class="control-item">
                <button id="pitchDownButton" title="Pitch Down">&#x25BC;</button>
                <span class="control-label">Pitch Down</span>
            </div>
            <div class="control-item">
                <button id="yawRightButton" title="Yaw Right">&#x25B6;</button>
                <span class="control-label">Yaw Right</span>
            </div>
        </div>


        <div id="controls" class="ui-panel">
            <button id="viewX">View X-Axis (Sagittal)</button>
            <button id="viewY">View Y-Axis (Coronal)</button>
            <button id="viewZ">View Z-Axis (Axial/Horizontal)</button>
            <button id="resetView">Reset View</button>
            <button id="toggleAxes">Toggle Axes Helper</button>
            <button id="flipX">Flip X</button>
            <button id="flipY">Flip Y</button>
            <button id="flipZ">Flip Z</button>

            <button id="rotateX90">Rotate X 90¬∞</button>
            <button id="rotateY90">Rotate Y 90¬∞</button>
            <button id="rotateZ90">Rotate Z 90¬∞</button>

            <!-- Zoom In/Out Buttons -->
            <button id="zoomIn">Zoom In</button>
            <button id="zoomOut">Zoom Out</button>


            <button id="togglePlanes">Toggle Reference Planes</button>
            <!-- Keyframe and recording controls -->
            <button id="captureKeyframe">Capture Keyframe</button>
            <button id="startAnimation">Start Keyframe Animation</button>
            <button id="startRecording">Start Recording</button>
            <button id="stopRecording" disabled>Stop Recording</button>

            <!-- Fly‚ÄìThrough and Manual Fly Mode Buttons -->
            <button id="flyThroughRegions">Fly Through Selected Regions</button>
            <button id="stopFlyThrough">Stop Fly‚ÄìThrough</button>
            <button id="downloadPngBtn">Save Screenshot</button>

            <button id="saveStateButton">
                <span id="saveSpinner" class="button-spinner" style="display: none;"></span>
                Save State
            </button>
            <button id="loadStateButton">
                <span id="loadSpinner" class="button-spinner" style="display: none;"></span>
                Load State
            </button>
            <input type="file" id="loadStateInput" style="display: none;" />

            <div id="toggleControls" style="margin-top:10px;">
                <!-- Manual Fly Mode Toggle -->
                <div class="toggle-container">
                    <label class="switch">
                        <input type="checkbox" id="toggleManualFly">
                        <span class="slider"></span>
                    </label>
                    <span>Manual Fly Mode</span>
                </div>
                <!-- Auto Rotate Toggle -->
                <div class="toggle-container">
                    <label class="switch">
                        <input type="checkbox" id="toggleAutoRotate">
                        <span class="slider"></span>
                    </label>
                    <span>Auto Rotate</span>
                </div>
                <!-- Grayscale Mode Toggle -->
                <div class="toggle-container">
                    <label class="switch">
                        <input type="checkbox" id="toggleGrayscale">
                        <span class="slider"></span>
                    </label>
                    <span>Grayscale Mode</span>
                </div>

                <!-- White Background Toggle -->
                <div class="toggle-container">
                    <label class="switch">
                        <input type="checkbox" id="toggleBackground">
                        <span class="slider"></span>
                    </label>
                    <span>White Background</span>
                </div>

                <!-- Stylized Neurons Toggle -->
                <div class="toggle-container" style="margin-top: 10px;">
                    <label class="switch">
                        <input type="checkbox" id="toggleStylizedNeurons">
                        <span class="slider"></span>
                    </label>
                    <span>Show Stylized Neurons</span>
                </div>

                <!-- Continuous Spiking Toggle -->
                <div class="toggle-container" style="margin-top: 10px;">
                    <label class="switch">
                        <input type="checkbox" id="toggleContinuousSpiking">
                        <span class="slider"></span>
                    </label>
                    <span>Continuous Spiking</span>

                </div>
            </div>
            <div id="usageHints">
                <strong>Usage Hints:</strong><br>
                ‚Ä¢ Load a CSV file with brain data using the top‚Äìleft input.<br>
                ‚Ä¢ Adjust the view with View, Flip, Reset, Zoom In, and Zoom Out buttons.<br>
                ‚Ä¢ Use the mouse to orbit, zoom (scroll), and pan (right‚Äìclick drag).<br>
                ‚Ä¢ In Region Filtering, each row‚Äôs checkbox shows the region and selects it for fly‚Äìthrough.<br>
                ‚Ä¢ Capture keyframes and start animation to record a camera tour.<br>
                ‚Ä¢ Start and Stop Recording to capture a video (download link appears below).<br>
                ‚Ä¢ Use "Fly Through Selected Regions" for an automated fly‚Äìthrough.<br>
                ‚Ä¢ Toggle Manual Fly Mode to control the camera with WASD (W: forward, S: back, A: left, D: right) and
                Q/E
                (up/down).
            </div>
            <!-- Tutorial Button -->
            <button id="showTutorial">Show Tutorial</button>

            <!-- Download link container -->
            <div id="downloadContainer"></div>
        </div>
        <div id="hoverTooltip" class="tooltip"></div>
        <div id="selectedTooltip" class="tooltip">
            <span class="close-btn" title="Close Tooltip">‚úñ</span>
            <span class="content"></span>
        </div>
        <div id="loadingIndicator">
            <div id="loadingMessage">Loading Data...</div>
            <progress id="loadingProgress" value="0" max="100"></progress>
        </div>
        <!-- Recording Indicator -->
        <div id="recordingIndicator">Recording...</div>
        <!-- Tutorial Modal -->
        <div id="tutorialModal">
            <button id="closeTutorial">‚úñ Close</button>
            <div class="modal-content">
                <h2>3D Mouse Brain Visualization Tutorial</h2>
                <p>
                    <strong>Step 1 ‚Äì Loading Data:</strong><br>
                    <span class="icon">üìÇ</span>
                    Click the <strong>Load Brain Data (CSV)</strong> input on the left sidebar to select your CSV file
                    containing brain data.
                    The file is parsed and visualized automatically.
                </p>
                <p>
                    <strong>Step 2 ‚Äì Using the Collapsible Left Sidebar:</strong><br>
                    <span class="icon">üóÑÔ∏è</span>
                    All main controls‚Äîfile input, region filtering, and intensity mapping‚Äîare organized in a stylish,
                    collapsible left sidebar.
                    Click the sidebar‚Äôs toggle button (with an arrow icon) to hide or reveal these elements,
                    giving you an unobstructed 3D view.
                </p>
                <p>
                    <strong>Step 3 ‚Äì Adjusting the View:</strong><br>
                    <span class="icon">üîç</span>
                    Use the view buttons (View X, Y, Z) and Zoom In/Out controls to position your camera.
                    The <strong>Reset View</strong> button re-centers your scene.
                </p>
                <p>
                    <strong>Step 4 ‚Äì Filtering Regions:</strong><br>
                    <span class="icon">üé®</span>
                    In the Region Filtering panel, each row displays a color box (click to change its color), a label
                    showing the region acronym and full name, and a checkbox to toggle both visibility and fly‚Äìthrough
                    selection.
                </p>
                <p>
                    <strong>Step 5 ‚Äì Intensity Mapping:</strong><br>
                    <span class="icon">‚öôÔ∏è</span>
                    Adjust settings like Raw Min, Raw Max, and Gray Contrast to fine‚Äìtune how data intensity is
                    visualized,
                    especially when using Grayscale Mode.
                </p>
                <p>
                    <strong>Step 6 ‚Äì Enhanced Camera Controls:</strong><br>
                    <span class="icon">‚úàÔ∏è</span>
                    Experience advanced camera manipulation using intuitive controls:
                    <br>
                    ‚Ä¢ <strong>Yaw (Left/Right):</strong> Rotate the camera like an airplane banking left or right.
                    <br>
                    ‚Ä¢ <strong>Pitch (Up/Down):</strong> Tilt the camera as if the airplane is climbing or descending.
                    <br>
                    ‚Ä¢ <strong>Roll (Left/Right):</strong> Tilt the camera along its forward axis to change the horizon.
                    <br>
                    ‚Ä¢ <strong>Reset:</strong> Restore the camera to its default orientation.
                </p>
                <p>
                    <strong>Step 7 ‚Äì Capturing Your Scene:</strong><br>
                    <span class="icon">üì∏</span>
                    Click the <strong>Download PNG</strong> button in the top right to capture the current rendered
                    scene as a PNG file,
                    which downloads automatically.
                </p>
                <p>
                    <strong>Step 8 ‚Äì Keyframe Animation & Video Recording:</strong><br>
                    <span class="icon">üé•</span>
                    Capture keyframes by clicking <strong>Capture Keyframe</strong> and play a guided tour with
                    <strong>Start Keyframe Animation</strong>.
                    Record your session by clicking <strong>Start Recording</strong> followed by <strong>Stop
                        Recording</strong>;
                    a download link for the video will appear.
                </p>
                <p>
                    <strong>Step 9 ‚Äì Fly‚ÄìThrough Mode & Manual Navigation:</strong><br>
                    <span class="icon">‚úàÔ∏è</span>
                    Enjoy automated fly‚Äìthrough of selected regions, or switch to Manual Fly Mode to navigate using WASD
                    (with Q/E for vertical movement).
                    You can also use additional keyboard shortcuts (e.g., X, Y, Z, 1/2/3, etc.) for more control.
                </p>
            </div>
        </div>

    </div>
    <!-- Toggle Button (outside the sidebar) -->
    <button id="toggleSidebarButton">&#9664;</button>

    <!-- Postprocessing scripts from Three.js examples -->
    <!-- *** Dependencies for EffectComposer *** -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/Pass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <!-- Postprocessing & Controls scripts from Three.js examples (from unpkg) -->
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <!-- *** Dependency for UnrealBloomPass *** -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <!-- Added this line -->
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>


    <!-- Main Script -->
    <script>

        // Utility: Returns a random number in the range [min, max).
        function randomRange(min, max) {
            return Math.random() * (max - min) + min;
        }
        // ===== Neuron Firing & Cortical Connectivity Simulation REFACTORED =====
        // --- Texture Generation ---
        function createGlowTexture(color = 'white', size = 128) {
            // Create a canvas and its 2D context.
            const canvas = document.createElement("canvas");
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext("2d");

            // Determine center and radius.
            const center = size / 2;
            const radius = center;

            // Define colors for the gradient.
            // For the "white" base, we use a set of stops that remain mostly neutral.
            // For "electric" effect, we add blue tones.
            let innerColor, midColor, outerColor;
            if (color === 'white') {
                innerColor = "rgba(255,255,255,1)";
                midColor = "rgba(200,200,200,0.8)";
                outerColor = "rgba(0,0,0,0)";
            } else {
                // Electric blue variant:
                innerColor = "rgba(255,255,255,1)";                  // Center bright white
                midColor = "rgba(50,150,255,0.8)";                  // Transition to electric blue
                outerColor = "rgba(0,0,50,0)";                        // Fade out to transparent deep blue
            }

            // Create a radial gradient from center to edge.
            const gradient = context.createRadialGradient(center, center, 0, center, center, radius);
            gradient.addColorStop(0, innerColor);
            gradient.addColorStop(0.4, midColor);
            gradient.addColorStop(1, outerColor);

            // Draw the gradient over the whole canvas.
            context.fillStyle = gradient;
            context.fillRect(0, 0, size, size);

            // Retrieve the pixel data so we can modify it.
            const imageData = context.getImageData(0, 0, size, size);
            const data = imageData.data;

            // Parameters to control the ripple (propagation) effect.
            const rippleFrequency = 10;  // How many ripples are visible from center to edge.
            const rippleAmplitude = 0.2; // How much the ripple affects the alpha value.

            // For each pixel, add a sine ripple based on the distance from the center plus random noise.
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const idx = (y * size + x) * 4;
                    // Compute the normalized distance from the center (0 at center, 1 at edge).
                    const dx = x - center;
                    const dy = y - center;
                    const d = Math.sqrt(dx * dx + dy * dy) / radius;

                    // Get the original alpha (0 - 1)
                    let origAlpha = data[idx + 3] / 255;

                    // Create a ripple using a sine wave.
                    // This produces concentric rings of higher and lower intensity.
                    const ripple = Math.sin(d * rippleFrequency * Math.PI) * rippleAmplitude;

                    // Add some random noise for a jagged, electric appearance.
                    const noise = (Math.random() - 0.5) * 0.2;  // Random number in approximately [-0.1, 0.1]

                    // Mix the original alpha with the ripple and noise.
                    let newAlpha = origAlpha + ripple + noise;
                    // Clamp the alpha value to the valid range.
                    newAlpha = Math.min(1, Math.max(0, newAlpha));

                    // Write the new alpha back; RGB remains as generated by the gradient.
                    data[idx + 3] = newAlpha * 255;
                }
            }

            // Update the canvas with the modified pixel data.
            context.putImageData(imageData, 0, 0);

            // Create and return a Three.js texture from the canvas.
            return new THREE.CanvasTexture(canvas);
        }

        // --- Neuron Class (Hodgkin-Huxley Inspired Model) ---
        class Neuron {
            /**
             * Represents a single neuron with Hodgkin-Huxley-like dynamics.
             * @param {THREE.Vector3} position - The 3D position of the neuron.
             * @param {string} type - "excitatory" or "inhibitory".
             * @param {number} simIndex - The index of this neuron within the simulation array.
             * @param {object} params - Simulation parameters reference.
             */
            constructor(position, type, simIndex, params) {
                this.position = position.clone(); // THREE.Vector3
                this.type = type;                 // "excitatory" or "inhibitory"
                this.index = simIndex;            // Index in the network simulation's neuron array
                this.params = params;             // Reference to global simulation parameters

                // Membrane Potential and Gating Variables (Hodgkin-Huxley)
                this.V = -65.0; // Membrane potential (mV) - resting potential
                this.m = 0.05;  // Sodium channel activation
                this.h = 0.60;  // Sodium channel inactivation
                this.n = 0.32;  // Potassium channel activation

                // Neuron State
                this.isFiring = false;          // Current spike state
                this.lastSpikeTime = -Infinity; // Time of the last spike (ms)
                this.refractoryUntil = -Infinity; // Time until the neuron can spike again (ms)

                // HH Model Constants (Typical values, can be adjusted)
                this.C_m = 1.0;    // Membrane capacitance (uF/cm^2)
                this.g_Na = 120.0; // Max sodium conductance (mS/cm^2)
                this.g_K = 36.0;   // Max potassium conductance (mS/cm^2)
                this.g_L = 0.3;    // Leak conductance (mS/cm^2)
                this.E_Na = 50.0;  // Sodium reversal potential (mV)
                this.E_K = -77.0;  // Potassium reversal potential (mV)
                this.E_L = -54.387;// Leak reversal potential (mV)
            }

            // --- HH Rate Functions (alpha/beta for gating variables) ---
            // Using standard formulations, checking for V near critical points to avoid NaN/Infinity
            alpha_m(V) { const d = V + 40; return Math.abs(d) < 1e-4 ? 1.0 : (0.1 * d) / (1 - Math.exp(-d / 10)); }
            beta_m(V) { return 4.0 * Math.exp(-(V + 65) / 18); }
            alpha_h(V) { return 0.07 * Math.exp(-(V + 65) / 20); }
            beta_h(V) { return 1.0 / (1 + Math.exp(-(V + 35) / 10)); }
            alpha_n(V) { const d = V + 55; return Math.abs(d) < 1e-4 ? 0.1 : (0.01 * d) / (1 - Math.exp(-d / 10)); }
            beta_n(V) { return 0.125 * Math.exp(-(V + 65) / 80); }

            /**
             * Update the neuron's state over a single time step using Forward Euler integration.
             * @param {number} dt_ms - Time step duration in milliseconds.
             * @param {number} I_syn - Total synaptic input current received in this step.
             * @param {number} currentTime_ms - The current simulation time in milliseconds.
             */
            update(dt_ms, I_syn, currentTime_ms) {
                // --- Refractory Period ---
                if (currentTime_ms < this.refractoryUntil) {
                    // Simple voltage decay towards leak reversal during refractory period
                    // this.V += (dt_ms / this.C_m) * (this.g_L * (this.E_L - this.V)); // Simplified recovery
                    // Keep voltage clamped low after spike? Or let it naturally recover via HH? Letting it recover seems more realistic.
                    this.isFiring = false; // Ensure firing state is off during refractory
                    // return; // Option 1: Exit early. Option 2: Still calculate dynamics but prevent spiking. Let's do Option 2.
                }

                const V = this.V;
                const dt_sec = dt_ms / 1000.0; // Convert dt to seconds for rate calculations

                // --- Update Gating Variables (using Forward Euler for simplicity) ---
                // More stable methods like Exponential Euler or RK4 could be used for higher accuracy if needed.
                const am = this.alpha_m(V), bm = this.beta_m(V);
                const ah = this.alpha_h(V), bh = this.beta_h(V);
                const an = this.alpha_n(V), bn = this.beta_n(V);

                this.m += dt_ms * (am * (1 - this.m) - bm * this.m);
                this.h += dt_ms * (ah * (1 - this.h) - bh * this.h);
                this.n += dt_ms * (an * (1 - this.n) - bn * this.n);

                // Clamp gating variables to [0, 1] - helps stability with Euler
                this.m = Math.max(0, Math.min(1, this.m));
                this.h = Math.max(0, Math.min(1, this.h));
                this.n = Math.max(0, Math.min(1, this.n));

                // --- Calculate Ionic Currents ---
                const I_Na = this.g_Na * Math.pow(this.m, 3) * this.h * (V - this.E_Na);
                const I_K = this.g_K * Math.pow(this.n, 4) * (V - this.E_K);
                const I_Leak = this.g_L * (V - this.E_L);

                // --- External Drive Current (Tuning Parameter) ---
                const baseDrive = (this.type === 'excitatory') ? this.params.baseExcitatoryDrive : this.params.baseInhibitoryDrive;
                const omega = 2 * Math.PI * this.params.gammaFrequency; // Radians per second
                const I_osc = this.params.gammaAmplitude * Math.sin(omega * (currentTime_ms / 1000.0)); // Oscillatory input
                const I_ext = baseDrive + I_osc; // Total external current

                // --- Update Membrane Potential (dV/dt = (I_ext + I_syn - I_ion) / C_m) ---
                this.V += (dt_sec / this.C_m) * (I_ext + I_syn - I_Na - I_K - I_Leak);

                // --- Spike Detection ---
                const spikeThreshold = 0.0; // mV (Adjust as needed)
                const previouslyFiring = this.isFiring;

                // Check for upward threshold crossing AND if not refractory
                if (!previouslyFiring && this.V > spikeThreshold && currentTime_ms >= this.refractoryUntil) {
                    this.isFiring = true;
                    this.lastSpikeTime = currentTime_ms;
                    this.refractoryUntil = currentTime_ms + this.params.refractoryPeriodMs;
                    // Optional: Clamp voltage during spike peak for visual effect or model simplicity
                    this.V = 40.0; // Set to a peak value
                } else if (previouslyFiring && this.V < (spikeThreshold - 10.0)) {
                    // Reset firing state after repolarization
                    this.isFiring = false;
                }
            }
        }

        // --- Compartmental Neuron Class ---
        class CompartmentalNeuron {
            /**
             * Represents a neuron with multiple compartments (Soma + Dendrite example).
             * @param {THREE.Vector3} somaPosition - The 3D position of the soma.
             * @param {string} type - "excitatory" or "inhibitory".
             * @param {number} simIndex - The index of this neuron within the simulation array.
             * @param {object} params - Simulation parameters reference.
             */
            constructor(somaPosition, type, simIndex, params) {
                this.neuronType = type;           // 'excitatory' or 'inhibitory'
                this.index = simIndex;            // Index in the network simulation's neuron array
                this.params = params;             // Reference to global simulation parameters

                this.compartments = [];
                this.connections = []; // Store axial connections between compartments

                // --- Define Compartments ---
                // Compartment 0: Soma
                const somaComp = {
                    id: 0,
                    name: 'soma',
                    position: somaPosition.clone(),
                    // State Variables
                    V: -65.0, m: 0.05, h: 0.60, n: 0.32,
                    // Parameters (Example: Soma might have higher Na/K density)
                    C_m: 1.0,    // uF/cm^2 (using area implicitly for now)
                    g_Na: 150.0, // mS/cm^2
                    g_K: 40.0,   // mS/cm^2
                    g_L: 0.3,    // mS/cm^2
                    E_Na: 50.0,  // mV
                    E_K: -77.0,  // mV
                    E_L: -54.387 // mV
                };
                this.compartments.push(somaComp);

                // Compartment 1: Dendrite (Example: slightly offset, different conductances)
                // Position relative to soma for visualization simplicity
                const dendriteOffset = new THREE.Vector3(
                    params.connectivityRadiusW * 0.1 * (Math.random() - 0.5), // Smaller offset based on connectivity radius
                    params.connectivityRadiusW * 0.1 * (Math.random() - 0.5),
                    params.connectivityRadiusW * 0.1 * (Math.random() - 0.5)
                );
                const dendritePosition = somaPosition.clone().add(dendriteOffset);

                const dendriteComp = {
                    id: 1,
                    name: 'dendrite',
                    position: dendritePosition,
                    // State Variables (start at resting potential)
                    V: -65.0, m: 0.05, h: 0.60, n: 0.32,
                    // Parameters (Example: Dendrite might have lower Na/K, higher Leak)
                    C_m: 1.0,
                    g_Na: 50.0,  // Lower active conductance
                    g_K: 15.0,
                    g_L: 0.5,    // Higher leak
                    E_Na: 50.0,
                    E_K: -77.0,
                    E_L: -54.387
                };
                this.compartments.push(dendriteComp);

                // --- Define Axial Connections ---
                // Connect Soma (0) and Dendrite (1)
                const R_axial = 50.0; // Axial resistance (MOhm) - TUNING PARAMETER
                this.connections.push({ from: 0, to: 1, R_axial: R_axial });
                this.connections.push({ from: 1, to: 0, R_axial: R_axial }); // Bidirectional

                // --- Neuron State (Based on Soma) ---
                this._isFiring = false;         // Use a getter/setter or method
                this.lastSpikeTime = -Infinity; // Time of the last spike (ms) - based on soma
                this.refractoryUntil = -Infinity; // Time until the soma can spike again (ms)

                // Pre-allocate arrays for calculations within update
                this.dVdt = new Float32Array(this.compartments.length);
                this.I_ion = new Float32Array(this.compartments.length);
                this.I_axial = new Float32Array(this.compartments.length);
                // Simplified: We'll calculate synaptic current externally for now
            }

            // --- HH Rate Functions (same as before) ---
            alpha_m(V) { const d = V + 40; return Math.abs(d) < 1e-4 ? 1.0 : (0.1 * d) / (1 - Math.exp(-d / 10)); }
            beta_m(V) { return 4.0 * Math.exp(-(V + 65) / 18); }
            alpha_h(V) { return 0.07 * Math.exp(-(V + 65) / 20); }
            beta_h(V) { return 1.0 / (1 + Math.exp(-(V + 35) / 10)); }
            alpha_n(V) { const d = V + 55; return Math.abs(d) < 1e-4 ? 0.1 : (0.01 * d) / (1 - Math.exp(-d / 10)); }
            beta_n(V) { return 0.125 * Math.exp(-(V + 65) / 80); }

            /**
             * Update the neuron's state over a single time step using Forward Euler integration.
             * @param {number} dt_ms - Time step duration in milliseconds.
             * @param {Float32Array | number} I_syn_per_compartment - Synaptic input current PER COMPARTMENT (or single value applied to soma if number).
             * @param {number} currentTime_ms - The current simulation time in milliseconds.
             */
            update(dt_ms, I_syn_per_compartment, currentTime_ms) {
                const dt_sec = dt_ms / 1000.0;
                const currentTime_sec = currentTime_ms / 1000.0; // Time in seconds for oscillation

                // --- Refractory Period Check (applied based on soma state) ---
                const isRefractory = currentTime_ms < this.refractoryUntil;
                if (this._isFiring && isRefractory) {
                    // If currently marked as firing but still refractory, turn off firing state
                    // Voltage recovery happens naturally via dynamics
                    this._isFiring = false;
                }

                // --- 1. Calculate dV/dt for all compartments ---
                this.I_ion.fill(0);
                this.I_axial.fill(0);
                this.dVdt.fill(0);

                // Calculate Axial Currents first (using voltages from *previous* step)
                this.connections.forEach(conn => {
                    const V_from = this.compartments[conn.from].V;
                    const V_to = this.compartments[conn.to].V;
                    // Check for valid R_axial to prevent NaN/Infinity
                    const axialCurrent = conn.R_axial !== 0 ? (V_from - V_to) / conn.R_axial : 0; // Current flowing *out* of 'to', *into* 'from'
                    this.I_axial[conn.to] -= axialCurrent; // Current leaving 'to'
                    // this.I_axial[conn.from] += axialCurrent; // Current entering 'from' - redundant due to bidirectional connections loop
                });


                // Calculate Ionic Currents and dV/dt for each compartment
                this.compartments.forEach((comp, i) => {
                    const V = comp.V;

                    // --- Calculate Ionic Currents (using HH logic for this compartment) ---
                    const I_Na = comp.g_Na * Math.pow(comp.m, 3) * comp.h * (V - comp.E_Na);
                    const I_K = comp.g_K * Math.pow(comp.n, 4) * (V - comp.E_K);
                    const I_Leak = comp.g_L * (V - comp.E_L);
                    this.I_ion[i] = I_Na + I_K + I_Leak; // Total *outward* ionic current

                    // --- External Drive Current ---
                    let I_ext = 0;
                    // Apply base drive and gamma ONLY to the SOMA (index 0) for this example
                    if (i === 0) {
                        const baseDrive = (this.neuronType === 'excitatory') ? this.params.baseExcitatoryDrive : this.params.baseInhibitoryDrive;
                        const omega = 2 * Math.PI * this.params.gammaFrequency; // Radians per second
                        const I_osc = this.params.gammaAmplitude * Math.sin(omega * currentTime_sec);
                        I_ext = baseDrive + I_osc;
                    }

                    // --- Synaptic Current ---
                    let I_syn = 0;
                    // Simplified: Apply passed-in current. A full implementation needs compartment targeting.
                    if (typeof I_syn_per_compartment === 'number') {
                        // If single value, apply only to soma (index 0) for now
                        if (i === 0) I_syn = I_syn_per_compartment;
                    } else if (I_syn_per_compartment instanceof Float32Array && i < I_syn_per_compartment.length) {
                        // Apply compartment-specific current if array is provided
                        I_syn = I_syn_per_compartment[i];
                    }


                    // --- Calculate Membrane Potential Change ---
                    // dV/dt = (I_ext + I_syn - I_ion + I_axial) / C_m
                    // Note: I_ion is outward (+), others inward (+) except I_axial sign depends on voltage difference
                    this.dVdt[i] = (I_ext + I_syn - this.I_ion[i] + this.I_axial[i]) / comp.C_m;
                });

                // --- 2. Update Voltages and Gating Variables for all compartments ---
                this.compartments.forEach((comp, i) => {
                    // Update Voltage
                    comp.V += this.dVdt[i] * dt_sec;


                    // Update Gating Variables (using voltage at start of step for rates - V_old)
                    // Let's recalculate rates using the voltage *before* the update for stability
                    const V_old = comp.V - this.dVdt[i] * dt_sec; // Approximate V at start of step
                    // from start of step. Revert V update placement? No, paper formulas use V(t). Stick with updated V.
                    const am = this.alpha_m(V_old), bm = this.beta_m(V_old);
                    const ah = this.alpha_h(V_old), bh = this.beta_h(V_old);
                    const an = this.alpha_n(V_old), bn = this.beta_n(V_old);

                    comp.m += dt_ms * (am * (1 - comp.m) - bm * comp.m);
                    comp.h += dt_ms * (ah * (1 - comp.h) - bh * comp.h);
                    comp.n += dt_ms * (an * (1 - comp.n) - bn * comp.n);

                    // Clamp gating variables
                    comp.m = Math.max(0, Math.min(1, comp.m));
                    comp.h = Math.max(0, Math.min(1, comp.h));
                    comp.n = Math.max(0, Math.min(1, comp.n));
                });

                // --- 3. Spike Detection (Based on Soma - Compartment 0) ---
                const somaV = this.compartments[0].V;
                const spikeThreshold = 0.0; // mV
                const previouslyFiring = this._isFiring;

                if (!previouslyFiring && !isRefractory && somaV > spikeThreshold) {
                    this._isFiring = true;
                    this.lastSpikeTime = currentTime_ms;
                    this.refractoryUntil = currentTime_ms + this.params.refractoryPeriodMs;
                    // console.log(`Neuron ${this.index} SOMA SPIKED at ${currentTime_ms.toFixed(1)} ms`);
                } else if (previouslyFiring && somaV < (spikeThreshold - 10.0)) {
                    // Reset firing state after repolarization (if it wasn't already reset by refractory check)
                    this._isFiring = false;
                }
                // Note: _isFiring becomes false automatically when refractory period ends if voltage is low,
                // or manually reset above if still refractory but marked firing.
            }

            // Method to check if the neuron (specifically soma) is currently firing
            isFiring() {
                // Check the internal flag AND ensure we are past the absolute refractory period start.
                // This prevents visualization glitches where it might be marked firing briefly before refractory logic applies.
                return this._isFiring && (performance.now() >= this.lastSpikeTime);
            }

            // Getter for soma position (useful for visuals)
            get position() {
                return this.compartments[0].position;
            }
            // Getter for neuron type
            get type() {
                return this.neuronType;
            }
        }


        // Constants for StylizedNeuron firing effect
        const FIRING_PULSE_COLOR = new THREE.Color(0xffff00); // Bright yellow
        const FIRING_PULSE_WIDTH = 0.15; // Normalized width of the pulse
        const FIRING_SPEED = 1.5; // Normalized distance per second
        const FIRING_COOLDOWN = 0.3; // Minimum seconds between firings
        const AUTO_FIRE_CHANCE = 0.5; // Chance per frame to fire (if not cooling down)
        const originalEmissiveColors = new Map(); // To store original emissive states

        // ---Stylized Neuron Class ---
        class StylizedNeuron {
            constructor(position, color, originalIndex, branchCount = 8, maxDepth = 4) { // Reduced defaults slightly
                this.group = new THREE.Group();
                this.position = position;
                this.color = color; // Base color from region
                this.originalDataIndex = originalIndex; // Store the index from the original CSV data
                //this.dendriteColor = color.clone().lerp(new THREE.Color(0xaaaaaa), 0.3); // Blend with gray
                this.dendriteColor = color.clone().multiplyScalar(0.8); // Slightly different color for dendrites
                this.axonColor = new THREE.Color(0xaaaaff); // Distinct axon color
                this.branchCount = branchCount;
                this.maxDepth = maxDepth;

                this.axonCurve = null;
                this.terminalMeshes = [];
                this.axonMesh = null;
                this.myelinMeshes = [];

                // Firing state
                this.isFiring = false;
                this.fireProgress = 0;
                this.fireSpeed = FIRING_SPEED;
                this.pulseColor = FIRING_PULSE_COLOR;
                this.pulseWidth = FIRING_PULSE_WIDTH;
                this.lastFireTime = -FIRING_COOLDOWN;
                this.fireCooldown = FIRING_COOLDOWN;

                // Reference to the soma mesh for easy access
                this.somaMesh = null;
                this.baseSomaRadius = 20; // Define a base radius for scaling
                this.somaSale = 0.8;
                this.baseEmissiveColor = this.color.clone().multiplyScalar(1.1);

                this.createSoma();
                this.createDendrites();
                this.createAxon();
            }

            // --- Method to update ONLY the soma scale ---

            updateSomaScale(currentPointSize) { // Accept argument
                if (!this.somaMesh) return; // Guard clause

                // Map pointSize (1-50) to a desired soma radius range
                const minPointSize = 1;
                const maxPointSize = 50;
                const minSomaRadius = 0.2; // Smallest visual radius for soma
                const maxSomaRadius = 2.5; // Largest visual radius for soma

                // Use the passed argument
                const pointSizeNormalized = Math.max(0, Math.min(1,
                    (currentPointSize - minPointSize) / (maxPointSize - minPointSize)
                ));

                // Calculate the target visual radius
                const targetRadius = minSomaRadius + pointSizeNormalized * (maxSomaRadius - minSomaRadius);

                // Calculate the scale factor needed based on the base geometry radius
                const scaleFactor = targetRadius / this.baseSomaRadius; // Scale factor

                // Apply the scale to the somaMesh
                this.somaMesh.scale.setScalar(scaleFactor);
            }

            createSoma() {
                const somaGeometry = new THREE.SphereGeometry(this.baseSomaRadius, 32, 32); // Slightly larger, fewer segments
                const positions = somaGeometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    const vertex = new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]);
                    const length = vertex.length();
                    vertex.normalize();
                    const noiseFactor = 0.1 * this.baseSomaRadius;
                    const noise = 1.0 + (Math.sin(vertex.x * 8) * Math.cos(vertex.y * 8) * Math.sin(vertex.z * 8)) * noiseFactor;
                    vertex.multiplyScalar(length * noise);
                    positions[i] = vertex.x; positions[i + 1] = vertex.y; positions[i + 2] = vertex.z;
                }
                somaGeometry.attributes.position.needsUpdate = true;
                somaGeometry.computeVertexNormals();

                const somaMaterial = new THREE.MeshPhongMaterial({
                    color: this.color, // Use the region color
                    transparent: true,
                    opacity: 0.9,
                    shininess: 60,
                    emissive: new THREE.Color(0x000000), // Add emissive property
                    emissiveIntensity: 0 // start with 0 intensity for default flash
                });
                this._storeOriginalEmissive(somaMaterial); // Store initial state

                this.somaMesh = new THREE.Mesh(somaGeometry, somaMaterial); // Store reference
                this.somaMesh.position.copy(this.position);
                this.somaMesh.userData.type = 'soma'; // Identify part
                this.group.add(this.somaMesh);

                // Optional subtle light
                const light = new THREE.PointLight(this.color, 0.2, 5);
                light.position.copy(this.position);
                this.group.add(light);
            }

            createDendrites() {
                for (let i = 0; i < this.branchCount; i++) {
                    const phi = Math.acos(-1 + (2 * i) / this.branchCount);
                    const theta = Math.sqrt(this.branchCount * Math.PI) * phi;
                    const direction = new THREE.Vector3().setFromSphericalCoords(1, phi, theta);
                    this.createBranch(this.position, direction, 4, 0, true); // Start dendrites
                }
            }

            createBranch(start, direction, length, depth, isDendrite) {
                if (depth >= this.maxDepth) return null;

                const points = [];
                const segments = 10; // Fewer segments per branch
                let currentPos = start.clone();
                points.push(currentPos.clone());
                const branchColor = isDendrite ? this.dendriteColor : this.axonColor.clone().lerp(this.color, 0.5); // Axon terminals blend region color

                for (let i = 1; i <= segments; i++) {
                    const t = i / segments;
                    const offset = direction.clone().multiplyScalar(length * t);
                    // Noise based on Perlin or Simplex would be better, but random for now
                    const noiseScale = 0.4 * (1 - t) * (1 / (depth + 1));

                    const tangent = direction.clone();
                    const randomAxis = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
                    const perpendicular = tangent.cross(randomAxis).normalize();
                    const noisyOffset = offset.add(perpendicular.multiplyScalar((Math.random() - 0.5) * noiseScale * 2));

                    currentPos = start.clone().add(noisyOffset);
                    points.push(currentPos.clone());
                }

                // Simple smoothing/filtering (can be improved)
                const filteredPoints = [points[0]];
                for (let i = 1; i < points.length - 1; i++) {
                    if (points[i].distanceTo(filteredPoints[filteredPoints.length - 1]) > 0.05) { // Min distance between points
                        filteredPoints.push(points[i]);
                    }
                }
                if (filteredPoints.length < 2) return null; // Need at least 2 points

                const curve = new THREE.CatmullRomCurve3(filteredPoints); // Lower tension
                const radius = 0.15 * Math.pow(0.65, depth); // Branch radius tapers
                const tubeSegments = Math.max(5, 20 - depth * 3);
                const radialSegments = Math.max(4, 8 - depth);

                const tubeGeometry = new THREE.TubeGeometry(curve, tubeSegments, radius, radialSegments, false);
                const tubeMaterial = new THREE.MeshPhongMaterial({
                    color: branchColor,
                    emissive: new THREE.Color(0x000000),
                    transparent: true,
                    opacity: 0.7 - depth * 0.1,
                    shininess: 40
                });
                this._storeOriginalEmissive(tubeMaterial);

                const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
                tube.userData.type = isDendrite ? 'dendrite' : 'axon_terminal';
                tube.userData.curve = curve;
                tube.userData.depth = depth;
                this.group.add(tube);

                if (!isDendrite) {
                    this.terminalMeshes.push(tube);
                }

                const endPos = filteredPoints[filteredPoints.length - 1];
                const endTangent = curve.getTangentAt(1).normalize();

                // Branching logic
                const subBranchCount = (depth < this.maxDepth - 1) ? Math.floor(Math.random() * 2) + (isDendrite ? 1 : 0) : 0; // Dendrites branch more maybe
                for (let i = 0; i < subBranchCount; i++) {
                    const angleDeviation = (Math.random() - 0.5) * Math.PI * (isDendrite ? 0.7 : 0.9); // Terminals spread more
                    const axis = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
                    const newDirection = endTangent.clone().applyAxisAngle(axis, angleDeviation).normalize();
                    this.createBranch(endPos, newDirection, length * (0.5 + Math.random() * 0.3), depth + 1, isDendrite);
                }

                // Synaptic bouton only at terminal ends
                if (!isDendrite && subBranchCount === 0) {
                    const tipGeometry = new THREE.SphereGeometry(radius * 1.3, 6, 6);
                    const tipMaterial = new THREE.MeshPhongMaterial({
                        color: branchColor,
                        emissive: new THREE.Color(0x000000), // Initialize emissive
                        transparent: true, opacity: 0.8, shininess: 50
                    });
                    this._storeOriginalEmissive(tipMaterial);

                    const tip = new THREE.Mesh(tipGeometry, tipMaterial);
                    tip.position.copy(endPos);
                    tip.userData.type = 'axon_terminal_tip'; // Identify part
                    tip.userData.parentBranch = tube; // Link to parent branch
                    this.group.add(tip);
                    this.terminalMeshes.push(tip); // Also make tips glow
                }
                return tube; // Return the created mesh
            }

            createAxon() {
                const axonLength = 12; // Slightly longer axon
                const startDirection = new THREE.Vector3(0, -1, (Math.random() - 0.5) * 0.3).normalize(); // Start downwards
                const points = [];
                const segments = 40;
                let currentPos = this.position.clone().add(startDirection.clone().multiplyScalar(0.8)); // Start slightly off soma
                let currentDir = startDirection.clone();
                points.push(currentPos.clone());

                for (let i = 1; i <= segments; i++) {
                    const segmentLength = axonLength / segments;
                    const angleDeviation = (Math.random() - 0.5) * Math.PI * 0.08; // More curvy
                    const axis = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
                    currentDir.applyAxisAngle(axis, angleDeviation).normalize();
                    const offset = currentDir.clone().multiplyScalar(segmentLength);
                    currentPos.add(offset);
                    points.push(currentPos.clone());
                }

                const filteredPoints = [points[0]];
                for (let i = 1; i < points.length; i++) {
                    if (points[i].distanceTo(filteredPoints[filteredPoints.length - 1]) > 0.05) {
                        filteredPoints.push(points[i]);
                    }
                }
                if (filteredPoints.length < 2) return;

                this.axonCurve = new THREE.CatmullRomCurve3(filteredPoints); // Store the curve
                this.axonCurve.needsUpdate = true; // Ensure arc length divisions are computed
                this.axonCurve.arcLengthDivisions = 200; // Increase precision for getPointAt
                this.axonCurve.updateArcLengths();


                const axonRadius = 0.07;
                const axonGeometry = new THREE.TubeGeometry(this.axonCurve, 100, axonRadius, 8, false); // More segments
                const axonMaterial = new THREE.MeshPhongMaterial({
                    color: this.axonColor,
                    emissive: new THREE.Color(0x000000), // Initialize emissive
                    transparent: true,
                    opacity: 0.9,
                    shininess: 70
                });
                this._storeOriginalEmissive(axonMaterial);

                this.axonMesh = new THREE.Mesh(axonGeometry, axonMaterial); // Store mesh
                this.axonMesh.userData.type = 'axon';
                this.group.add(this.axonMesh);

                // Myelin Sheath
                const myelinSegmentCount = Math.floor(axonLength / 1.2);
                const nodeGap = 0.15;

                for (let i = 0; i < myelinSegmentCount; i++) {
                    const segmentStartT = (i * (1.0 / myelinSegmentCount));
                    const segmentEndT = ((i + 1) * (1.0 / myelinSegmentCount)) - (nodeGap / this.axonCurve.getLength()); // Use curve length

                    if (segmentEndT <= segmentStartT) continue;

                    const myelinPoints = this.axonCurve.getPoints(100).filter((p, index, arr) => {
                        const t = this.axonCurve.getUtoTmapping(index / (arr.length - 1)); // Use arc length mapping
                        return t >= segmentStartT && t <= segmentEndT;
                    });

                    if (myelinPoints.length < 2) continue;

                    const myelinCurve = new THREE.CatmullRomCurve3(myelinPoints);
                    const myelinGeometry = new THREE.TubeGeometry(myelinCurve, Math.max(4, myelinPoints.length), axonRadius * 1.6, 8, false);
                    const myelinMaterial = new THREE.MeshPhongMaterial({
                        color: 0xffffff,
                        emissive: new THREE.Color(0x000000), // Initialize emissive
                        transparent: true, opacity: 0.6, shininess: 100
                    });
                    this._storeOriginalEmissive(myelinMaterial);

                    const myelinSegment = new THREE.Mesh(myelinGeometry, myelinMaterial);
                    myelinSegment.userData.type = 'myelin';
                    myelinSegment.userData.tStart = segmentStartT; // Store normalized start/end
                    myelinSegment.userData.tEnd = segmentEndT;
                    this.group.add(myelinSegment);
                    this.myelinMeshes.push(myelinSegment); // Store myelin mesh
                }

                // Axon Terminals
                const axonEnd = this.axonCurve.getPointAt(1);
                const axonEndTangent = this.axonCurve.getTangentAt(1).normalize();
                const terminalBranchCount = 5 + Math.floor(Math.random() * 3); // More terminals (5-7)
                for (let i = 0; i < terminalBranchCount; i++) {
                    const angleDeviation = (Math.random() - 0.5) * Math.PI * 0.9;
                    const axis = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
                    const terminalDirection = axonEndTangent.clone().applyAxisAngle(axis, angleDeviation).normalize();
                    // Create terminal branches (max depth 2 for terminals, starting at depth 0)
                    this.createBranch(axonEnd, terminalDirection, 1.5 + Math.random(), 0, false);
                }
            }

            // --- Firing Logic ---
            _storeOriginalEmissive(material) {
                if (!originalEmissiveColors.has(material.uuid)) {
                    originalEmissiveColors.set(material.uuid, {
                        color: material.emissive.getHex(),
                        intensity: material.emissiveIntensity
                    });
                }
            }

            _restoreOriginalEmissive(material) {
                const original = originalEmissiveColors.get(material.uuid);
                if (original) {
                    material.emissive.setHex(original.color);
                    material.emissiveIntensity = original.intensity;
                } else {
                    material.emissive.setHex(0x000000); // Default fallback
                    material.emissiveIntensity = 1.0;
                }
            }

            startFiring() {
                if (!this.isFiring) {
                    const now = (typeof clock !== 'undefined' ? clock.getElapsedTime() : performance.now() / 1000);
                    //const now = clock.getElapsedTime();
                    if (now > this.lastFireTime + this.fireCooldown) {
                        this.isFiring = true;
                        this.fireProgress = 0;
                        this.lastFireTime = now;
                        // Small flash on soma
                        const soma = this.group.children.find(c => c.userData.type === 'soma');
                        if (soma) {
                            soma.material.emissive.set(this.pulseColor);
                            soma.material.emissiveIntensity = 0.8;
                        }
                    }
                }
            }

            updateFiring(deltaTime) {
                if (!this.isFiring) return;

                this.fireProgress += this.fireSpeed * deltaTime;

                let pulseActive = false;

                // --- Apply to Axon ---
                if (this.axonMesh) {
                    const axonTStart = 0;
                    const axonTEnd = 1.0;
                    const pulseStart = this.fireProgress - this.pulseWidth / 2;
                    const pulseEnd = this.fireProgress + this.pulseWidth / 2;

                    // Check if pulse overlaps with the axon's range (0 to 1)
                    if (Math.max(axonTStart, pulseStart) < Math.min(axonTEnd, pulseEnd)) {
                        const intensity = Math.max(0, 1 - Math.abs(this.fireProgress - 0.5) * (2 / this.pulseWidth)); // Simple triangle pulse shape for demo
                        this.axonMesh.material.emissive.set(this.pulseColor);
                        this.axonMesh.material.emissiveIntensity = intensity * 1.5; // Make pulse bright
                        pulseActive = true;
                    } else {
                        this._restoreOriginalEmissive(this.axonMesh.material);
                    }
                }
                // --- Apply to Myelin Gaps (Nodes of Ranvier) ---
                this.myelinMeshes.forEach(myelin => {
                    // We actually want to brighten the *gaps* between myelin
                    // This is tricky with current structure. Simple approach:
                    // Briefly flash myelin *itself* as pulse passes its T range
                    const tStart = myelin.userData.tStart;
                    const tEnd = myelin.userData.tEnd;
                    const centerT = (tStart + tEnd) / 2;
                    const dist = Math.abs(this.fireProgress - centerT);

                    if (dist < this.pulseWidth / 2) {
                        const intensity = Math.max(0, 1 - dist * (2 / this.pulseWidth));
                        myelin.material.emissive.set(this.pulseColor);
                        myelin.material.emissiveIntensity = intensity * 0.5; // Less intense flash
                        pulseActive = true;
                    } else {
                        this._restoreOriginalEmissive(myelin.material);
                    }
                });


                // --- Apply to Terminals (after pulse passes axon end) ---
                const terminalStartTime = 1.0; // Start terminals when main pulse hits axon end
                if (this.fireProgress >= terminalStartTime) {
                    // Calculate progress along terminals (simplified: all fire simultaneously)
                    const terminalProgress = (this.fireProgress - terminalStartTime) * (this.fireSpeed * 0.8); // Slower in terminals maybe
                    const terminalPulseStart = terminalProgress - this.pulseWidth / 2;
                    const terminalPulseEnd = terminalProgress + this.pulseWidth / 2;


                    this.terminalMeshes.forEach(mesh => {
                        const isTip = mesh.userData.type === 'axon_terminal_tip';
                        const meshTStart = isTip ? 0.9 : 0; // Treat tips as point at end
                        const meshTEnd = 1.0;

                        // Check overlap (treating each terminal branch as normalized 0 to 1)
                        if (Math.max(meshTStart, terminalPulseStart) < Math.min(meshTEnd, terminalPulseEnd)) {
                            const intensity = Math.max(0, 1 - Math.abs(terminalProgress - 0.5) * (2 / this.pulseWidth));
                            mesh.material.emissive.set(this.pulseColor);
                            mesh.material.emissiveIntensity = intensity * (isTip ? 2.0 : 1.5); // Tips brighter
                            pulseActive = true;
                        } else {
                            this._restoreOriginalEmissive(mesh.material);
                        }
                    });
                } else {
                    // Ensure terminals are reset if pulse hasn't reached them yet
                    this.terminalMeshes.forEach(mesh => {
                        this._restoreOriginalEmissive(mesh.material);
                    });
                }


                // --- Reset ---
                // Total effective length is axon (1.0) + longest terminal path (approx 1.0)
                const totalFireLength = 2.0; // Approximate normalized length
                if (this.fireProgress > totalFireLength) {
                    this.isFiring = false;
                    // Ensure all parts are reset
                    const soma = this.group.children.find(c => c.userData.type === 'soma');
                    if (soma) this._restoreOriginalEmissive(soma.material);
                    if (this.axonMesh) this._restoreOriginalEmissive(this.axonMesh.material);
                    this.myelinMeshes.forEach(m => this._restoreOriginalEmissive(m.material));
                    this.terminalMeshes.forEach(m => this._restoreOriginalEmissive(m.material));
                }
            }

            // --- Dispose ---
            dispose() {
                // Dispose geometries and materials
                this.group.traverse((object) => {
                    if (object.isMesh) {
                        if (object.geometry) {
                            object.geometry.dispose();
                        }
                        if (object.material) {
                            if (Array.isArray(object.material)) {
                                object.material.forEach(material => {
                                    if (material.map) material.map.dispose();
                                    material.dispose();
                                });
                            } else {
                                if (object.material.map) object.material.map.dispose();
                                object.material.dispose();
                            }
                            // Clean up emissive cache link
                            originalEmissiveColors.delete(object.material.uuid);
                        }
                    } else if (object.isLight) {
                        // Lights don't have geometry/material to dispose in the same way
                    }
                });

                // Clear arrays
                this.terminalMeshes = [];
                this.myelinMeshes = [];
                this.axonCurve = null;
                this.axonMesh = null;
                this.somaMesh = null;
                // console.log("StylizedNeuron disposed");
            }
        } // End StylizedNeuron Class
        // --- Neural Network Simulation Class  ---
        class NeuralNetworkSimulation {
            /**
             * Manages the collection of neurons and their connections, handling simulation steps.
             * Works with Neuron or CompartmentalNeuron objects.
             * @param {Array<Neuron|CompartmentalNeuron>} neurons - Array of neuron objects.
             * @param {Array<object>} connections - Array of connection objects { from: index, to: index, weight: number, ... }
             * @param {object} params - Reference to the global simulation parameters object.
             */
            constructor(neurons, connections, params) {
                this.neurons = neurons;         // Array of Neuron OR CompartmentalNeuron objects
                this.connections = connections; // Array of connection objects { from: index, to: index, weight: number, targetCompartment?: number, lastPreSpikeTime?: number, lastPostSpikeTime?: number }
                this.params = params;           // Reference to global simulation parameters
                this.dt_ms = params.simulationDt * 1000.0; // Simulation time step in ms

                // --- Synaptic Input Handling ---
                // Needs adaptation if detailed compartmental targeting is implemented.
                // This simple version assumes total current per neuron, applied to soma for CompartmentalNeuron.
                this.synapticInputs = new Float32Array(neurons.length);
                // Example for advanced compartmental input (requires more complex handling):
                // this.synapticInputsPerCompartment = neurons.map(n => new Float32Array(n.compartments?.length || 1));

                // --- State Tracking ---
                this.spikedNeuronsIndices = new Set(); // Tracks indices of neurons spiking in the current step
            }

            /**
             * Advances the simulation by one time step (dt_ms).
             * Calculates synaptic inputs, updates all neurons, handles STDP (if enabled),
             * and triggers an aggregate sound effect based on spike count.
             * @param {number} currentTimeMs - The current simulation time in milliseconds.
             */
            step(currentTimeMs) {
                // --- 0. Reset Step State ---
                this.spikedNeuronsIndices.clear();
                this.synapticInputs.fill(0); // Reset total input per neuron for this step
                // If using compartmental inputs:
                // this.synapticInputsPerCompartment.forEach(arr => arr.fill(0));

                // --- 1. Calculate Synaptic Inputs ---
                // Accumulate input based on *recent* presynaptic spikes considering delay.
                // TODO: This section needs significant change for compartmental targeting.
                //       Currently aggregates input per neuron, assuming application to soma.
                const SYNAPTIC_DELAY_MS = this.params.synapticDelayMs || 1.0; // Get delay from params or default
                this.connections.forEach(conn => {
                    const preNeuron = this.neurons[conn.from];
                    // Check if presynaptic neuron spiked within the delay window ending *before* this step
                    if (preNeuron.lastSpikeTime > (currentTimeMs - this.dt_ms - SYNAPTIC_DELAY_MS) &&
                        preNeuron.lastSpikeTime <= (currentTimeMs - SYNAPTIC_DELAY_MS)) {

                        const effectSign = (preNeuron.type === "excitatory") ? 1.0 : -1.0;

                        // --- Apply Synaptic Input (Simple Version: Aggregate per neuron) ---
                        this.synapticInputs[conn.to] += effectSign * conn.weight;

                        // --- Apply Synaptic Input (Compartmental Version Placeholder) ---

                        const targetNeuron = this.neurons[conn.to];
                        const targetCompartmentIndex = conn.targetCompartment || 0; // Default to soma (0) if not specified
                        if (targetNeuron instanceof CompartmentalNeuron && targetCompartmentIndex < this.synapticInputsPerCompartment[conn.to].length) {
                            this.synapticInputsPerCompartment[conn.to][targetCompartmentIndex] += effectSign * conn.weight;
                        } else {
                            // Fallback or handle non-compartmental neurons if mixed types are used
                            this.synapticInputs[conn.to] += effectSign * conn.weight;
                        }


                        // Record presynaptic spike time for STDP calculation (based on soma spike times)
                        conn.lastPreSpikeTime = preNeuron.lastSpikeTime;
                    }
                });


                // --- 2. Update Each Neuron ---
                this.neurons.forEach(neuron => {
                    // Store the time of the last spike *before* the update
                    const spikeTimeBeforeUpdate = neuron.lastSpikeTime;

                    // --- Determine Input for this Neuron ---
                    let neuronInput;
                    // Simple version: Use the aggregated input
                    neuronInput = this.synapticInputs[neuron.index];
                    // Compartmental version (if implemented): Pass the array of inputs
                    // neuronInput = this.synapticInputsPerCompartment[neuron.index];

                    // --- Update Neuron State ---
                    neuron.update(this.dt_ms, neuronInput, currentTimeMs);

                    // --- Check for Spike Occurrence During This Update ---
                    // Check if the neuron's lastSpikeTime was updated *during* this call to neuron.update()
                    if (neuron.lastSpikeTime > spikeTimeBeforeUpdate) {
                        this.spikedNeuronsIndices.add(neuron.index); // Add index to the set of spiked neurons this step

                        // Record post-synaptic spike time for STDP (relevant for *incoming* connections to this neuron)
                        // This relies on soma spike timing for now.
                        this.connections.forEach(conn => {
                            if (conn.to === neuron.index) {
                                conn.lastPostSpikeTime = neuron.lastSpikeTime;
                            }
                        });
                    }
                });

                // --- 3. Apply STDP Weight Updates (if enabled) ---
                if (this.params.enableSTDP) {
                    this.connections.forEach(conn => {
                        // Check if both pre and post spike times are valid (not -Infinity)
                        if (conn.lastPreSpikeTime > -Infinity && conn.lastPostSpikeTime > -Infinity) {
                            const dt = conn.lastPostSpikeTime - conn.lastPreSpikeTime; // Post-Pre time difference (ms)
                            let dw = 0; // Initialize weight change

                            // Check for LTP timing (Post fires AFTER Pre within window)
                            if (dt > 0 && dt <= this.params.stdpTimeWindow) {
                                // Exponential decay for potentiation effect
                                dw = this.params.stdpLearningRate * Math.exp(-dt / this.params.stdpTimeWindow);
                            }
                            // Check for LTD timing (Pre fires AFTER Post within window)
                            else if (dt < 0 && dt >= -this.params.stdpTimeWindow) {
                                // Exponential decay for depression effect (dt is negative here)
                                // Often uses a slightly different magnitude factor (e.g., 1.0 or 1.05)
                                dw = -this.params.stdpLearningRate * 1.0 * Math.exp(dt / this.params.stdpTimeWindow);
                            }

                            // Apply weight change if calculated
                            if (dw !== 0) {
                                conn.weight += dw;
                                // Clamp weights to min/max defined in params
                                conn.weight = Math.max(this.params.minWeight, Math.min(this.params.maxWeight, conn.weight));
                            }

                            // --- Reset Spike Timing Info ---
                            // Option 1: Reset immediately after considering the pair. Prevents using the same pair twice if dt is very small.
                            // conn.lastPreSpikeTime = -Infinity;
                            // conn.lastPostSpikeTime = -Infinity;

                            // Option 2: Reset only if spikes are too far apart (outside a wider window). Allows a spike to participate in multiple pairings if they happen close together.
                            if (Math.abs(dt) > this.params.stdpTimeWindow * 2.5) { // Use a slightly wider window for reset
                                conn.lastPreSpikeTime = -Infinity;
                                conn.lastPostSpikeTime = -Infinity;
                            }
                        }
                    });
                } // End STDP block

                // ---> ADDED THIS CALL <---
                // --- 4. Trigger Aggregate Sound Effect for this Step ---
                // Call the function that plays sound based on the number of neurons that spiked in *this* step.
                playSimulationStepSound(this.spikedNeuronsIndices.size);

            } // End of step method

            /**
             * Get the indices of neurons that spiked in the most recent step.
             * @returns {Set<number>} Set of neuron indices.
             */
            getSpikedNeuronIndices() {
                return this.spikedNeuronsIndices;
            }

            /**
             * Get the Neuron or CompartmentalNeuron object by its index.
             * @param {number} index - Index of the neuron.
             * @returns {Neuron | CompartmentalNeuron | null} The neuron object or null if index is invalid.
             */
            getNeuron(index) {
                return this.neurons[index] || null;
            }
        } // End of NeuralNetworkSimulation class

        // --- Simulation Manager Class ---
        class SimulationManager {
            /**
             * Manages the overall simulation lifecycle and state, using CompartmentalNeuron objects.
             * @param {object} params - Reference to simulation parameters.
             */
            constructor(params, physicsWorldInstance) {
                this.params = params;           // Reference to global simulation parameters object
                this.network = null;            // Will hold the NeuralNetworkSimulation instance
                this.neurons = [];              // Array holding CompartmentalNeuron objects
                this.params.running = false;    // Simulation running state flag in the shared params object
                this.params.isInitialized = false; // Simulation initialized flag in the shared params object
                this.currentTimeMs = 0;         // Current simulation time in milliseconds

                // Ensure physicsWorldInstance is provided
                if (!physicsWorldInstance) {
                    throw new Error("SimulationManager constructor requires a valid physicsWorld instance.");
                }
                this.physicsWorld = physicsWorldInstance;

            }


            // Add a method to step the physics world (called from animate)
            stepPhysics(deltaTime) {
                if (!this.params.running || !this.params.isInitialized) return;
                // Fixed time step for physics stability is often recommended
                const fixedTimeStep = 1 / 60;
                const maxSubSteps = 5; // Prevent spiral of death
                this.physicsWorld.step(fixedTimeStep, deltaTime, maxSubSteps);
            }

            /**
             * Initializes the simulation with a set of sampled neuron data, creating CompartmentalNeurons.
             * @param {Array<object>} sampledNeuronsData - Array of { position: THREE.Vector3, regionId: number }.
             *                                            The position is assumed to be the SOMA position.
             * @returns {boolean} True if initialization was successful, false otherwise.
             */
            initialize(sampledNeuronsData) {
                console.log(`SimulationManager: Initializing compartmental simulation with ${sampledNeuronsData.length} neurons...`);
                this.dispose(); // Clear previous simulation if any

                if (!sampledNeuronsData || sampledNeuronsData.length === 0) {
                    console.warn("SimulationManager: No neurons provided for initialization.");
                    this.params.isInitialized = false;
                    return false;
                }

                // --- 1. Create Neuron Objects (Use CompartmentalNeuron) ---
                try {
                    this.neurons = sampledNeuronsData.map((data, idx) => {
                        // Simple 80/20 E/I split for now
                        const type = (Math.random() < 0.8) ? "excitatory" : "inhibitory";
                        // Create CompartmentalNeuron, passing the SOMA position from the data
                        return new CompartmentalNeuron(data.position, type, idx, this.params);
                    });
                } catch (error) {
                    console.error("SimulationManager: Error creating CompartmentalNeuron objects.", error);
                    this.dispose(); // Clean up partially created state
                    return false;
                }


                // --- 2. Create Connectivity ---
                // The connection generation logic uses the '.position' getter of the neuron,
                // which in CompartmentalNeuron should return the soma position.
                const connections = this._generateConnections(this.neurons);
                if (connections === null) { // Check if connection generation failed
                    console.error("SimulationManager: Failed to generate connections.");
                    this.dispose();
                    return false;
                }

                // --- 3. Instantiate Simulation Network ---
                // NeuralNetworkSimulation needs to be aware it might contain CompartmentalNeurons
                this.network = new NeuralNetworkSimulation(this.neurons, connections, this.params);

                this.currentTimeMs = performance.now(); // Initialize simulation time
                this.params.isInitialized = true;
                console.log(`SimulationManager: Initialization complete with ${this.neurons.length} compartmental neurons and ${connections.length} connections.`);
                return true;
            }

            /**
             * Generates connections based on simulation parameters.
             * Uses the neuron's primary position (soma for CompartmentalNeuron) for distance checks.
             * @param {CompartmentalNeuron[]} neurons - Array of neuron objects.
             * @returns {Array<object> | null} Array of connection objects, or null on error.
             * @private
             */
            _generateConnections(neurons) {
                const connections = [];
                const numNeurons = neurons.length;
                if (numNeurons < 2) return connections; // Need at least 2 neurons to connect

                console.log(`SimulationManager: Generating connections (Mode: ${this.params.useLocalConnectivity ? 'Local' : 'Global'}) for compartmental neurons...`);

                try {
                    if (this.params.useLocalConnectivity) {
                        // --- LOCAL CONNECTIVITY based on Radius ---
                        const radiusSq = this.params.connectivityRadiusW * this.params.connectivityRadiusW;
                        let attemptedConnections = 0;

                        for (let i = 0; i < numNeurons; i++) {
                            const sourceNeuron = neurons[i];
                            // Use the .position getter (should return soma position)
                            const sourcePos = sourceNeuron.position;
                            if (!sourcePos) {
                                console.warn(`Skipping neuron ${i}: Invalid position.`);
                                continue;
                            }

                            for (let j = 0; j < numNeurons; j++) {
                                if (i === j) continue; // No self-connections

                                const targetNeuron = neurons[j];
                                const targetPos = targetNeuron.position;
                                if (!targetPos) continue; // Skip invalid target

                                const distSq = sourcePos.distanceToSquared(targetPos);

                                if (distSq <= radiusSq) {
                                    attemptedConnections++;
                                    if (Math.random() < this.params.localConnectionProbability) {
                                        const initialWeight = (sourceNeuron.type === "excitatory")
                                            ? randomRange(0.8, 1.5) // Excitatory weights (adjust range)
                                            : randomRange(1.0, 2.5); // Inhibitory weights (often stronger)
                                        connections.push({
                                            from: i, to: j, weight: initialWeight,
                                            // Future Enhancement: Add targetCompartment ID here, e.g., targetCompartment: 1 for dendrite
                                            lastPreSpikeTime: -Infinity, lastPostSpikeTime: -Infinity
                                        });
                                    }
                                }
                            }
                        }
                        console.log(`SimulationManager: Generated ${connections.length} local connections from ${attemptedConnections} potential pairs within radius.`);

                    } else {
                        // --- GLOBAL RANDOM CONNECTIVITY ---
                        // Connect each neuron to a small random subset of others
                        const avgConnectionsPerNeuron = 10; // Example target density
                        for (let i = 0; i < numNeurons; i++) {
                            const sourceNeuron = neurons[i];
                            // Determine number of outgoing connections (can be fixed or random)
                            const numOutgoing = Math.floor(randomRange(avgConnectionsPerNeuron * 0.5, avgConnectionsPerNeuron * 1.5));

                            // Create a shuffled list of potential targets (excluding self)
                            const potentialTargets = [];
                            for (let t = 0; t < numNeurons; t++) { if (t !== i) potentialTargets.push(t); }
                            potentialTargets.sort(() => 0.5 - Math.random()); // Shuffle

                            for (let k = 0; k < numOutgoing && k < potentialTargets.length; k++) {
                                const targetIdx = potentialTargets[k];
                                const initialWeight = (sourceNeuron.type === "excitatory")
                                    ? randomRange(0.5, 1.0) // Global random weights might be weaker on average
                                    : randomRange(0.8, 1.8);
                                connections.push({
                                    from: i, to: targetIdx, weight: initialWeight,
                                    // Future Enhancement: Add targetCompartment ID here
                                    lastPreSpikeTime: -Infinity, lastPostSpikeTime: -Infinity
                                });
                            }
                        }
                        console.log(`SimulationManager: Generated ${connections.length} global random connections.`);
                    }
                } catch (error) {
                    console.error("SimulationManager: Error during connection generation:", error);
                    return null; // Indicate failure
                }
                return connections;
            }

            /** Starts the simulation updates. */
            start() {
                if (this.params.isInitialized && this.network) {
                    this.params.running = true;
                    // Reset time? Or resume? Current implementation resumes.
                    // this.currentTimeMs = performance.now(); // Optional: Reset time on start
                    console.log("SimulationManager: Started.");
                } else {
                    console.warn("SimulationManager: Cannot start, not initialized properly.");
                }
            }

            /** Stops the simulation updates. */
            stop() {
                if (this.params.running) {
                    this.params.running = false;
                    console.log("SimulationManager: Stopped.");
                    // Optionally reset neuron states here if desired when stopping explicitly
                    // this.neurons.forEach(n => { /* reset compartment V, m, h, n states */ });
                }
            }

            /**
             * Advances the simulation by the time elapsed since the last frame.
             * @param {number} deltaSeconds - Time elapsed since last frame in seconds.
             */
            step(deltaSeconds) {
                if (!this.params.running || !this.network) return;

                // Use the simulation time step defined in params
                const dtMs = this.network.dt_ms; // Get dt from the network instance
                const numSteps = Math.max(1, Math.round((deltaSeconds * 1000.0) / dtMs)); // Calculate steps needed

                // Perform multiple simulation steps per frame if needed
                for (let i = 0; i < numSteps; i++) {
                    // Increment time for each sub-step
                    this.currentTimeMs += dtMs;
                    // The network's step method handles updating all neurons (compartmental or simple)
                    this.network.step(this.currentTimeMs);
                }
            }

            /**
             * Returns the current state needed for visualization.
             * @returns {object | null} Object containing { isRunning, isInitialized, neurons, spikedIndices } or null.
             */
            getSimulationState() {
                if (!this.params.isInitialized) return null;
                return {
                    isRunning: this.params.running,
                    isInitialized: this.params.isInitialized,
                    neurons: this.neurons, // Provides access to CompartmentalNeuron objects
                    spikedIndices: this.network ? this.network.getSpikedNeuronIndices() : new Set() // Indices of neurons whose soma spiked
                };
            }

            /**
             * Gets the Neuron object by its index.
             * @param {number} index
             * @returns {CompartmentalNeuron | null}
             */
            getNeuron(index) {
                return this.neurons[index] || null;
            }

            /** Cleans up simulation resources. */
            dispose() {
                console.log("SimulationManager: Disposing...");
                this.stop(); // Ensure simulation is stopped
                // Consider clearing physics bodies if they weren't handled by visuals
                while (this.physicsWorld.bodies.length > 0) {
                    this.physicsWorld.removeBody(this.physicsWorld.bodies[0]);
                }
                this.network = null; // Release reference to network
                this.neurons = [];   // Clear neuron array
                this.params.isInitialized = false; // Reset flag
                this.params.running = false; // Ensure running flag is false
                console.log("SimulationManager: Disposed.");
            }

            /**
             * Gets the serializable state of the simulation.
             * NOTE: This is a placeholder. Saving compartmental state is complex.
             * @returns {object | null} Serializable state object or null if not initialized.
             */
            getSerializableState() {
                if (!this.params.isInitialized || !this.network) {
                    console.warn("SimulationManager: Cannot serialize simulation state: Not initialized.");
                    return null;
                }

                console.warn("SimulationManager.getSerializableState: Compartmental state serialization is not fully implemented.");
                /*
                TODO: Implement robust serialization for compartmental state:
                1. Serialize parameters (already partially done in example).
                2. Serialize current time.
                3. Serialize dynamic state for EACH compartment of EACH neuron (V, m, h, n, etc.).
                4. Serialize connection weights and timing info (already partially done).
                */

                // Basic structure (incomplete):
                const serializableParams = {};
                for (const key in this.params) {
                    if (typeof this.params[key] !== 'function') {
                        serializableParams[key] = this.params[key];
                    }
                }
                serializableParams.running = this.params.running;
                serializableParams.isInitialized = this.params.isInitialized;

                return {
                    params: serializableParams,
                    currentTimeMs: this.currentTimeMs,
                    neurons: null, // Requires iterating compartments
                    connections: null // Requires saving weights/timing
                };
            }

            /**
             * Loads simulation dynamic state from a saved object.
             * NOTE: This is a placeholder. Loading compartmental state is complex.
             * Assumes the manager has been *initialized* with the correct set of neurons
             * based on loaded visibility/parameters *before* this is called.
             * @param {object} savedSimState - The simulation part of the loaded state object.
             * @returns {boolean} True if state was loaded successfully, false otherwise.
             */
            loadState(savedSimState) {
                if (!savedSimState) {
                    console.warn("SimulationManager: No saved simulation state provided to load.");
                    return false;
                }
                if (!this.params.isInitialized || !this.network) {
                    console.warn("SimulationManager: Cannot load dynamic state - simulation not initialized correctly before loadState call.");
                    return false;
                }

                console.warn("SimulationManager.loadState: Compartmental state loading is not fully implemented.");
                /*
                TODO: Implement robust loading for compartmental state:
                1. Restore parameters (handled externally by main load function).
                2. Restore current time.
                3. Restore dynamic state for EACH compartment of EACH neuron. Ensure neuron count/structure matches.
                4. Restore connection weights and timing info. Ensure connection count/structure matches.
                */
                try {
                    this.currentTimeMs = savedSimState.currentTimeMs || performance.now();
                    // Need loops to restore compartment states and connection states...
                    console.log("SimulationManager: Basic time restored, but full compartmental state loading is PENDING IMPLEMENTATION.");
                    return true; // Returning true for now, but it's misleading.
                } catch (error) {
                    console.error("Error loading simulation dynamic state (incomplete implementation):", error);
                    this.dispose(); // Stop simulation and clean up if loading fails critically
                    return false; // Indicate failure
                }
            }
        }


        /**
         * ============================================================
         * Updated SimulationVisuals Class
         * Manages neuron soma markers, branching synaptic tree visuals,
         * and physics-based pulse propagation effects.
         * ============================================================
         */
        class SimulationVisuals {
            /**
             * Constructor for SimulationVisuals.
             * @param {THREE.Scene} scene - The main Three.js scene.
             * @param {object} params - Shared simulation parameters object.
             * @param {CANNON.World} physicsWorld - The Cannon.js physics world instance.
             */
            constructor(scene, params, physicsWorld) {
                if (!scene || !params || !physicsWorld) {
                    throw new Error("SimulationVisuals requires scene, params, and physicsWorld.");
                }
                this.scene = scene;
                this.params = params;
                this.physicsWorld = physicsWorld; // Store reference to physics world

                // --- State ---
                this.neuronVisuals = []; // Stores { neuronIndex, somaMarker, dendriteMarker?, connectionLine? }
                this.activeSynapticEffects = []; // Stores { treeMesh, pulseBody, targetBody, startTime, connectionInfo, hasHitTarget, hitTime?, lifeTimeMs }
                this.isInitialized = false;

                // --- Textures and Colors ---
                this.glowTexture = createGlowTexture('white', 64); // Reuse existing function
                this.excitatoryColor = new THREE.Color(0x5588ff); // Blueish for Excitatory Soma
                this.inhibitoryColor = new THREE.Color(0xaa55ff); // Purple for Inhibitory Soma
                this.spikeColor = new THREE.Color(0x00aaff);      // Spike flash color for soma
                this.excitatoryPulseColor = new THREE.Color(0xffff00); // Yellow pulse for E->?
                this.inhibitoryPulseColor = new THREE.Color(0xff00ff); // Magenta pulse for I->?

                // --- Materials ---
                // Base material for the synaptic trees (will be cloned)
                this.treeBaseMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0.0 },
                        baseColor: { value: new THREE.Color(0x333344) }, // Dark blue/grey base
                        pulseColor: { value: new THREE.Color(0xffffff) }, // Default pulse color
                        pulsePosition: { value: -1.0 }, // Normalized position (0-1), -1 means inactive
                        pulseWidth: { value: 0.08 }, // Width of the pulse along the tube
                        brightness: { value: 1.0 } // Controls overall brightness/fade
                    },
                    vertexShader: `
                varying vec2 vUv;
                varying float vDepth; // Pass depth for potential fog/depth effects
                void main() {
                    vUv = uv; // Pass UV coords to fragment shader
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    vDepth = -mvPosition.z; // Depth from camera
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
                    fragmentShader: `
                uniform float time;
                uniform vec3 baseColor;
                uniform vec3 pulseColor;
                uniform float pulsePosition; // Normalized position (0.0 to 1.0)
                uniform float pulseWidth;
                uniform float brightness;
                varying vec2 vUv;
                varying float vDepth; // Receive depth

                // Simple pseudo-random function
                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                }

                // Improved flicker function
                float flicker(float intensity, vec2 uv, float time) {
                    float noise = random(uv + fract(time * 5.0)) * 0.4 + 0.8; // Time-varying noise
                    return intensity * noise;
                }

                void main() {
                    vec3 finalColor = baseColor;
                    float pulseEffect = 0.0;

                    if (pulsePosition >= 0.0 && pulsePosition <= 1.0) {
                        // Calculate distance from the current UV's x-coord (along the tube) to the pulse center
                        float dist = abs(vUv.x - pulsePosition);
                        // Gaussian-like falloff for the pulse intensity
                        float sigma = pulseWidth / 3.0; // Adjust sigma for desired sharpness
                        pulseEffect = exp(-(dist * dist) / (2.0 * sigma * sigma));
                        // pulseEffect = smoothstep(pulseWidth * 0.5, 0.0, dist); // Alternative smoothstep
                    }

                    // Add flicker to the pulse effect
                    pulseEffect = flicker(pulseEffect, vUv, time);

                    // Mix base color and pulse color based on the effect intensity
                    finalColor = mix(baseColor, pulseColor, pulseEffect);

                    // Apply overall brightness (for fading out) and ensure alpha respects brightness
                    float alpha = clamp(brightness * (0.2 + 0.8 * pulseEffect), 0.0, 1.0); // Base opacity + pulse makes it brighter

                    gl_FragColor = vec4(finalColor * brightness, alpha);

                    // Optional: Add fog effect based on depth
                    // float fogFactor = smoothstep(100.0, 5000.0, vDepth); // Example depth range
                    // gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), fogFactor);
                }
            `,
                    transparent: true,
                    blending: THREE.AdditiveBlending, // Additive looks good for energy pulses
                    depthWrite: false,
                    side: THREE.DoubleSide // Important for tubes
                });

                // Material for optional simple soma-dendrite structural lines
                this.structureMaterial = new THREE.LineBasicMaterial({
                    color: 0x666666, // Greyish color
                    transparent: true,
                    opacity: 0.4,
                    linewidth: 1,
                });

                // Physics materials (references to globally defined materials)
                if (typeof pulseMaterial === 'undefined' || typeof targetMaterial === 'undefined') {
                    console.warn("Physics materials 'pulseMaterial' or 'targetMaterial' not found globally. Using defaults.");
                    this.pulsePhysicsMaterial = new CANNON.Material("pulseDefault");
                    this.targetPhysicsMaterial = new CANNON.Material("targetDefault");
                    // Need to add contact material if using defaults
                    const defaultContactMaterial = new CANNON.ContactMaterial(this.pulsePhysicsMaterial, this.targetPhysicsMaterial, { friction: 0, restitution: 0.1 });
                    this.physicsWorld.addContactMaterial(defaultContactMaterial);
                } else {
                    this.pulsePhysicsMaterial = pulseMaterial;
                    this.targetPhysicsMaterial = targetMaterial;
                }
            }

            // --- Synaptic Tree Generation ---
            /**
             * Generates a list of points defining a somewhat organic, branching path.
             * @param {THREE.Vector3} startVec - Starting point (e.g., source soma).
             * @param {THREE.Vector3} endVec - Ending point (e.g., target soma).
             * @param {number} segments - Number of main segments along the path.
             * @param {number} branchiness - Probability (0-1) of branching at each segment.
             * @param {number} jitterScale - Max distance a point can deviate laterally.
             * @param {number} branchFactor - How much branches deviate angle-wise.
             * @param {number} branchLengthFactor - Multiplier for branch length relative to segment length.
             * @returns {Array<THREE.Vector3>} Array of points defining the tree path.
             */
            generateSynapticTreePoints(startVec, endVec, segments = 6, branchiness = 0.3, jitterScale = 8, branchFactor = 0.8, branchLengthFactor = 0.6) {
                const points = [startVec.clone()];
                const mainDirection = endVec.clone().sub(startVec);
                const totalLength = mainDirection.length();
                if (totalLength < 1e-6) return [startVec, endVec]; // Avoid division by zero for coincident points
                mainDirection.normalize();

                let currentPos = startVec.clone();
                const segmentLength = totalLength / segments;

                // Create perpendicular axes for jittering
                const perp1 = new THREE.Vector3();
                if (Math.abs(mainDirection.y) < 0.9) { // Avoid parallel with Y-axis
                    perp1.crossVectors(mainDirection, new THREE.Vector3(0, 1, 0)).normalize();
                } else { // Use X-axis if mainDirection is close to Y
                    perp1.crossVectors(mainDirection, new THREE.Vector3(1, 0, 0)).normalize();
                }
                const perp2 = new THREE.Vector3().crossVectors(mainDirection, perp1).normalize();

                for (let i = 1; i < segments; i++) {
                    // Move along main direction
                    const step = mainDirection.clone().multiplyScalar(segmentLength);
                    currentPos.add(step);

                    // Add jitter perpendicular to the main direction
                    const jitterAmount = (Math.random() * 2 - 1) * jitterScale * (i / segments); // Increase jitter further out
                    const jitterDirection = Math.random() < 0.5 ? perp1 : perp2;
                    const jitterAngle = Math.random() * Math.PI * 2;
                    const jitterOffset = perp1.clone().multiplyScalar(Math.cos(jitterAngle))
                        .add(perp2.clone().multiplyScalar(Math.sin(jitterAngle)))
                        .multiplyScalar(jitterAmount);

                    const jitteredPos = currentPos.clone().add(jitterOffset);
                    points.push(jitteredPos);

                    // --- Branching Logic ---
                    if (Math.random() < branchiness) {
                        // Calculate branch direction (deviating from main direction)
                        const branchDevAngle1 = (Math.random() - 0.5) * 2 * Math.PI * branchFactor;
                        const branchDevAngle2 = (Math.random() - 0.5) * 2 * Math.PI * branchFactor;
                        const branchDirection = mainDirection.clone()
                            .applyAxisAngle(perp1, branchDevAngle1)
                            .applyAxisAngle(perp2, branchDevAngle2)
                            .normalize();

                        const branchLength = segmentLength * branchLengthFactor * (0.5 + Math.random() * 0.7);
                        const branchEnd = jitteredPos.clone().add(branchDirection.multiplyScalar(branchLength));

                        // Add points for the branch: start from jittered pos, go to end, then back
                        // This ensures the TubeGeometry follows the branch and returns
                        points.push(branchEnd);
                        points.push(jitteredPos); // Return to the main path for the next segment
                    }
                }
                points.push(endVec.clone()); // Ensure it ends exactly at the target
                return points;
            }

            // --- Create the Visual Tree Mesh ---
            /**
             * Creates a THREE.Mesh with TubeGeometry for the synapse path.
             * @param {Array<THREE.Vector3>} points - Points defining the path.
             * @param {THREE.Color} pulseColor - Color for the propagating pulse.
             * @returns {THREE.Mesh | null} The created mesh or null on error.
             */
            createSynapticTreeMesh(points, pulseColor) {
                if (!points || points.length < 2) {
                    console.warn("Cannot create tree mesh with less than 2 points.");
                    return null;
                }
                try {
                    // Ensure points are valid Vector3 instances
                    const validPoints = points.map(p => p instanceof THREE.Vector3 ? p : new THREE.Vector3(p.x, p.y, p.z));
                    if (validPoints.length < 2) return null; // Check again after potential conversion

                    const curve = new THREE.CatmullRomCurve3(validPoints, false, 'catmullrom', 0.1); // Use CatmullRom, low tension

                    // Adjust tube detail based on complexity/performance needs
                    const tubeSegments = Math.min(128, Math.max(16, validPoints.length * 4)); // Dynamic segments
                    const tubeRadius = this.params.connectivityRadiusW * 0.015; // Smaller radius relative to connectivity scale
                    const radialSegments = 8; // Fewer radial segments for performance

                    const tubeGeometry = new THREE.TubeGeometry(curve, tubeSegments, tubeRadius, radialSegments, false); // Segments, radius, radialSegments

                    const material = this.treeBaseMaterial.clone(); // Clone the base shader material
                    material.uniforms.pulseColor.value = pulseColor.clone();
                    material.uniforms.pulsePosition.value = -1.0; // Initially inactive pulse
                    material.uniforms.brightness.value = 1.0;     // Initially fully bright

                    const mesh = new THREE.Mesh(tubeGeometry, material);
                    mesh.userData.curve = curve; // Store the curve for pulse position calculation
                    mesh.frustumCulled = true; // Trees might be complex, prevent premature culling (optional)
                    return mesh;
                } catch (error) {
                    console.error("Error creating TubeGeometry for synaptic tree:", error, "Input points:", points);
                    return null; // Return null if geometry creation fails
                }
            }

            // --- Create Physics Bodies for Pulse and Target ---
            /**
             * Creates a dynamic physics body for the propagating pulse.
             * @param {THREE.Vector3} startPos - Initial position of the pulse.
             * @returns {CANNON.Body} The created physics body.
             */
            createPulsePhysicsBody(startPos) {
                const shape = new CANNON.Sphere(1.5); // Slightly larger pulse body for reliable collision
                const body = new CANNON.Body({
                    mass: 0.1, // Give it some mass to move
                    material: this.pulsePhysicsMaterial, // Assign physics material
                    linearDamping: 0.2, // Some damping to prevent excessive speed
                    angularDamping: 0.5, // Prevent spinning
                    collisionFilterGroup: 2, // Assign to group 2
                    collisionFilterMask: 1   // Collide only with group 1 (targets)
                });
                body.addShape(shape);
                body.position.copy(startPos); // Set initial position
                this.physicsWorld.addBody(body);
                return body;
            }

            /**
             * Creates a static physics body representing the target area.
             * @param {THREE.Vector3} endPos - Position of the target.
             * @returns {CANNON.Body} The created static physics body.
             */
            createTargetPhysicsBody(endPos) {
                const shape = new CANNON.Sphere(3.0); // Target area radius
                const body = new CANNON.Body({
                    mass: 0, // Static body (mass 0)
                    type: CANNON.Body.STATIC,
                    material: this.targetPhysicsMaterial, // Assign physics material
                    collisionFilterGroup: 1,  // Assign to group 1
                    collisionFilterMask: 2    // Collide only with group 2 (pulses)
                });
                body.addShape(shape);
                body.position.copy(endPos); // Set position
                this.physicsWorld.addBody(body);
                return body;
            }

            // --- Initialize Base Visuals (Soma Markers) ---
            /**
             * Initializes the basic visual representation (soma markers) for each neuron.
             * @param {Array<CompartmentalNeuron>} neurons - Array of neuron objects.
             * @returns {boolean} True if initialization was successful.
             */
            initialize(neurons) {
                this.dispose(); // Clear previous visuals first
                if (!neurons || neurons.length === 0) {
                    console.warn("SimulationVisuals: No neurons provided for initialization.");
                    return false;
                }
                console.log(`SimulationVisuals: Initializing BASE visuals for ${neurons.length} neurons.`);

                const baseScale = this.params.markerBaseScale;

                this.neuronVisuals = neurons.map(neuron => {
                    // Ensure it's a valid neuron with a position getter
                    if (!neuron || typeof neuron.position === 'undefined' || typeof neuron.index === 'undefined') {
                        console.warn("Visuals: Skipping invalid neuron object during init", neuron);
                        return null;
                    }

                    const isExcitatory = neuron.type === "excitatory";
                    const baseColor = isExcitatory ? this.excitatoryColor : this.inhibitoryColor;
                    const baseOpacity = isExcitatory ? 0.3 : 0.4; // Slightly denser for Inhibitory?

                    const somaMaterial = new THREE.SpriteMaterial({
                        map: this.glowTexture,
                        color: baseColor.clone(),
                        transparent: true,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false,
                        opacity: baseOpacity,
                        sizeAttenuation: true
                    });
                    const somaMarker = new THREE.Sprite(somaMaterial);
                    somaMarker.position.copy(neuron.position); // Use the neuron's position getter
                    somaMarker.scale.set(baseScale, baseScale, 1);
                    // Store essential data for updates and resets
                    somaMarker.userData = {
                        neuronIndex: neuron.index, // CRITICAL: Store the neuron's index
                        baseColor: baseColor.clone(),
                        baseOpacity: baseOpacity,
                        baseScale: baseScale,
                        isSoma: true // Identifier
                    };
                    this.scene.add(somaMarker);

                    // NOTE: Add dendriteMarker and connectionLine logic here if needed
                    // For this focused example, we're omitting them.

                    return {
                        neuronIndex: neuron.index,
                        somaMarker: somaMarker,
                        dendriteMarker: null, // Placeholder
                        connectionLine: null   // Placeholder
                    };

                }).filter(vis => vis !== null); // Remove any null entries from skipped neurons

                this.isInitialized = true;
                console.log("SimulationVisuals: BASE Initialization complete.");
                return true;
            }

            // --- Visualize Outgoing Connections (Rewritten) ---
            /**
             * Creates and manages the visual and physics effect for a spike's outgoing connections.
             * @param {CompartmentalNeuron | Neuron} sourceNeuron - The neuron that fired.
             * @param {Array<CompartmentalNeuron | Neuron>} allNeurons - All neurons in the simulation.
             * @param {number} currentTimeMs - Current simulation time.
             * @private
             */
            _visualizeOutgoingConnections(sourceNeuron, allNeurons, currentTimeMs) {
                const network = simulationManager.network; // Get network simulation instance
                if (!network || !network.connections) {
                    console.warn("Cannot visualize outgoing connections: Network or connections missing.");
                    return;
                }

                const outgoing = network.connections.filter(c => c.from === sourceNeuron.index);
                outgoing.sort(() => 0.5 - Math.random()); // Randomize for visual variety
                const connectionsToDraw = outgoing.slice(0, this.params.maxConnectionsPerSpike);

                connectionsToDraw.forEach(connInfo => {
                    const targetNeuron = allNeurons[connInfo.to];
                    if (!targetNeuron || typeof targetNeuron.position === 'undefined') {
                        console.warn(`Skipping connection visualization: Target neuron ${connInfo.to} not found or invalid.`);
                        return;
                    }

                    const startPos = sourceNeuron.position; // Use getter for soma position
                    const endPos = targetNeuron.position;   // Use getter for target soma position

                    // 1. Generate Tree Geometry Points
                    const treePoints = this.generateSynapticTreePoints(startPos, endPos, 6, 0.3, 8);

                    // 2. Create Visual Mesh
                    const pulseColor = sourceNeuron.type === "excitatory" ? this.excitatoryPulseColor : this.inhibitoryPulseColor;
                    const treeMesh = this.createSynapticTreeMesh(treePoints, pulseColor);
                    if (!treeMesh) {
                        console.warn(`Failed to create tree mesh for connection ${connInfo.from}->${connInfo.to}`);
                        return; // Skip if mesh creation failed
                    }
                    this.scene.add(treeMesh);

                    // 3. Create Physics Bodies
                    const pulseBody = this.createPulsePhysicsBody(startPos);
                    const targetBody = this.createTargetPhysicsBody(endPos); // Static target

                    // 4. Add Collision Listener to the PULSE body
                    const collisionHandler = (event) => {
                        // Check if the collision is with the intended target body
                        // event.body is the OTHER body involved in the collision
                        if (!effectData.hasHitTarget && event.body === targetBody) {
                            //console.log(`Pulse for connection ${connInfo.from}->${connInfo.to} hit target!`);
                            effectData.hasHitTarget = true;
                            effectData.hitTime = performance.now(); // Record hit time for fading logic

                            // --- Trigger Visual Feedback on Target ---
                            const targetVisual = this.neuronVisuals.find(v => v && v.neuronIndex === connInfo.to);
                            if (targetVisual && targetVisual.somaMarker) {
                                const marker = targetVisual.somaMarker;
                                // Make target soma flash briefly (e.g., white and larger)
                                const originalColor = marker.userData.baseColor.clone();
                                const originalScale = marker.userData.baseScale;
                                marker.material.color.set(0xffffff); // Flash white
                                marker.scale.setScalar(originalScale * 1.8); // Pulse larger
                                marker.material.opacity = 0.9;

                                // Set timeout to revert the visual changes
                                setTimeout(() => {
                                    // Check if the marker still exists before reverting
                                    if (marker && marker.material && marker.userData) {
                                        marker.material.color.copy(originalColor);
                                        marker.scale.setScalar(originalScale);
                                        marker.material.opacity = marker.userData.baseOpacity;
                                    }
                                }, 150); // Flash duration (ms)
                            }

                            // Optional: Reduce pulse body velocity significantly upon hit
                            pulseBody.velocity.scale(0.1, pulseBody.velocity);
                            pulseBody.angularVelocity.scale(0.1, pulseBody.angularVelocity);

                            // Important: Remove the listener after the first hit to prevent multiple triggers
                            pulseBody.removeEventListener("collide", collisionHandler);
                        }
                    };
                    pulseBody.addEventListener("collide", collisionHandler);


                    // 5. Store references to manage the effect
                    const effectData = {
                        treeMesh: treeMesh,
                        pulseBody: pulseBody,
                        targetBody: targetBody,
                        collisionHandler: collisionHandler, // Store handler to remove later
                        startTime: currentTimeMs,
                        connectionInfo: connInfo,
                        hasHitTarget: false,
                        hitTime: null, // Initialize hit time
                        lifeTimeMs: this.params.connectionLifeTimeMs || 2000 // Use param or default (ms)
                    };
                    this.activeSynapticEffects.push(effectData);

                    // 6. Apply Initial Physics Impulse to start the pulse movement
                    const impulseDirection = endPos.clone().sub(startPos).normalize();
                    const impulseMagnitude = 3 + Math.random() * 2; // Tunable speed
                    pulseBody.applyImpulse(impulseDirection.multiplyScalar(impulseMagnitude), pulseBody.position); // Apply impulse at the body's center
                });
            }

            // --- Update Active Synaptic Effects (Pulses and Fading) ---
            /**
             * Updates the visual state (pulse position, brightness) of active synaptic effects
             * and cleans up expired or faded effects.
             * @param {number} currentTimeMs - Current simulation time.
             * @private
             */
            updateActiveSynapticEffects(currentTimeMs) {
                const remainingEffects = [];
                const time = currentTimeMs / 1000.0; // Consistent time for shaders

                this.activeSynapticEffects.forEach(effect => {
                    const elapsedTime = currentTimeMs - effect.startTime;
                    let keepEffect = true;
                    let brightness = 1.0;

                    // Check lifetime first
                    if (elapsedTime > effect.lifeTimeMs) {
                        keepEffect = false;
                        brightness = 0.0; // Ensure it's faded if removed due to time
                    } else {
                        // --- Update Pulse Position in Shader ---
                        const pulseBodyPos = effect.pulseBody.position;
                        const curve = effect.treeMesh.userData.curve;

                        if (curve && curve.points && curve.points.length >= 2) {
                            // Estimate progress along the curve based on physics body position
                            // Approximation: Project current position onto the line between start/end
                            const startPos = curve.points[0];
                            const endPos = curve.points[curve.points.length - 1];
                            const totalVector = endPos.clone().sub(startPos);
                            const totalLengthSq = totalVector.lengthSq();
                            let progress_t = 0;

                            if (totalLengthSq > 1e-6) { // Avoid division by zero
                                const currentVector = pulseBodyPos.clone().sub(startPos);
                                const projectedLength = currentVector.dot(totalVector);
                                progress_t = Math.max(0, Math.min(1, projectedLength / totalLengthSq));
                            }

                            // If the target has been hit, visually clamp pulse at the end
                            if (effect.hasHitTarget) {
                                progress_t = 1.0;
                                // Start fading quickly after hit
                                const timeSinceHit = currentTimeMs - effect.hitTime; // Use recorded hit time
                                brightness = Math.max(0, 1.0 - timeSinceHit / 400.0); // Fade over 400ms after hit
                            } else {
                                // Fade linearly over the total lifetime if not hit yet
                                brightness = Math.max(0, 1.0 - (elapsedTime / effect.lifeTimeMs));
                            }

                            // Update shader uniforms
                            effect.treeMesh.material.uniforms.pulsePosition.value = progress_t;
                            effect.treeMesh.material.uniforms.time.value = time; // For flicker
                            effect.treeMesh.material.uniforms.brightness.value = brightness * brightness; // Squared fade looks better

                            // If fully faded, mark for removal
                            if (brightness <= 0.01) {
                                keepEffect = false;
                            }
                        } else {
                            // Invalid curve, mark for removal
                            console.warn("Invalid curve found in active synaptic effect. Removing.", effect.connectionInfo);
                            keepEffect = false;
                        }
                    }

                    // --- Cleanup or Keep ---
                    if (keepEffect) {
                        remainingEffects.push(effect);
                    } else {
                        // Dispose THREE resources
                        this.scene.remove(effect.treeMesh);
                        if (effect.treeMesh.geometry) effect.treeMesh.geometry.dispose();
                        if (effect.treeMesh.material) effect.treeMesh.material.dispose();

                        // Remove physics bodies
                        if (effect.pulseBody) {
                            // Remove event listener explicitly before removing body
                            if (effect.collisionHandler) {
                                effect.pulseBody.removeEventListener("collide", effect.collisionHandler);
                            }
                            this.physicsWorld.removeBody(effect.pulseBody);
                        }
                        if (effect.targetBody) {
                            this.physicsWorld.removeBody(effect.targetBody);
                        }
                    }
                });

                this.activeSynapticEffects = remainingEffects;
            }


            // --- Main Update Method ---
            /**
             * Updates all managed visuals based on the simulation state.
             * @param {object | null} simState - Current state from SimulationManager { isRunning, isInitialized, neurons, spikedIndices }.
             * @param {boolean} isContinuousSpikingActive - Flag indicating if continuous mode is on.
             * @param {number} currentTimeMs - Current simulation time.
             */
            update(simState, isContinuousSpikingActive, currentTimeMs) {
                if (!this.isInitialized) return; // Don't update if base visuals aren't ready

                // 1. Handle Continuous Spiking Visual Override FIRST
                if (isContinuousSpikingActive) {
                    this._updateContinuousVisuals(currentTimeMs);
                    // Hide detailed synaptic effects during continuous mode
                    this.activeSynapticEffects.forEach(effect => {
                        if (effect.treeMesh) effect.treeMesh.visible = false;
                    });
                    return; // Skip detailed updates
                } else {
                    // Ensure synaptic effects are visible when continuous stops (if they exist)
                    this.activeSynapticEffects.forEach(effect => {
                        if (effect.treeMesh) effect.treeMesh.visible = true;
                    });
                }

                // 2. Handle Simulation Not Running State or Invalid State
                if (!simState || !simState.isRunning || !simState.neurons) {
                    this._resetVisuals(); // Resets soma markers
                    // Force cleanup of any active synaptic effects immediately
                    this.activeSynapticEffects.forEach(effect => {
                        if (effect.treeMesh && effect.treeMesh.material) {
                            effect.treeMesh.material.uniforms.brightness.value = 0.0; // Trigger fast fade/cleanup
                        }
                    });
                    this.updateActiveSynapticEffects(currentTimeMs); // Run cleanup logic now
                    return;
                }

                // 3. Update Soma Markers based on Detailed Simulation State
                const spikedIndices = simState.spikedIndices || new Set(); // Ensure spikedIndices is a Set

                this.neuronVisuals.forEach(vis => {
                    if (!vis || !vis.somaMarker || !vis.somaMarker.userData) return; // Ensure marker and userData exist

                    const neuron = simState.neurons[vis.neuronIndex];
                    if (!neuron) {
                        // console.warn(`Visual update skipped: Neuron ${vis.neuronIndex} not found in simState.`);
                        return; // Skip if neuron data is missing
                    }

                    const somaMarker = vis.somaMarker;
                    const userData = somaMarker.userData;
                    const timeSinceSpike = currentTimeMs - neuron.lastSpikeTime;
                    const baseScale = userData.baseScale;
                    const baseColor = userData.baseColor;
                    const baseOpacity = userData.baseOpacity;

                    let targetScale = baseScale;
                    let targetOpacity = baseOpacity;
                    let targetColor = baseColor;

                    // Check neuron's firing state using its method
                    if (neuron.isFiring && neuron.isFiring() && timeSinceSpike < 100) { // Extend flash duration slightly
                        // Flash effect for soma spike
                        const flashProgress = 1.0 - Math.min(1.0, timeSinceSpike / 100.0); // 0 to 1 progress
                        const scalePulse = 1.0 + (this.params.markerSpikeScaleFactor - 1.0) * flashProgress;
                        targetScale = baseScale * scalePulse;
                        targetOpacity = baseOpacity + (0.9 - baseOpacity) * flashProgress; // Fade from 0.9 down to base
                        targetColor = baseColor.clone().lerp(this.spikeColor, flashProgress * 0.8); // Blend towards spike color

                        // If this neuron just spiked *in this simulation step*, trigger outgoing effects
                        if (spikedIndices.has(neuron.index)) {
                            this._visualizeOutgoingConnections(neuron, simState.neurons, currentTimeMs);
                            // playSpikeSound(); // Sound is now triggered per step in NeuralNetworkSimulation
                        }

                    } else { // Reset to base appearance
                        targetScale = baseScale;
                        targetOpacity = baseOpacity;
                        targetColor = baseColor;
                    }

                    // Apply visuals to soma marker
                    somaMarker.material.color.copy(targetColor);
                    somaMarker.material.opacity = targetOpacity;
                    somaMarker.scale.set(targetScale, targetScale, 1);
                    somaMarker.visible = true; // Ensure visible
                });

                // 4. Update the Active Synaptic Tree Effects (Pulse position, fading, cleanup)
                this.updateActiveSynapticEffects(currentTimeMs);
            }


            // --- Continuous Visuals and Reset ---
            /**
             * Overrides soma marker visuals for continuous spiking mode.
             * @param {number} currentTimeMs - Current time.
             * @private
             */
            _updateContinuousVisuals(currentTimeMs) {
                const flashIntensity = 0.7 + 0.3 * Math.sin(currentTimeMs / 80.0); // Faster pulse
                const flashScale = this.params.markerBaseScale * (1.2 + 0.8 * flashIntensity); // More dynamic scale
                this.neuronVisuals.forEach(vis => {
                    if (vis && vis.somaMarker) {
                        vis.somaMarker.material.color.copy(this.spikeColor); // Use consistent spike color
                        vis.somaMarker.material.opacity = flashIntensity * 0.7; // Modulated opacity
                        vis.somaMarker.scale.set(flashScale, flashScale, 1);
                        vis.somaMarker.visible = true; // Ensure visible
                    }
                    // Hide structural lines if any are used
                    if (vis && vis.connectionLine) vis.connectionLine.visible = false;
                });
                // Active synaptic effects visibility handled in the main update loop
            }

            /**
             * Resets soma markers to their base appearance.
             * @private
             */
            _resetVisuals() {
                this.neuronVisuals.forEach(vis => {
                    if (vis && vis.somaMarker && vis.somaMarker.userData) {
                        const marker = vis.somaMarker;
                        const userData = marker.userData;
                        marker.material.color.copy(userData.baseColor);
                        marker.material.opacity = userData.baseOpacity;
                        marker.scale.set(userData.baseScale, userData.baseScale, 1);
                        marker.visible = true; // Ensure visible
                    }
                    // Ensure structural lines are visible again if used
                    if (vis && vis.connectionLine) vis.connectionLine.visible = true;
                });
                // Note: Active synaptic effects are cleaned up via updateActiveSynapticEffects when sim stops
            }

            // --- Dispose Method ---
            /**
             * Cleans up all Three.js and Cannon.js resources managed by this class.
             */
            dispose() {
                console.log("SimulationVisuals: Disposing ALL visuals...");

                // Dispose Soma/Dendrite markers and structural lines
                this.neuronVisuals.forEach(vis => {
                    if (!vis) return;
                    if (vis.somaMarker) {
                        this.scene.remove(vis.somaMarker);
                        // Dispose sprite map texture IF it's unique per marker (it's shared now)
                        // if (vis.somaMarker.material?.map) vis.somaMarker.material.map.dispose();
                        if (vis.somaMarker.material) vis.somaMarker.material.dispose();
                    }
                    if (vis.dendriteMarker) { // If you add these back
                        this.scene.remove(vis.dendriteMarker);
                        if (vis.dendriteMarker.material) vis.dendriteMarker.material.dispose();
                    }
                    if (vis.connectionLine) { // If you add these back
                        this.scene.remove(vis.connectionLine);
                        if (vis.connectionLine.geometry) vis.connectionLine.geometry.dispose();
                        if (vis.connectionLine.material) vis.connectionLine.material.dispose();
                    }
                });
                this.neuronVisuals = [];

                // Dispose active synaptic effects (trees and physics bodies)
                console.log(`Disposing ${this.activeSynapticEffects.length} active synaptic effects...`);
                this.activeSynapticEffects.forEach(effect => {
                    // Remove event listener first!
                    if (effect.pulseBody && effect.collisionHandler) {
                        effect.pulseBody.removeEventListener("collide", effect.collisionHandler);
                    }
                    // Remove THREE mesh
                    if (effect.treeMesh) {
                        this.scene.remove(effect.treeMesh);
                        if (effect.treeMesh.geometry) effect.treeMesh.geometry.dispose();
                        // Material is cloned, so needs disposal
                        if (effect.treeMesh.material) effect.treeMesh.material.dispose();
                    }
                    // Remove Cannon bodies
                    if (effect.pulseBody) this.physicsWorld.removeBody(effect.pulseBody);
                    if (effect.targetBody) this.physicsWorld.removeBody(effect.targetBody);
                });
                this.activeSynapticEffects = [];

                // Dispose shared textures and base materials
                console.log("Disposing shared textures and materials...");
                if (this.glowTexture) {
                    this.glowTexture.dispose();
                    this.glowTexture = null; // Release reference
                }
                if (this.treeBaseMaterial) {
                    this.treeBaseMaterial.dispose();
                    this.treeBaseMaterial = null; // Release reference
                }
                if (this.structureMaterial) {
                    this.structureMaterial.dispose();
                    this.structureMaterial = null; // Release reference
                }

                this.isInitialized = false; // Mark as uninitialized
                console.log("SimulationVisuals: Disposal complete.");
            }
        }


        // --- Audio Handling ---
        // Ensure AudioContext is created/resumed on user interaction
        let audioCtx = null;
        function getAudioContext() {
            if (!audioCtx) {
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    // Add a listener to resume context on first user gesture
                    const resumeAudio = () => {
                        if (audioCtx && audioCtx.state === 'suspended') {
                            audioCtx.resume().then(() => {
                                console.log("AudioContext resumed successfully.");
                                // Remove the listeners after successful resume
                                document.removeEventListener('click', resumeAudio);
                                document.removeEventListener('keydown', resumeAudio);
                            });
                        } else {
                            // If already running or not supported, remove listeners
                            document.removeEventListener('click', resumeAudio);
                            document.removeEventListener('keydown', resumeAudio);
                        }
                    };
                    document.addEventListener('click', resumeAudio);
                    document.addEventListener('keydown', resumeAudio);

                } catch (e) {
                    console.error("Web Audio API is not supported in this browser.", e);
                    return null;
                }
            }
            // Handle state suspension manually if needed (e.g., on visibility change)
            if (audioCtx && audioCtx.state === 'suspended') {
                console.warn("AudioContext is suspended. User interaction needed to resume.");
                // No automatic resume here, rely on the gesture listener
            }
            return audioCtx;
        }


        // Store the noise buffer globally/outside the function
        let staticNoiseBuffer = null;

        // --- Sound Settings and GUI ---
        const soundSettings = {
            soundPreset: 'Tesla', // Options: "Tesla", "Default"
            attackTime: 0.001,
            mainDecayTime: 0.05,
            sizzleTailTime: 0.08,
            noiseGainLevel: 0.2,
            clickGainLevel: 0.08,
            sizzleFilterFreqBase: 5000,
            zapFilterFreqBase: 1200,
            clickFreqBase: 1500,
            distortionAmount: 1.2,
            freqRandomFactor: 0.15,
            timeRandomFactor: 0.20,
            playSpikeSound: function () {
                playSpikeSound();
            }
        };

        // When the preset is changed, update the parameters:
        function updatePreset(presetName) {
            if (presetName === 'Tesla') {
                soundSettings.attackTime = 0.001;
                soundSettings.mainDecayTime = 0.05;
                soundSettings.sizzleTailTime = 0.08;
                soundSettings.noiseGainLevel = 0.2;
                soundSettings.clickGainLevel = 0.08;
                soundSettings.sizzleFilterFreqBase = 5000;
                soundSettings.zapFilterFreqBase = 1200;
                soundSettings.clickFreqBase = 1500;
                soundSettings.distortionAmount = 1.2;
                soundSettings.freqRandomFactor = 0.15;
                soundSettings.timeRandomFactor = 0.20;
            } else if (presetName === 'Default') {
                // A simpler, cleaner spike sound (for example, based on a triangle oscillator)
                soundSettings.attackTime = 0.001;
                soundSettings.mainDecayTime = 0.03;
                soundSettings.sizzleTailTime = 0.06;
                soundSettings.noiseGainLevel = 0.3;
                soundSettings.clickGainLevel = 0.15;
                soundSettings.sizzleFilterFreqBase = 3500;
                soundSettings.zapFilterFreqBase = 1200;
                soundSettings.clickFreqBase = 1000;
                soundSettings.distortionAmount = 0.8;
                soundSettings.freqRandomFactor = 0.1;
                soundSettings.timeRandomFactor = 0.20;
            }
        }


        /**
         * Plays a sound designed to resemble a Tesla coil discharge.
         * Uses heavily filtered noise, distortion, and a sharp envelope.
         * Tuned by a simulated "senior natural sound engineer".
         * @param {object} options - Optional overrides for sound parameters.
         *                           Example: { gainScale: 1.2, distortionScale: 1.1 }
         */
        function playSpikeSound(options = {}) { // Accept options object
            const localAudioCtx = getAudioContext();
            if (!localAudioCtx || localAudioCtx.state !== 'running') return;

            try {
                const now = localAudioCtx.currentTime;

                // --- Use parameters from soundSettings, potentially scaled by options ---
                // Apply scaling factors from options, defaulting to 1.0
                const gainScale = options.gainScale || 1.0;
                const distortionScale = options.distortionScale || 1.0;
                // Add more scales if desired (e.g., freqScale)

                // Apply scaling to base parameters
                const attackTime = soundSettings.attackTime; // Usually keep attack fast
                const mainDecayTime = soundSettings.mainDecayTime * (options.decayScale || 1.0); // Optional decay scaling
                const sizzleTailTime = soundSettings.sizzleTailTime * (options.decayScale || 1.0);
                const noiseGainLevel = soundSettings.noiseGainLevel * gainScale; // Scale gain
                const clickGainLevel = soundSettings.clickGainLevel * gainScale; // Scale gain
                const sizzleFilterFreqBase = soundSettings.sizzleFilterFreqBase; // Keep base freqs for now
                const zapFilterFreqBase = soundSettings.zapFilterFreqBase;
                const clickFreqBase = soundSettings.clickFreqBase;
                const distortionAmount = soundSettings.distortionAmount * distortionScale; // Scale distortion
                const freqRandomFactor = soundSettings.freqRandomFactor;
                const timeRandomFactor = soundSettings.timeRandomFactor;

                // Randomization (remains the same)
                const currentMainDecay = mainDecayTime + randomRange(-mainDecayTime * timeRandomFactor, mainDecayTime * timeRandomFactor);
                const currentSizzleTail = sizzleTailTime + randomRange(-sizzleTailTime * timeRandomFactor, sizzleTailTime * timeRandomFactor);
                const currentSizzleFreq = sizzleFilterFreqBase + randomRange(-sizzleFilterFreqBase * freqRandomFactor, sizzleFilterFreqBase * freqRandomFactor);
                const currentZapFreq = zapFilterFreqBase + randomRange(-zapFilterFreqBase * freqRandomFactor, zapFilterFreqBase * freqRandomFactor);
                const currentClickFreq = clickFreqBase + randomRange(-clickFreqBase * freqRandomFactor * 2, clickFreqBase * freqRandomFactor * 2);

                // ===== Noise Component (uses scaled gains) =====
                if (!staticNoiseBuffer || staticNoiseBuffer.sampleRate !== localAudioCtx.sampleRate) {
                    // ... (noise buffer creation remains the same) ...
                    const bufferDuration = 0.15;
                    const bufferSize = Math.floor(localAudioCtx.sampleRate * bufferDuration);
                    staticNoiseBuffer = localAudioCtx.createBuffer(1, bufferSize, localAudioCtx.sampleRate);
                    const noiseData = staticNoiseBuffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        noiseData[i] = Math.random() * 2 - 1;
                    }
                    console.log("Generated static noise buffer.");
                }
                const noiseSource = localAudioCtx.createBufferSource();
                noiseSource.buffer = staticNoiseBuffer;
                noiseSource.loop = false;

                const sizzleFilter = localAudioCtx.createBiquadFilter();
                sizzleFilter.type = 'highpass';
                sizzleFilter.frequency.setValueAtTime(Math.max(1000, currentSizzleFreq), now);
                sizzleFilter.Q.setValueAtTime(1.5, now);

                const zapFilter = localAudioCtx.createBiquadFilter();
                zapFilter.type = 'peaking';
                zapFilter.frequency.setValueAtTime(Math.max(300, currentZapFreq), now);
                zapFilter.Q.setValueAtTime(8, now);
                zapFilter.gain.setValueAtTime(12, now); // Keep filter gain constant maybe?

                const noiseGain = localAudioCtx.createGain();
                noiseGain.gain.setValueAtTime(0.0, now);
                // Use the potentially scaled noiseGainLevel here
                noiseGain.gain.linearRampToValueAtTime(noiseGainLevel, now + attackTime);
                noiseGain.gain.setTargetAtTime(noiseGainLevel * 0.1, now + attackTime, currentMainDecay / 4);
                noiseGain.gain.setTargetAtTime(0.0, now + currentMainDecay, currentSizzleTail / 3);

                noiseSource.connect(sizzleFilter).connect(zapFilter).connect(noiseGain);

                // ===== Tonal Click Component (uses scaled gains) =====
                const oscillator = localAudioCtx.createOscillator();
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(currentClickFreq, now);

                const clickGain = localAudioCtx.createGain();
                clickGain.gain.setValueAtTime(0.0, now);
                // Use the potentially scaled clickGainLevel here
                clickGain.gain.linearRampToValueAtTime(clickGainLevel, now + attackTime);
                clickGain.gain.exponentialRampToValueAtTime(0.001, now + attackTime + 0.015);

                oscillator.connect(clickGain);

                // ===== Distortion (Waveshaper - uses scaled amount) =====
                const waveShaper = localAudioCtx.createWaveShaper();
                const curveSamples = 256;
                const curve = new Float32Array(curveSamples);
                // Use the potentially scaled distortionAmount here
                const k = distortionAmount * 80;
                for (let i = 0; i < curveSamples; ++i) {
                    const x = i * 2 / curveSamples - 1;
                    curve[i] = Math.tanh(x * (1 + k / 10));
                }
                waveShaper.curve = curve;
                waveShaper.oversample = '4x';

                // ===== Mixing & Output (add a limiter) =====
                const limiter = localAudioCtx.createDynamicsCompressor();
                limiter.threshold.setValueAtTime(-1.0, now); // Catch loud peaks
                limiter.knee.setValueAtTime(0, now);
                limiter.ratio.setValueAtTime(20.0, now); // Hard limiting
                limiter.attack.setValueAtTime(0.001, now);
                limiter.release.setValueAtTime(0.05, now);

                noiseGain.connect(waveShaper);
                clickGain.connect(waveShaper);
                waveShaper.connect(limiter).connect(localAudioCtx.destination); // Connect through limiter

                // ===== Start/Stop Timing =====
                // Ensure stop time accommodates potentially longer decay
                const stopTime = now + Math.max(currentMainDecay + currentSizzleTail, 0.1, attackTime + 0.015 + 0.05); // Ensure it covers click decay too
                oscillator.start(now);
                noiseSource.start(now);
                // Use try/catch for stop() as it can error if context closes prematurely
                try { oscillator.stop(stopTime); } catch (e) { /* ignore */ }
                try { noiseSource.stop(stopTime); } catch (e) { /* ignore */ }

            } catch (e) {
                console.error("Error playing spike sound:", e);
            }
        }

        /**
         * Called once per simulation step if any neurons spiked.
         * Calculates sound modulation based on the number of spikes and triggers
         * the actual sound playback with modified parameters.
         * @param {number} spikeCount - The number of neurons that spiked in this step.
         */
        function playSimulationStepSound(spikeCount) {
            if (spikeCount <= 0) {
                return; // No spikes, no sound
            }

            // --- Calculate Modulation Factors ---
            // Gain: Increase loudness slightly with more spikes.
            // Use a logarithmic scale (or similar) to prevent extreme loudness.
            // Map spikeCount (e.g., 1 to maxSimNeurons) to a gain scale (e.g., 1.0 to 1.5)
            const maxExpectedSpikes = Math.min(simulationParams.maxSimNeurons * 0.1, 50); // Estimate reasonable max simultaneous spikes
            const normalizedSpikeCount = Math.min(1.0, spikeCount / maxExpectedSpikes); // Normalize to 0-1 range

            const minGainScale = 1.0;
            const maxGainScale = 1.5; // Max volume increase (adjust as needed)
            // Simple linear mapping for now, could use log:
            const gainScale = minGainScale + (maxGainScale - minGainScale) * normalizedSpikeCount;

            // Distortion: Slightly increase distortion for more intense sound at high activity
            const minDistortionScale = 1.0;
            const maxDistortionScale = 1.2; // Modest increase
            const distortionScale = minDistortionScale + (maxDistortionScale - minDistortionScale) * normalizedSpikeCount;

            // Decay: Optional - slightly longer decay for more spikes?
            const minDecayScale = 1.0;
            const maxDecayScale = 1.1;
            const decayScale = minDecayScale + (maxDecayScale - minDecayScale) * normalizedSpikeCount;


            // --- Prepare Options for playSpikeSound ---
            const soundOptions = {
                gainScale: gainScale,
                distortionScale: distortionScale,
                decayScale: decayScale
                // Add other scaled parameters if desired
            };

            // Log the triggered sound event and parameters
            // console.log(`Sim Step Sound: ${spikeCount} spikes. GainScale: ${gainScale.toFixed(2)}, DistScale: ${distortionScale.toFixed(2)}`);

            // --- Trigger the Sound ---
            playSpikeSound(soundOptions);
        }

        // --- Continuous Spiking Controller (Refined) ---
        class ContinuousSpikingController {
            constructor(options = {}) {
                this.intervalMs = options.intervalMs || 100; // Default ~10 Hz
                this.soundHandler = options.soundHandler || (() => { }); // Function to play sound
                this.visualHandler = options.visualHandler || (() => { }); // Function to trigger visual update (now done in main loop)
                this.visualReset = options.visualReset || (() => { }); // Function to reset visuals (now done in main loop)
                this.timer = null;
                this._isActive = false; // Internal state
            }

            get isActive() {
                return this._isActive;
            }

            start() {
                if (this._isActive) return;
                // Check if simulation visuals are ready before starting?
                // This check might be better placed in the UI event handler.
                this._isActive = true;
                this.timer = setInterval(() => this.handleSpike(), this.intervalMs);
                console.log("ContinuousSpikingController: ACTIVATED.");
            }

            stop() {
                if (!this._isActive) return;
                if (this.timer) {
                    clearInterval(this.timer);
                    this.timer = null;
                }
                this._isActive = false;
                // Visual reset is now handled by the main loop checking this.isActive
                console.log("ContinuousSpikingController: DEACTIVATED.");
            }

            handleSpike() {
                // Play the auditory spike
                this.soundHandler();
                // The visual update is now driven by the isActive flag in the main animate loop's call to simulationVisuals.update()
            }
        }

        // --- Physics World Setup ---
        const physicsWorld = new CANNON.World();
        physicsWorld.gravity.set(0, 0, 0); // No gravity needed for this effect
        physicsWorld.broadphase = new CANNON.NaiveBroadphase(); // Simple broadphase
        physicsWorld.solver.iterations = 5; // Fewer iterations might suffice

        // Physics materials (optional but good practice)
        const pulseMaterial = new CANNON.Material("pulseMaterial");
        const targetMaterial = new CANNON.Material("targetMaterial");
        const pulseTargetContactMaterial = new CANNON.ContactMaterial(pulseMaterial, targetMaterial, {
            friction: 0,
            restitution: 0.5 // Little bounce
        });
        physicsWorld.addContactMaterial(pulseTargetContactMaterial);



        document.addEventListener("DOMContentLoaded", function () {
            // When the page loads, try to restore cached state.
            restoreState();

            // Get tooltip elements
            const selectedTooltip = document.getElementById("selectedTooltip");
            let selectedTooltipContent, selectedTooltipCloseBtn;
            if (selectedTooltip) {
                selectedTooltipContent = selectedTooltip.querySelector(".content");
                selectedTooltipCloseBtn = selectedTooltip.querySelector(".close-btn");
                if (!selectedTooltipCloseBtn) {
                    console.error("Error: 'selectedTooltipCloseBtn' element not found.");
                }
            } else {
                console.error("Error: 'selectedTooltip' element not found.");
                selectedTooltipContent = document.createElement("span");
            }

            // Global Variables and Setup
            const RESOLUTION = { x: 1, y: 1, z: 2 };
            const POINT_SIZE_DEFAULT = 5;
            const POINT_OPACITY_DEFAULT = 0.75;
            const RAYCASTER_THRESHOLD_FACTOR = 0.3;

            // --- Lighting Intensity Constants for Theme Switching ---
            const AMBIENT_LIGHT_INTENSITY = 1.0;
            const POINT_LIGHT_INTENSITY = 0.8;
            const DIR_LIGHT_INTENSITY = 0.5;

            // Keyframe animation array
            let keyframes = [];

            // Recording variables
            let mediaRecorder = null;
            let recordedChunks = [];

            // Three.js Scene Setup
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.001, 500000);
            camera.position.set(0, 0, 10000);
            const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // OrbitControls (enabled by default, disabled in manual fly mode)
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            controls.minDistance = 0.001;
            controls.maxDistance = 500000;
            controls.enablePan = true;
            controls.enableZoom = true;
            controls.autoRotateSpeed = 2.0; //positive rotates clockwise


            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040, AMBIENT_LIGHT_INTENSITY);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, POINT_LIGHT_INTENSITY, 100);

            pointLight.position.set(10, 15, 10);
            scene.add(pointLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, DIR_LIGHT_INTENSITY);
            dirLight.position.set(-10, -5, 5);
            scene.add(dirLight);

            // After creating the controls:
            if (!controls.sphericalDelta) {
                controls.sphericalDelta = { theta: 0, phi: 0 };
            }

            controls.rotateLeft = function (angle) {
                this.sphericalDelta.theta = (this.sphericalDelta.theta || 0) - angle;
            };
            controls.rotateUp = function (angle) {
                this.sphericalDelta.phi = (this.sphericalDelta.phi || 0) - angle;
            };

            // Add rotateLeft if not present.
            if (typeof controls.rotateLeft !== 'function') {
                controls.rotateLeft = function (angle) {
                    // OrbitControls uses a spherical coordinate delta to track changes.
                    // Subtract angle from the azimuthal (theta) delta.
                    this.sphericalDelta.theta -= angle;
                };
            }

            // Add rotateUp if not present.
            if (typeof controls.rotateUp !== 'function') {
                controls.rotateUp = function (angle) {
                    // Subtract angle from the polar (phi) delta.
                    this.sphericalDelta.phi -= angle;
                };
            }


            const axesHelper = new THREE.AxesHelper(1000);
            scene.add(axesHelper);
            let axesVisible = true;

            const brainGroup = new THREE.Group();
            scene.add(brainGroup);
            let referencePlanes = null;
            let planesVisible = false;

            // Data storage
            let geometry = null;
            let points = null;
            let pointMaterial = null;
            let regionInfoList = [];
            // If not null, the region list UI shows only these region IDs
            let pinnedRegionIDsForDisplay = null; // snapshot of checked regions when "Show Checked Regions" is clicked
            let currentVisibleIndices = null;
            let dataBounds = { center: new THREE.Vector3(), size: 1000, min: new THREE.Vector3(), max: new THREE.Vector3() };
            let finalPositions = null, finalColors = null, finalPointRegionIDs = null, finalIntensities = null;

            // Accumulation arrays for CSV data
            let accumulatedPositions = [];
            let accumulatedColors = [];
            let accumulatedPointRegionIDs = [];
            let accumulatedIntensities = [];
            let expectedTotalPoints = 0, receivedPoints = 0;
            let isProcessingComplete = false;

            let showStylizedNeuronsEnabled = false; // Default to OFF
            let stylizedNeuronsByRegion = {}; // Stores { regionId: [StylizedNeuronInstance, ...] }
            let activeStylizedNeurons = []; // Flat list for easier update iteration

            // UI Elements
            const hoverTooltip = document.getElementById("hoverTooltip");
            const loadingIndicator = document.getElementById("loadingIndicator");
            const loadingMessage = document.getElementById("loadingMessage");
            const loadingProgress = document.getElementById("loadingProgress");
            const recordingIndicator = document.getElementById("recordingIndicator");
            const downloadContainer = document.getElementById("downloadContainer");

            // Worker variable
            let dataWorker = null;

            // Manual fly mode variables
            let manualFlyMode = false;
            const flySpeed = 200; // units per second
            const flyKeys = { W: false, A: false, S: false, D: false, Q: false, E: false };
            // Declare flyClock only once
            const flyClock = new THREE.Clock();

            // Keyboard listeners for manual fly controls
            document.addEventListener("keydown", (e) => {
                if (!manualFlyMode) return;
                const key = e.key.toUpperCase();
                if (flyKeys.hasOwnProperty(key)) {
                    flyKeys[key] = true;
                }
            });
            document.addEventListener("keyup", (e) => {
                if (!manualFlyMode) return;
                const key = e.key.toUpperCase();
                if (flyKeys.hasOwnProperty(key)) {
                    flyKeys[key] = false;
                }
            });

            // Update manual fly mode using flyClock
            function updateFlyMode() {
                if (!manualFlyMode) return;
                const delta = flyClock.getDelta();
                const forward = new THREE.Vector3();
                camera.getWorldDirection(forward).normalize();
                const right = new THREE.Vector3();
                right.crossVectors(forward, camera.up).normalize();
                const up = new THREE.Vector3(0, 1, 0);
                const moveVector = new THREE.Vector3();
                if (flyKeys.W) moveVector.add(forward);
                if (flyKeys.S) moveVector.sub(forward);
                if (flyKeys.A) moveVector.sub(right);
                if (flyKeys.D) moveVector.add(right);
                if (flyKeys.Q) moveVector.add(up);
                if (flyKeys.E) moveVector.sub(up);
                if (moveVector.length() > 0) {
                    moveVector.normalize().multiplyScalar(flySpeed * delta);
                    camera.position.add(moveVector);
                    controls.target.add(moveVector);
                }
            }

            // dat.GUI Setup
            const guiParams = {
                pointSize: POINT_SIZE_DEFAULT,
                opacity: POINT_OPACITY_DEFAULT,
                regionSearch: "",
                useGrayscale: false,
                rawIntensityMin: 0,
                rawIntensityMax: 1,
                grayContrast: 1.0,
                maxStylizedNeuronsPerRegion: 100,
                // Region filtering helpers (snapshot-only behavior)
                focusOnChecked: () => {
                    // Take a snapshot of currently checked regions for display; list won't auto-change on uncheck
                    const selectedIds = regionInfoList.filter(r => r && r.visible).map(r => r.id);
                    pinnedRegionIDsForDisplay = new Set(selectedIds);
                    // Clear search to see the full pinned set
                    guiParams.regionSearch = "";
                    if (typeof regionSearchController !== 'undefined' && regionSearchController) {
                        regionSearchController.updateDisplay();
                    }
                    filterAndRebuildRegionGUI();
                },
                showAllRegions: () => {
                    // Clear the pinned snapshot and show full searchable list again
                    pinnedRegionIDsForDisplay = null;
                    filterAndRebuildRegionGUI();
                },
                selectAllRegions: () => { toggleAllRegions(true); },
                deselectAllRegions: () => { toggleAllRegions(false); }
            };

            const gui = new dat.GUI();
            const vizFolder = gui.addFolder("Visualization");
            vizFolder.add(guiParams, "pointSize", 1, 50, 0.5)
                .name("Point Size")
                .onChange(() => {
                    updateMaterial();
                    updateRaycasterThreshold();
                    updateAllStylizedNeuronSomaScales();
                });
            vizFolder.add(guiParams, "opacity", 0.05, 1.0, 0.05)
                .name("Point Opacity")
                .onChange(updateMaterial);
            vizFolder.add(guiParams, "useGrayscale")
                .name("Grayscale Mode")
                .onChange((val) => {
                    if (pointMaterial && pointMaterial.userData.shader)
                        pointMaterial.userData.shader.uniforms.useGrayscale.value = val;
                });

            vizFolder.add(guiParams, "maxStylizedNeuronsPerRegion", 0, 100, 1)
                .name("Max Stylized Neurons / Region")
                .onChange((value) => {
                    // Optional: Could trigger an update if needed, but usually
                    // the limit is applied when a region checkbox is toggled.
                    console.log("Max stylized neurons per region set to:", value);
                });
            vizFolder.open();

            // --- Function to update all active neuron SOMA scales ---
            function updateAllStylizedNeuronSomaScales() {
                if (typeof guiParams === 'undefined') {
                    console.error("guiParams not accessible in updateAllStylizedNeuronSomaScales");
                    return;
                }
                activeStylizedNeurons.forEach(neuron => {
                    if (neuron && typeof neuron.updateSomaScale === 'function') {
                        neuron.updateSomaScale(); // Call the specific method
                    }
                });
                // console.log("Updated soma scales for active stylized neurons.");
            }

            const intensityFolder = gui.addFolder("Intensity Mapping");
            let rawMinController = intensityFolder.add(guiParams, "rawIntensityMin", 0, 1, 1)
                .name("Raw Min")
                .onChange((val) => { if (pointMaterial && pointMaterial.userData.shader) pointMaterial.userData.shader.uniforms.rawMin.value = val; });
            let rawMaxController = intensityFolder.add(guiParams, "rawIntensityMax", 0, 1, 1)
                .name("Raw Max")
                .onChange((val) => { if (pointMaterial && pointMaterial.userData.shader) pointMaterial.userData.shader.uniforms.rawMax.value = val; });
            let grayContrastController = intensityFolder.add(guiParams, "grayContrast", 0.1, 3.0, 0.1)
                .name("Gray Contrast")
                .onChange((val) => { if (pointMaterial && pointMaterial.userData.shader) pointMaterial.userData.shader.uniforms.grayContrast.value = val; });
            intensityFolder.open();

            const filterFolder = gui.addFolder("Region Filtering");
            let searchDebounceTimer = null;
            let regionSearchController = filterFolder.add(guiParams, "regionSearch")
                .name("Search")
                .onChange(() => {
                    clearTimeout(searchDebounceTimer);
                    searchDebounceTimer = setTimeout(filterAndRebuildRegionGUI, 250);
                });
            filterFolder.add(guiParams, "focusOnChecked").name("Show Checked Regions");
            filterFolder.add(guiParams, "showAllRegions").name("Show All Regions");
            filterFolder.add(guiParams, "selectAllRegions").name("Select All");
            filterFolder.add(guiParams, "deselectAllRegions").name("Deselect All");
            filterFolder.open();

            // --- Save/Load State Buttons ---
            document.getElementById("saveStateButton").addEventListener("click", () => {
                const spinner = document.getElementById("saveSpinner");
                spinner.style.display = "inline-block";
                // Use a timeout to allow the spinner to render before blocking thread
                setTimeout(() => {
                    saveStateToFile((success) => { // Pass callback
                        spinner.style.display = "none"; // Hide spinner regardless of success/failure
                        if (!success) {
                            // Optionally show an error message if save failed internally
                            // alert("Failed to save state. See console for details.");
                        }
                    });
                }, 10); // Small delay like 10ms is usually enough
            });

            document.getElementById("loadStateButton").addEventListener("click", () => {
                // Just trigger the hidden file input
                document.getElementById("loadStateInput").click();
            });

            document.getElementById("loadStateInput").addEventListener("change", (event) => {
                if (event.target.files.length > 0) {
                    const file = event.target.files[0];
                    const spinner = document.getElementById("loadSpinner");
                    spinner.style.display = "inline-block";

                    // Use timeout for spinner rendering
                    setTimeout(() => {
                        loadStateFromFile(file, (success) => { // Pass callback
                            spinner.style.display = "none"; // Hide spinner on completion/error
                            if (!success) {
                                // Error messages are handled within loadStateFromFile
                                // alert("Failed to load state. Check console for details.");
                            }
                            // Clear the input value so the same file can be selected again
                            event.target.value = null;
                        });
                    }, 10);
                }
            });


            // Tutorial modal controls
            const tutorialModal = document.getElementById("tutorialModal");
            document.getElementById("showTutorial").addEventListener("click", () => {
                tutorialModal.style.display = "block";
            });
            document.getElementById("closeTutorial").addEventListener("click", () => {
                tutorialModal.style.display = "none";
            });


            // ===  "Restore Defaults" Button in Settings ===

            //add a dat.GUI action to reset settings (without clearing the CSV cache).
            const settingsFolder = gui.addFolder("Settings");
            const settingsActions = {
                restoreDefaults: function () {
                    // Overwrite the in-session guiParams with the default values.
                    Object.keys(defaultGuiParams).forEach(key => { guiParams[key] = defaultGuiParams[key]; });
                    gui.updateDisplay();
                    // Refresh the material, filter, camera, etc.
                    updateMaterial();
                    updateFilteredPoints();
                    resetCameraView(true);
                    console.log("Settings restored to default for this session.");
                    // Optionally: Save these defaults to cache.
                    saveState();
                }
            };
            settingsFolder.add(settingsActions, "restoreDefaults").name("Restore Defaults");
            settingsFolder.open();

            // Global simulation parameters for the network simulation (default values).
            const simulationParams = {
                running: false,
                // --- Performance ---
                maxSimNeurons: 20000,          // Max neurons to simulate in detail (sampling)
                // --- Connectivity ---
                useLocalConnectivity: true,     // Toggle local vs global random
                connectivityRadiusW: 30,       // Max distance for local connections (units based on coordinates)
                localConnectionProbability: 0.1,// Chance to connect if within radius
                // --- Neuron Dynamics (HH related) ---
                // Note: These are simplified params driving the HH model, not direct HH constants
                baseExcitatoryDrive: 8.0,  // External current drive for E neurons (adjust based on model tuning)
                baseInhibitoryDrive: 6.0, // External current drive for I neurons
                firingProbability: 0.15,     // Base external drive/probability influence (adjust based on model)
                gammaFrequency: 40.0,           // Target oscillation frequency (Hz)
                gammaAmplitude: 5.0,            // Strength of oscillatory current drive
                refractoryPeriodMs: 5.0,    // Neuron refractory period (ms)
                // --- Synaptic Plasticity (STDP) ---
                enableSTDP: true,            // Toggle STDP on/off
                stdpLearningRate: 0.005,     // How much weights change per spike pair
                stdpTimeWindow: 20,          // Time window (ms) for LTP/LTD
                maxWeight: 5.0,              // Maximum synaptic weight
                minWeight: 0.1,              // Minimum synaptic weight
                // --- Aesthetics ---
                connectionLifeTimeMs: 300, // How long connection visualization persists (e.g., dendrite tubes)
                maxConnectionsPerSpike: 5, // Limit visual connections shown per spike
                markerBaseScale: 8,
                markerSpikeScaleFactor: 3,
                markerGlowScaleFactor: 2.5,
                boltLifetimeMs: 150,         // Lifetime of excitatory sparks (ms)
                maxBoltsPerSpike: 3,         // Max sparks per E-neuron firing
                inhibitoryGlowDuration: 300, // How long the purple glow lasts (ms)
                // --- Scene Effects ---
                fogDensity: 0.0,         // Volumetric fog density
                bloomStrength: 1.8,          // Bloom intensity
                bloomRadius: 0.5,            // Bloom radius
                bloomThreshold: 0.75,        // Bloom threshold (lower = more glows)
                // --- Simulation Internals ---
                simulationDt: 0.001,         // Simulation integration timestep (s) - Tied to HH model needs!
                simulationStepsPerFrame: 5,  // How many sim steps per render frame
                maxStylizedNeuronsPerRegion: 100, // Mirror GUI param initially
            };

            // Store a deep copy of the initial default parameters *before* GUI or state loading modifies them
            const defaultSimulationParams = JSON.parse(JSON.stringify(simulationParams, (key, value) => {
                // Exclude functions from the deep copy
                return typeof value === 'function' ? undefined : value;
            }));
            // Log to confirm it's created
            console.log("Default simulation parameters captured:", defaultSimulationParams);


            // Override the placeholder functions in simulationParams
            simulationParams.startSimulation = function () { /* ... Logic to gather data, sample, and call simulationManager.initialize() then .start() ... */
                console.log("GUI: Requesting simulation start...");
                const selectedRegionIDs = regionInfoList.filter(r => r && r.visible).map(r => r.id);
                if (selectedRegionIDs.length === 0) { alert("No regions selected..."); /* ... */ return; }
                let allNeuronsData = []; /* ... Gather data ... */
                if (allNeuronsData.length === 0) { alert("No neurons found..."); /* ... */ return; }
                let sampledNeuronsData = allNeuronsData; /* ... Sample data ... */
                if (allNeuronsData.length > simulationParams.maxSimNeurons) { sampledNeuronsData = allNeuronsData.sort(() => 0.5 - Math.random()).slice(0, simulationParams.maxSimNeurons); }
                const initSuccess = simulationManager.initialize(sampledNeuronsData);
                if (initSuccess) { simulationVisuals.initialize(simulationManager.neurons); simulationManager.start(); }
                else { alert("Simulation init failed."); simulationParams.running = false; }
                if (runningController) runningController.updateDisplay();
            };



            simulationParams.stopSimulation = function () {
                console.log("GUI Action: Requesting detailed simulation stop..."); // Log Entry

                // 1. Stop the Core Simulation Logic & Update State
                if (simulationManager && simulationManager.params.isInitialized) {
                    console.log(" -> Calling simulationManager.stop()...");
                    simulationManager.stop(); // This sets the shared 'running' flag to false internally
                } else {
                    console.warn(" -> simulationManager not found or not initialized to stop.");
                    // Manually set the flag as a fallback
                    simulationParams.running = false;
                }

                // 2. Explicitly Reset Simulation Visuals Immediately
                // This cleans up markers, transient connections, etc., related to the detailed sim.
                if (simulationVisuals && simulationVisuals.isInitialized) {
                    console.log(" -> Calling simulationVisuals._resetVisuals()...");
                    simulationVisuals._resetVisuals();
                } else {
                    console.warn(" -> simulationVisuals not found or not initialized to reset.");
                }

                // 3. Verify and Ensure the Running Flag is False (Safety check)
                if (simulationParams.running) {
                    console.warn(" -> 'simulationParams.running' flag was still true after manager stop. Forcing false.");
                    simulationParams.running = false;
                } else {
                    console.log(" -> 'simulationParams.running' flag is correctly false.");
                }

                // 4. Update the GUI 'Running' Toggle State
                if (runningController) {
                    console.log(" -> Updating GUI 'Running' controller display...");
                    runningController.updateDisplay(); // Reflect the change in the checkbox
                } else {
                    console.warn(" -> 'Running' GUI controller not found to update display.");
                }

                console.log("GUI Action: Detailed simulation stop sequence complete.");
            }; // End of refactored simulationParams.stopSimulation


            // Create a new folder for simulation parameters
            const simFolder = gui.addFolder("Neuron Firing Simulation");

            // Add Connectivity Controls
            const connFolder = simFolder.addFolder("Connectivity");
            connFolder.add(simulationParams, "useLocalConnectivity").name("Use Local (Radius)");
            connFolder.add(simulationParams, "connectivityRadiusW", 0, 1500, 10).name("Radius (W)");
            connFolder.add(simulationParams, "localConnectionProbability", 0.01, 1.0, 0.01).name("Connect Probability");
            connFolder.open();


            //simFolder.add(simulationParams, "running").name("Running").listen();
            // Add the 'running' controller but store a reference to it
            let runningController = simFolder.add(simulationParams, "running").name("Running").listen();

            // Add an onChange handler to THIS specific controller
            runningController.onChange(function (value) {
                console.log(`GUI 'Running' toggle changed by user to: ${value}`);
                if (value === true) {
                    // User wants to START the simulation
                    // Check if it's already running to prevent multiple starts
                    if (!simulationParams.running) {
                        console.log("GUI Toggle: Calling startSimulation()");
                        simulationParams.startSimulation(); // Use the existing start function
                    } else {
                        console.log("GUI Toggle: Already running, no action.");
                    }
                } else {
                    // User wants to STOP the simulation
                    // Check if it's actually running to prevent multiple stops
                    if (simulationParams.running) {
                        console.log("GUI Toggle: Calling stopSimulation()");
                        simulationParams.stopSimulation(); // Use the existing stop function
                    } else {
                        console.log("GUI Toggle: Already stopped, no action.");
                    }
                }
            });

            simFolder.add(simulationParams, "maxSimNeurons", 50, 2000, 50).name("Max Simulated Neurons");
            // Add/Update Neuron Dynamics Controls
            simFolder.add(simulationParams, "firingProbability", 0.0, 0.5, 0.01).name("Base Drive"); // Renamed for clarity
            simFolder.add(simulationParams, "gammaFrequency", 10.0, 100.0, 1.0).name("Gamma Freq (Hz)");
            simFolder.add(simulationParams, "gammaAmplitude", 0.0, 15.0, 0.1).name("Gamma Amplitude");

            simFolder.add(simulationParams, "enableSTDP").name("Enable STDP");
            simFolder.add(simulationParams, "stdpLearningRate", 0.0001, 0.02, 0.0005).name("STDP Learn Rate");
            simFolder.add(simulationParams, "stdpTimeWindow", 5, 100, 1).name("STDP Window (ms)");
            simFolder.add(simulationParams, "maxWeight", 1.0, 10.0, 0.1).name("Max Syn Weight");
            simFolder.add(simulationParams, "minWeight", 0.01, 1.0, 0.01).name("Min Syn Weight");
            simFolder.add(simulationParams, "boltLifetimeMs", 50, 500, 10).name("Spark Lifetime (ms)");
            simFolder.add(simulationParams, "maxBoltsPerSpike", 1, 10, 1).name("Max Sparks / Spike");
            simFolder.add(simulationParams, "inhibitoryGlowDuration", 100, 1000, 20).name("Inhib. Glow (ms)");
            simFolder.add(simulationParams, "fogDensity", 0.0, 0.001, 0.00001).name("Fog Density").onChange(val => {
                if (scene.fog) scene.fog.density = val;
            });
            simFolder.add(simulationParams, "bloomStrength", 0.0, 3.0, 0.1).name("Bloom Strength").onChange(val => {
                if (bloomPass) bloomPass.strength = val;
            });
            simFolder.add(simulationParams, "bloomRadius", 0.0, 2.0, 0.05).name("Bloom Radius").onChange(val => {
                if (bloomPass) bloomPass.radius = val;
            });
            simFolder.add(simulationParams, "bloomThreshold", 0.0, 1.0, 0.01).name("Bloom Threshold").onChange(val => {
                if (bloomPass) bloomPass.threshold = val;
            });
            // Link GUI param to simulation param if needed
            guiParams.maxStylizedNeuronsPerRegion = simulationParams.maxStylizedNeuronsPerRegion;
            simFolder.add(simulationParams, 'maxStylizedNeuronsPerRegion', 0, 100, 1).name("Max Stylized / Region")
                .onChange(value => { guiParams.maxStylizedNeuronsPerRegion = value; }); // Keep GUI param synced
            // Keep sim dt / steps per frame if useful for debugging, but maybe hide initially
            simFolder.add(simulationParams, "startSimulation").name("Start Simulation");
            simFolder.add(simulationParams, "stopSimulation").name("Stop Simulation");
            // Add the Clear/Reset button directly to the GUI folder
            simFolder.add({ clearReset: clearSimulationState }, 'clearReset').name("Clear Simulation");

            // 1. Handler for the main "Running" toggle in dat.GUI
            // (Ensure this is applied after runningController is defined)
            if (runningController) {
                runningController.onChange(function (value) {
                    console.log(`GUI 'Running' toggle changed by user to: ${value}`);
                    if (value === true) {
                        // User wants to START detailed simulation
                        if (!simulationParams.running) { // Check internal state first
                            // --- Ensure Continuous Spiker is OFF before starting detailed sim ---
                            if (continuousSpiker && continuousSpiker.isActive) {
                                console.log("   -> Stopping continuous spiker first...");
                                continuousSpiker.stop();
                                const toggleSpike = document.getElementById("toggleContinuousSpiking");
                                if (toggleSpike) toggleSpike.checked = false; // Update its UI toggle
                            }
                            // --- Now start the detailed simulation ---
                            console.log("   -> Calling startSimulation()...");
                            simulationParams.startSimulation(); // Use the manager-linked start function
                        } else {
                            console.log("   -> Detailed simulation already running.");
                        }
                    } else {
                        // User wants to STOP detailed simulation
                        if (simulationParams.running) { // Check internal state first
                            console.log("   -> Calling stopSimulation()...");
                            simulationParams.stopSimulation(); // Use the manager-linked stop function
                        } else {
                            console.log("   -> Detailed simulation already stopped.");
                        }
                    }
                });
            } else {
                console.warn("Could not find 'Running' controller in dat.GUI folder to attach onChange handler.");
            }


            // 2. Handler for the "Continuous Spiking" toggle switch
            // (Replace the existing event listener for 'toggleContinuousSpiking')
            document.getElementById("toggleContinuousSpiking").addEventListener("change", function () {
                if (this.checked) {
                    // User wants to START Continuous Spiking
                    console.log("UI Toggle: Continuous Spiking ON requested.");

                    // a) Check if visuals are ready (needed for continuous mode too)
                    if (!simulationVisuals || !simulationVisuals.isInitialized) {
                        alert("Simulation needs to be initialized first (Load data and press Start Simulation at least once).");
                        this.checked = false; // Revert toggle
                        console.warn(" -> Aborted: Simulation visuals not ready.");
                        return;
                    }

                    // b) Stop the DETAILED simulation if it's running
                    if (simulationManager && simulationManager.params.running) {
                        console.log(" -> Stopping detailed simulation first...");
                        simulationParams.stopSimulation(); // Use the proper stop function
                    }

                    // c) Start the continuous spiker
                    console.log(" -> Starting continuous spiker...");
                    continuousSpiker.start();

                } else {
                    // User wants to STOP Continuous Spiking
                    console.log("UI Toggle: Continuous Spiking OFF requested.");
                    if (continuousSpiker && continuousSpiker.isActive) {
                        console.log(" -> Stopping continuous spiker...");
                        continuousSpiker.stop();
                    } else {
                        console.log(" -> Continuous spiker was already stopped.");
                    }
                }
            });


            // create a new folder for sound settings
            const soundFolder = gui.addFolder("Sound Settings");
            soundFolder.add(soundSettings, "soundPreset", ["Tesla", "Default"])
                .name("Sound Preset")
                .onChange(updatePreset);
            soundFolder.add(soundSettings, "attackTime", 0.0005, 0.005, 0.0001).name("Attack Time");
            soundFolder.add(soundSettings, "mainDecayTime", 0.01, 0.1, 0.001).name("Main Decay Time");
            soundFolder.add(soundSettings, "sizzleTailTime", 0.05, 0.15, 0.001).name("Sizzle Tail Time");
            soundFolder.add(soundSettings, "noiseGainLevel", 0, 1, 0.01).name("Noise Gain");
            soundFolder.add(soundSettings, "clickGainLevel", 0, 0.5, 0.01).name("Click Gain");
            soundFolder.add(soundSettings, "sizzleFilterFreqBase", 1000, 8000, 100).name("Sizzle Filter Freq");
            soundFolder.add(soundSettings, "zapFilterFreqBase", 300, 3000, 50).name("Zap Filter Freq");
            soundFolder.add(soundSettings, "clickFreqBase", 500, 3000, 50).name("Click Frequency");
            soundFolder.add(soundSettings, "distortionAmount", 0, 2, 0.01).name("Distortion Amount");
            soundFolder.add(soundSettings, "freqRandomFactor", 0, 0.5, 0.01).name("Freq Randomizer");
            soundFolder.add(soundSettings, "timeRandomFactor", 0, 0.5, 0.01).name("Time Randomizer");
            soundFolder.add(soundSettings, "playSpikeSound").name("Play Spike Sound");


            // --- Fly‚ÄìThrough Feature Functions ---
            // Compute region centers
            function computeRegionCenters() {
                const regionSums = {};
                for (let i = 0; i < finalPointRegionIDs.length; i++) {
                    const regionID = finalPointRegionIDs[i];
                    const x = finalPositions[i * 3 + 0],
                        y = finalPositions[i * 3 + 1],
                        z = finalPositions[i * 3 + 2];
                    if (!regionSums[regionID]) {
                        regionSums[regionID] = { sum: new THREE.Vector3(), count: 0 };
                    }
                    regionSums[regionID].sum.add(new THREE.Vector3(x, y, z));
                    regionSums[regionID].count++;
                }
                for (let id in regionSums) {
                    regionInfoList[id].center = regionSums[id].sum.divideScalar(regionSums[id].count);
                }
            }

            // Declare a global variable to store the fly-through animation frame ID
            let flyAnimationId = null;
            let isFlyThroughActive = false;

            // Automated fly-through via spline through selected regions
            function flyThroughSelectedRegions(duration = 15000) {
                isFlyThroughActive = true;
                // Enable blending for fly-through mode
                if (pointMaterial && pointMaterial.userData.shader) {
                    pointMaterial.userData.shader.uniforms.enableBlink.value = true;
                }

                const flightWaypoints = [];
                regionInfoList.forEach(region => {
                    if (region.visible && region.center) {
                        flightWaypoints.push(region.center.clone());
                    }
                });
                if (flightWaypoints.length < 2) {
                    console.warn("At least 2 regions must be selected for fly‚Äìthrough.");
                    return;
                }
                const flightPath = new THREE.CatmullRomCurve3(flightWaypoints, true);
                const clock = new THREE.Clock();
                const totalTime = duration;

                // Reset the clock so the animation starts from the beginning
                clock.start();
                // Function that updates the camera position and orientation along the flight path
                function animateFlight() {
                    if (!isFlyThroughActive) return; // Stop if fly-through is not active
                    const elapsed = clock.getElapsedTime() * 1000; // elapsed time in milliseconds
                    const t = (elapsed % totalTime) / totalTime; // Normalize t to [0, 1]
                    const pos = flightPath.getPointAt(t);
                    camera.position.copy(pos);
                    const lookAtPos = flightPath.getPointAt((t + 0.01) % 1);
                    camera.lookAt(lookAtPos);
                    controls.update();
                    renderer.render(scene, camera);
                    // Request the next frame and store the ID
                    flyAnimationId = requestAnimationFrame(animateFlight);
                }
                animateFlight();
            }

            document.getElementById("flyThroughRegions").addEventListener("click", () => {
                computeRegionCenters();
                flyThroughSelectedRegions(15000);
            });

            //Function to stop the fly-through animation
            function stopFlyThrough() {
                isFlyThroughActive = false;
                // Cancel the animation frame if it's running
                if (flyAnimationId != null) {
                    cancelAnimationFrame(flyAnimationId);
                    flyAnimationId = null;
                    console.log("Fly-through animation stopped.");
                }
                if (pointMaterial && pointMaterial.userData.shader) {
                    pointMaterial.userData.shader.uniforms.enableBlink.value = false;
                }
            }

            document.getElementById("stopFlyThrough").addEventListener("click", stopFlyThrough);


            function rotateCamera(controls, deltaTheta, deltaPhi) {
                // Compute the offset from the target.
                const offset = new THREE.Vector3();
                offset.copy(camera.position).sub(controls.target);

                // Convert the offset to spherical coordinates.
                const spherical = new THREE.Spherical();
                spherical.setFromVector3(offset);

                // Apply deltas.
                spherical.theta += deltaTheta; // change yaw
                spherical.phi += deltaPhi;   // change pitch

                // Restrict the polar angle (phi) to be between EPS and PI - EPS.
                const EPS = 0.000001;
                spherical.phi = Math.max(EPS, Math.min(Math.PI - EPS, spherical.phi));

                // Convert the spherical coordinates back to a Cartesian offset.
                offset.setFromSpherical(spherical);

                // Update the camera position.
                camera.position.copy(controls.target).add(offset);
                camera.lookAt(controls.target);
                controls.update();
            }

            // Helper function to rotate the camera around its forward vector (roll).
            function rollCamera(angle) {
                // Get the camera's forward direction (normalized)
                const forward = new THREE.Vector3();
                camera.getWorldDirection(forward);

                // Create a quaternion that represents a rotation around this forward axis.
                const q = new THREE.Quaternion();
                q.setFromAxisAngle(forward, angle);

                // Apply the rotation to the camera's up vector.
                camera.up.applyQuaternion(q);

                // (Optional) You can update other camera parameters if needed.
                // Ensure the camera still looks at the target.
                camera.lookAt(controls.target);
                controls.update();
            }


            // Set the angular step in radians
            const ANGLE_STEP = 0.1;

            // Yaw (rotation around the vertical axis)
            document.getElementById('yawLeftButton').addEventListener('click', () => {
                // Rotate left (positive rotateLeft value)
                rotateCamera(controls, ANGLE_STEP, 0);
            });

            document.getElementById('yawRightButton').addEventListener('click', () => {
                // Rotate right (negative rotateLeft value)
                rotateCamera(controls, -ANGLE_STEP, 0);
            });

            // Pitch (rotation around the horizontal axis)
            // OrbitControls provides rotateUp(), which moves the camera up (pitching down) if you use a positive value.
            // To get a ‚Äúpitch up‚Äù effect (i.e. look upward), you rotate up with a negative value.
            document.getElementById('pitchUpButton').addEventListener('click', () => {
                rotateCamera(controls, 0, -ANGLE_STEP);
            });

            document.getElementById('pitchDownButton').addEventListener('click', () => {
                rotateCamera(controls, 0, ANGLE_STEP);
            });

            // Roll controls.
            document.getElementById('rollLeftButton').addEventListener('click', () => {
                rollCamera(ANGLE_STEP);
            });
            document.getElementById('rollRightButton').addEventListener('click', () => {
                rollCamera(-ANGLE_STEP);
            });

            // Reset camera - you might already have a reset function
            document.getElementById('resetCameraButton').addEventListener('click', () => {
                resetCameraView(true); // assuming you have a resetCameraView function
                controls.update();
            });

            // Toggle Manual Fly Mode using the new switch
            const toggleManualFly = document.getElementById("toggleManualFly");
            toggleManualFly.addEventListener("change", function () {
                // When manual fly is on, disable OrbitControls
                manualFlyMode = this.checked;
                controls.enabled = !this.checked;
                console.log("Manual Fly Mode:", manualFlyMode ? "ON" : "OFF");
            });

            // --- End Fly‚ÄìThrough Feature ---

            // Toggle Auto Rotate using the new switch
            const toggleAutoRotate = document.getElementById("toggleAutoRotate");
            toggleAutoRotate.addEventListener("change", function () {
                controls.autoRotate = this.checked;
                console.log("Auto Rotate:", controls.autoRotate ? "ON" : "OFF");
            });


            // --- NEW: Event Listener for Stylized Neuron Toggle ---
            const toggleStylizedSwitch = document.getElementById("toggleStylizedNeurons");
            toggleStylizedSwitch.addEventListener("change", function () {
                showStylizedNeuronsEnabled = this.checked;
                console.log("Show Stylized Neurons Enabled:", showStylizedNeuronsEnabled);

                if (showStylizedNeuronsEnabled) {
                    // --- User turned the switch ON ---
                    // Iterate through existing region info and create neurons for regions
                    // that are currently marked as visible (checkbox checked) but don't have neurons yet.
                    console.log("Master switch ON: Checking visible regions to create neurons...");
                    regionInfoList.forEach(info => {
                        if (info && info.visible && (!stylizedNeuronsByRegion[info.id] || stylizedNeuronsByRegion[info.id].length === 0)) {
                            console.log(` -> Creating neurons for already visible region ${info.id}`);
                            createStylizedNeuronsForRegion(info.id, info);
                        }
                    });
                    // Make sure point cloud is potentially updated if regions were hidden before
                    updateFilteredPoints();

                } else {
                    // --- User turned the switch OFF ---
                    // Remove ALL existing stylized neurons immediately
                    console.log("Master switch OFF: Removing all stylized neurons...");
                    Object.keys(stylizedNeuronsByRegion).forEach(regionId => {
                        // Need to parse regionId back to number if keys are strings
                        removeStylizedNeuronsForRegion(parseInt(regionId, 10));
                    });
                    // Point cloud visibility remains controlled by info.visible
                }
            });

            // Toggle Grayscale Mode
            const toggleGrayscale = document.getElementById("toggleGrayscale");
            toggleGrayscale.addEventListener("change", function () {
                guiParams.useGrayscale = this.checked;
                if (pointMaterial && pointMaterial.userData.shader) {
                    pointMaterial.userData.shader.uniforms.useGrayscale.value = this.checked;
                }
                console.log("Grayscale Mode:", this.checked ? "ON" : "OFF");
            });

            // --- White Background Mode ---
            const toggleBackground = document.getElementById("toggleBackground");
            toggleBackground.addEventListener("change", function () {
                updateUIMode(this.checked);
            });

            function updateUIMode(isWhiteMode) {
                if (isWhiteMode) {
                    // --- White Mode Activated ---
                    scene.background = new THREE.Color(0xffffff);
                    document.body.classList.add('white-background-mode');

                    // Disable the bloom effect to remove the glow
                    if (bloomPass) {
                        bloomPass.enabled = false;
                    }

                    // Reduce lighting intensity to prevent a washed-out look
                    ambientLight.intensity = 0.7; // Lower ambient light
                    pointLight.intensity = 0.5;
                    dirLight.intensity = 0.3;


                    // Change reference plane colors to be darker and more opaque
                    if (referencePlanes) {
                        referencePlanes.children[0].material.color.set(0xcc0000); // Sagittal - darker red
                        referencePlanes.children[1].material.color.set(0x00cc00); // Coronal - darker green
                        referencePlanes.children[2].material.color.set(0x0000cc); // Axial - darker blue
                        referencePlanes.children.forEach(p => p.material.opacity = 0.25);
                    }
                } else {
                    // --- Dark Mode Activated (Default) ---
                    scene.background = new THREE.Color(0x111111);
                    document.body.classList.remove('white-background-mode');

                    // Re-enable the bloom effect
                    if (bloomPass) {
                        bloomPass.enabled = true;
                    }

                    // Restore original lighting intensity using the constants
                    ambientLight.intensity = AMBIENT_LIGHT_INTENSITY;
                    pointLight.intensity = POINT_LIGHT_INTENSITY;
                    dirLight.intensity = DIR_LIGHT_INTENSITY;

                    // Revert reference plane colors and opacity
                    if (referencePlanes) {
                        referencePlanes.children[0].material.color.set(0xff0000);
                        referencePlanes.children[1].material.color.set(0x00ff00);
                        referencePlanes.children[2].material.color.set(0x0000ff);
                        referencePlanes.children.forEach(p => p.material.opacity = 0.15);
                    }
                }
            }



            // Get reference to the download button
            const downloadPngBtn = document.getElementById('downloadPngBtn');

            downloadPngBtn.addEventListener('click', () => {
                captureAndDownload();
            });

            function captureAndDownload() {

                // Make sure the scene is rendered immediately
                renderer.render(scene, camera);

                // Capture the canvas image as a PNG data URL.
                const dataURL = renderer.domElement.toDataURL('image/png');

                // Create a temporary <a> element with a download attribute.
                const link = document.createElement('a');
                link.href = dataURL;
                link.download = 'screenshot.png';

                // Trigger the download.
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                console.log("Screenshot captured and downloaded.");
            }

            // Get references to the sidebar and the toggle button
            const leftSidebar = document.getElementById('leftSidebar');
            const toggleSidebarButton = document.getElementById('toggleSidebarButton');

            // Toggle function: add/remove the "hidden" class
            toggleSidebarButton.addEventListener('click', () => {
                leftSidebar.classList.toggle('hidden');
                toggleSidebarButton.classList.toggle('hidden');

                // Change the arrow icon for the toggle button:
                if (leftSidebar.classList.contains('hidden')) {
                    // When hidden, show a right arrow (pointing to the right to indicate "expand")
                    toggleSidebarButton.innerHTML = "&#9654;";
                } else {
                    // When visible, show a left arrow (pointing to the left to indicate "collapse")
                    toggleSidebarButton.innerHTML = "&#9664;";
                }
            });

            // --- Save the Default Settings for a ‚ÄúRestore Defaults‚Äù ---
            const defaultGuiParams = JSON.parse(JSON.stringify(guiParams));

            // Save the processed CSV data, region info, GUI parameters and camera state to localStorage.
            function saveState() {
                try {
                    // Only cache if the array length is within your acceptable threshold.
                    if (finalPositions && finalPositions.length < 1e6) {
                        const positionsString = JSON.stringify(Array.from(finalPositions));
                        const compressedPositions = LZString.compress(positionsString);
                        localStorage.setItem("cachedPositions", compressedPositions);

                        const colorsString = JSON.stringify(Array.from(finalColors));
                        const compressedColors = LZString.compress(colorsString);
                        localStorage.setItem("cachedColors", compressedColors);

                        localStorage.setItem("cachedPointIDs", JSON.stringify(Array.from(finalPointRegionIDs)));

                        const intensitiesString = JSON.stringify(Array.from(finalIntensities));
                        const compressedIntensities = LZString.compress(intensitiesString);
                        localStorage.setItem("cachedIntensities", compressedIntensities);

                        localStorage.setItem("cachedRegionInfo", JSON.stringify(regionInfoList));
                    } else {
                        console.warn("Geometry data too large to cache in localStorage; skipping caching.");
                    }

                    localStorage.setItem("guiParams", JSON.stringify(guiParams));

                    const camState = {
                        position: camera.position.toArray(),
                        target: controls.target.toArray()
                    };
                    localStorage.setItem("cameraState", JSON.stringify(camState));

                    console.log("State saved to cache.");
                } catch (e) {
                    console.error("Error saving state: ", e);
                }
            }
            // Restore state from localStorage (if cached data exists).
            function restoreState() {
                try {
                    const cachedPositions = localStorage.getItem("cachedPositions");
                    if (cachedPositions) {
                        const decompressedPositions = LZString.decompress(cachedPositions);
                        finalPositions = new Float32Array(JSON.parse(decompressedPositions));

                        const cachedColors = localStorage.getItem("cachedColors");
                        const decompressedColors = LZString.decompress(cachedColors);
                        finalColors = new Uint8Array(JSON.parse(decompressedColors));

                        finalPointRegionIDs = new Uint32Array(JSON.parse(localStorage.getItem("cachedPointIDs")));

                        const cachedIntensities = localStorage.getItem("cachedIntensities");
                        const decompressedIntensities = LZString.decompress(cachedIntensities);
                        finalIntensities = new Float32Array(JSON.parse(decompressedIntensities));

                        regionInfoList = JSON.parse(localStorage.getItem("cachedRegionInfo"));

                        // Rebuild scene from cache.
                        buildFinalVisualizationFromCache();

                        const savedGuiParams = localStorage.getItem("guiParams");
                        if (savedGuiParams) {
                            const loadedSettings = JSON.parse(savedGuiParams);
                            Object.keys(loadedSettings).forEach(key => { guiParams[key] = loadedSettings[key]; });
                            gui.updateDisplay();
                        }

                        const camStateStr = localStorage.getItem("cameraState");
                        if (camStateStr) {
                            const camState = JSON.parse(camStateStr);
                            camera.position.fromArray(camState.position);
                            controls.target.fromArray(camState.target);
                            camera.lookAt(controls.target);
                            controls.update();
                        }

                        console.log("State restored from cache.");
                    }
                } catch (e) {
                    console.error("Error restoring state:", e);
                }
            }

            // Build your final THREE.js geometry from the cached arrays.
            function buildFinalVisualizationFromCache() {
                try {
                    // Dispose previous objects if any.
                    if (points) { brainGroup.remove(points); points = null; }
                    if (geometry) { geometry.dispose(); geometry = null; }
                    if (pointMaterial) { pointMaterial.dispose(); pointMaterial = null; }

                    geometry = new THREE.BufferGeometry();
                    geometry.setAttribute("position", new THREE.BufferAttribute(finalPositions, 3));
                    geometry.setAttribute("color", new THREE.BufferAttribute(finalColors, 3, true));
                    geometry.setAttribute("intensity", new THREE.BufferAttribute(finalIntensities, 1));

                    const numPoints = finalPointRegionIDs.length;
                    const initialIndices = new Uint32Array(numPoints);
                    for (let i = 0; i < numPoints; i++) { initialIndices[i] = i; }
                    geometry.setIndex(new THREE.BufferAttribute(initialIndices, 1));

                    // Compute bounding data if needed.
                    geometry.computeBoundingBox();
                    geometry.computeBoundingSphere();

                    pointMaterial = new THREE.PointsMaterial({
                        vertexColors: true,
                        size: guiParams.pointSize,
                        map: neuronTexture,
                        transparent: true,
                        opacity: guiParams.opacity,
                        alphaTest: 0.05,
                        depthTest: true,
                        depthWrite: false,
                        sizeAttenuation: true
                    });

                    points = new THREE.Points(geometry, pointMaterial);
                    points.frustumCulled = true;
                    brainGroup.add(points);

                    // Update any scene filters and camera view.
                    updateFilteredPoints();
                    resetCameraView(true);
                } catch (error) {
                    console.error("Error rebuilding visualization from cache:", error);
                }
            }

            // Keyframe Animation functions
            function captureKeyframe() {
                const keyframe = {
                    position: camera.position.clone(),
                    target: controls.target.clone()
                };
                keyframes.push(keyframe);
                console.log("Keyframe captured:", keyframe);
            }
            document.getElementById("captureKeyframe").addEventListener("click", captureKeyframe);

            function animateKeyframes(durationPerSegment = 2000, onComplete) {
                if (keyframes.length < 2) { console.warn("At least 2 keyframes needed."); return; }
                let currentKey = 0;
                function nextSegment() {
                    if (currentKey >= keyframes.length - 1) { if (onComplete) onComplete(); return; }
                    const startKF = keyframes[currentKey];
                    const endKF = keyframes[currentKey + 1];
                    const startTime = performance.now();
                    function animateSegment(now) {
                        const t = Math.min((now - startTime) / durationPerSegment, 1);
                        camera.position.lerpVectors(startKF.position, endKF.position, t);
                        controls.target.lerpVectors(startKF.target, endKF.target, t);
                        controls.update();
                        if (t < 1) requestAnimationFrame(animateSegment);
                        else { currentKey++; nextSegment(); }
                    }
                    requestAnimationFrame(animateSegment);
                }
                nextSegment();
            }
            document.getElementById("startAnimation").addEventListener("click", () => {
                startRecording();
                animateKeyframes(3000, stopRecording);
            });

            // Zoom In/Out functions
            function zoomIn() {
                const direction = new THREE.Vector3();
                direction.subVectors(controls.target, camera.position).normalize();
                camera.position.add(direction.multiplyScalar(100));
                controls.update();
            }
            function zoomOut() {
                const direction = new THREE.Vector3();
                direction.subVectors(controls.target, camera.position).normalize();
                camera.position.add(direction.multiplyScalar(-100));
                controls.update();
            }
            document.getElementById("zoomIn").addEventListener("click", zoomIn);
            document.getElementById("zoomOut").addEventListener("click", zoomOut);

            // Manual Fly Mode update using the single flyClock declared earlier
            function updateFlyMode() {
                if (!manualFlyMode) return;
                const delta = flyClock.getDelta();
                const forward = new THREE.Vector3();
                camera.getWorldDirection(forward).normalize();
                const right = new THREE.Vector3();
                right.crossVectors(forward, camera.up).normalize();
                const up = new THREE.Vector3(0, 1, 0);
                const moveVector = new THREE.Vector3();
                if (flyKeys.W) moveVector.add(forward);
                if (flyKeys.S) moveVector.sub(forward);
                if (flyKeys.A) moveVector.sub(right);
                if (flyKeys.D) moveVector.add(right);
                if (flyKeys.Q) moveVector.add(up);
                if (flyKeys.E) moveVector.sub(up);
                if (moveVector.length() > 0) {
                    moveVector.normalize().multiplyScalar(flySpeed * delta);
                    camera.position.add(moveVector);
                    controls.target.add(moveVector);
                }
            }

            // Set up keyboard event listeners for manual fly mode are already defined above

            // Recording functions with download link
            function startRecording() {
                const stream = renderer.domElement.captureStream(30);
                mediaRecorder = new MediaRecorder(stream, { mimeType: "video/webm; codecs=vp9" });
                recordedChunks = [];
                mediaRecorder.ondataavailable = function (event) {
                    if (event.data && event.data.size > 0) recordedChunks.push(event.data);
                };
                mediaRecorder.onstop = function () {
                    const blob = new Blob(recordedChunks, { type: "video/webm" });
                    const url = URL.createObjectURL(blob);
                    downloadContainer.innerHTML = "";
                    const downloadLink = document.createElement("a");
                    downloadLink.href = url;
                    downloadLink.download = "mouse_brain_movie.webm";
                    downloadLink.textContent = "Download Recorded Movie";
                    downloadContainer.appendChild(downloadLink);
                    document.getElementById("startRecording").disabled = false;
                    document.getElementById("startRecording").textContent = "Start Recording";
                    document.getElementById("stopRecording").disabled = true;
                    recordingIndicator.style.display = "none";
                    console.log("Recording stopped and ready for download.");
                };
                mediaRecorder.start();
                document.getElementById("startRecording").disabled = true;
                document.getElementById("startRecording").textContent = "Recording...";
                document.getElementById("stopRecording").disabled = false;
                recordingIndicator.style.display = "block";
                console.log("Recording started");
            }
            function stopRecording() {
                if (mediaRecorder && mediaRecorder.state !== "inactive") {
                    mediaRecorder.stop();
                    document.getElementById("startRecording").disabled = false;
                    document.getElementById("stopRecording").disabled = true;
                    console.log("Recording stopped");
                }
            }
            document.getElementById("startRecording").addEventListener("click", startRecording);
            document.getElementById("stopRecording").addEventListener("click", stopRecording);

            // Region Filtering GUI functions (reuse same checkbox for visibility & fly‚Äìthrough)
            let regionFilterSubFolder = null, regionFilterContainer = null;
            function setupRegionFilterGUI() {
                if (!regionFilterSubFolder) {
                    regionFilterSubFolder = filterFolder.addFolder("Regions");
                    regionFilterContainer = document.createElement("div");
                    regionFilterContainer.className = "region-filter-container";
                    regionFilterSubFolder.domElement.appendChild(regionFilterContainer);
                    regionFilterSubFolder.open();
                }
                filterAndRebuildRegionGUI();
            }

            function filterAndRebuildRegionGUI() {
                if (!regionFilterContainer) return; // Exit if the container div doesn't exist
                regionFilterContainer.innerHTML = ""; // Clear previous filter UI

                // Get search term and decide which regions to show in the list
                const searchTerm = guiParams.regionSearch.toLowerCase().trim();
                let regionsToShow = [];
                if (pinnedRegionIDsForDisplay !== null) {
                    // Show only the pinned snapshot set, optionally filtered by search
                    regionsToShow = regionInfoList
                        .filter(info => info && pinnedRegionIDsForDisplay.has(info.id))
                        .filter(info => (searchTerm === "" || info.lowerAcronym.includes(searchTerm) || info.lowerFullName.includes(searchTerm)))
                        .sort((a, b) => a.lowerAcronym.localeCompare(b.lowerAcronym));
                } else {
                    // Normal searchable list (no snapshot)
                    regionsToShow = regionInfoList
                        .filter(info => info && (searchTerm === "" || info.lowerAcronym.includes(searchTerm) || info.lowerFullName.includes(searchTerm)))
                        .sort((a, b) => a.lowerAcronym.localeCompare(b.lowerAcronym));
                }

                // Handle cases where no data is loaded or no regions match
                if (regionInfoList.filter(Boolean).length === 0) {
                    regionFilterContainer.innerHTML = "<i>Load data first</i>";
                    return;
                }
                if (regionsToShow.length === 0) {
                    const msg = (pinnedRegionIDsForDisplay !== null) ? "No regions are checked" : "No regions match search";
                    regionFilterContainer.innerHTML = `<i>${msg}</i>`;
                    return;
                }

                // Build the UI rows for filtered regions
                const fragment = document.createDocumentFragment();
                regionsToShow.forEach(info => {
                    const row = document.createElement("div");
                    row.className = "region-filter-row";

                    // Color square (with color picker input)
                    const colorBox = document.createElement("div");
                    colorBox.className = "region-filter-colorbox";
                    colorBox.style.backgroundColor = info.colorHex;
                    const colorInput = document.createElement("input");
                    colorInput.type = "color";
                    colorInput.value = info.colorHex;
                    colorInput.addEventListener("input", function () {
                        clearTimeout(colorInput.debounceTimer);
                        colorInput.debounceTimer = setTimeout(() => {
                            const newColorHex = colorInput.value;
                            info.colorHex = newColorHex;
                            const tempColor = new THREE.Color(newColorHex);
                            info.r = Math.floor(tempColor.r * 255);
                            info.g = Math.floor(tempColor.g * 255);
                            info.b = Math.floor(tempColor.b * 255);
                            colorBox.style.backgroundColor = newColorHex;
                            updateRegionColor(info.id, newColorHex); // Update point cloud colors
                            // Also update stylized neuron colors if they exist
                            if (stylizedNeuronsByRegion[info.id]) {
                                stylizedNeuronsByRegion[info.id].forEach(neuron => {
                                    neuron.color.set(newColorHex);
                                    // Update derived colors if necessary (or have neuron do it internally)
                                    neuron.dendriteColor = neuron.color.clone().lerp(new THREE.Color(0xaaaaaa), 0.3);
                                    if (neuron.somaMesh) neuron.somaMesh.material.color.copy(neuron.color);
                                });
                            }
                        }, 100);
                    });
                    colorBox.appendChild(colorInput);
                    colorBox.addEventListener("click", () => colorInput.click());

                    // Text span for region name
                    const textSpan = document.createElement("span");
                    textSpan.className = "region-filter-text";
                    const displayName = `${info.acronym} (${info.fullName || "N/A"})`;
                    textSpan.textContent = displayName;
                    textSpan.title = displayName; // Tooltip for full name

                    // Checkbox for points visibility AND conditional stylized neuron toggle
                    const visCheckbox = document.createElement("input");
                    visCheckbox.type = "checkbox";
                    visCheckbox.checked = info.visible;
                    visCheckbox.className = "region-filter-checkbox";
                    visCheckbox.title = "Toggle Points / Stylized Neurons (if master enabled)"; // Updated title

                    visCheckbox.addEventListener("change", function () {
                        const isChecked = visCheckbox.checked;
                        info.visible = isChecked; // Always update point visibility state

                        // --- Manage Stylized Neurons ONLY if Master Switch is ON ---
                        if (showStylizedNeuronsEnabled) { // Check the global master flag
                            if (isChecked) {
                                // Checkbox checked AND master switch ON: Create neurons if they don't exist
                                if (!stylizedNeuronsByRegion[info.id] || stylizedNeuronsByRegion[info.id].length === 0) {
                                    console.log(`Region ${info.id} checked & master ON -> Creating stylized neurons`);
                                    createStylizedNeuronsForRegion(info.id, info);
                                } else {
                                    console.log(`Region ${info.id} checked & master ON -> Stylized neurons already exist`);
                                }
                            } else {
                                // Checkbox unchecked (while master switch is ON): Remove neurons
                                console.log(`Region ${info.id} unchecked & master ON -> Removing stylized neurons`);
                                removeStylizedNeuronsForRegion(info.id);
                            }
                        } else {
                            console.log(`Region ${info.id} visibility changed, but master stylized switch is OFF.`);
                            // Ensure neurons are removed if checkbox is unchecked, even if master is off (consistency)
                            if (!isChecked && stylizedNeuronsByRegion[info.id]) {
                                console.log(`   -> Removing stylized neurons for region ${info.id} as it was unchecked.`);
                                removeStylizedNeuronsForRegion(info.id);
                            }
                        }
                        // --- End Conditional Logic ---

                        // Update point cloud visibility (debounced)
                        clearTimeout(visCheckbox.debounceTimer);
                        visCheckbox.debounceTimer = setTimeout(updateFilteredPoints, 50);
                        // Do not auto-rebuild the list when using snapshot mode; user can click
                        // "Show Checked Regions" again to refresh the snapshot.
                    });

                    // Append elements to the row
                    row.appendChild(colorBox);
                    row.appendChild(textSpan);
                    row.appendChild(visCheckbox);
                    fragment.appendChild(row); // Add the completed row to the document fragment
                });

                // Add the fragment containing all rows to the DOM container
                regionFilterContainer.appendChild(fragment);

                // Adjust GUI folder height (if needed)
                if (regionFilterSubFolder && regionFilterSubFolder.__ul) {
                    regionFilterSubFolder.__ul.style.height = "auto";
                }

                // --- Re-initialization/Cleanup logic after filtering ---
                // This runs after the UI is rebuilt based on the search term
                // It ensures consistency between the visible checkboxes and the active stylized neurons.
                regionInfoList.forEach(info => { // Iterate through ALL region infos
                    if (!info) return; // Skip empty slots

                    const isRegionVisibleInFilter = regionsToShow.some(r => r.id === info.id);

                    if (showStylizedNeuronsEnabled) {
                        // Master switch is ON
                        if (isRegionVisibleInFilter && info.visible && (!stylizedNeuronsByRegion[info.id] || stylizedNeuronsByRegion[info.id].length === 0)) {
                            // Region is shown in the filter, its checkbox is checked, BUT no neurons exist -> Create them
                            console.log(`Re-initializing stylized neurons for visible region ${info.id} after filter (Master ON).`);
                            createStylizedNeuronsForRegion(info.id, info);
                        } else if ((!isRegionVisibleInFilter || !info.visible) && stylizedNeuronsByRegion[info.id]) {
                            // Region is NOT shown in filter OR its checkbox is unchecked, BUT neurons exist -> Remove them
                            console.log(`Removing stylized neurons for region ${info.id} because it was filtered out or unchecked (Master ON).`);
                            removeStylizedNeuronsForRegion(info.id);
                        }
                    } else {
                        // Master switch is OFF
                        if (stylizedNeuronsByRegion[info.id]) {
                            // Neurons exist but master is OFF -> Remove them (Safety check)
                            console.warn(`Safety check: Removing stylized neurons for region ${info.id} because master switch is OFF.`);
                            removeStylizedNeuronsForRegion(info.id);
                        }
                    }
                });

            } // End filterAndRebuildRegionGUI

            function toggleAllRegions(select) {
                let changed = false;
                regionInfoList.forEach(info => {
                    if (info && info.visible !== select) {
                        info.visible = select;
                        info.selectedForFlight = select;
                        changed = true;
                    }
                });
                if (changed) { filterAndRebuildRegionGUI(); updateFilteredPoints(); }
            }

            // --- Create Stylized Neurons for a Region ---
            function createStylizedNeuronsForRegion(regionId, regionInfo) {
                if (!showStylizedNeuronsEnabled) {
                    console.log(`Skipping stylized neuron creation for region ${regionId}: Master switch is OFF.`);
                    return;
                }
                if (!finalPositions || !finalPointRegionIDs) {
                    console.warn("Cannot create stylized neurons: Point data not loaded.");
                    return;
                }
                if (stylizedNeuronsByRegion[regionId]) {
                    console.warn("Stylized neurons already exist for region", regionId);
                    return; // Avoid duplicates
                }

                const regionColor = new THREE.Color(regionInfo.colorHex);
                const neuronIndicesInRegion = [];
                const numTotalPoints = finalPointRegionIDs.length;

                // Find indices of all points belonging to this region
                for (let i = 0; i < numTotalPoints; i++) {
                    if (finalPointRegionIDs[i] === regionId) {
                        neuronIndicesInRegion.push(i);
                    }
                }

                if (neuronIndicesInRegion.length === 0) {
                    console.log("No points found for region", regionId);
                    return;
                }

                // Sample indices if needed
                const maxToShow = guiParams.maxStylizedNeuronsPerRegion; // Use GUI param
                const indicesToShow = [];
                if (neuronIndicesInRegion.length <= maxToShow || maxToShow <= 0) {
                    indicesToShow.push(...neuronIndicesInRegion); // Show all
                } else {
                    // Simple random sampling
                    const shuffled = neuronIndicesInRegion.sort(() => 0.5 - Math.random());
                    indicesToShow.push(...shuffled.slice(0, maxToShow));
                    console.log(`Sampling ${maxToShow} stylized neurons from ${neuronIndicesInRegion.length} in region ${regionId}`);
                }

                const createdNeurons = [];
                indicesToShow.forEach(originalIndex => {
                    const pos = new THREE.Vector3(
                        finalPositions[originalIndex * 3],
                        finalPositions[originalIndex * 3 + 1],
                        finalPositions[originalIndex * 3 + 2]
                    );
                    // Pass originalIndex for potential future linking
                    const neuron = new StylizedNeuron(pos, regionColor, originalIndex);
                    neuron.updateSomaScale(guiParams.pointSize); // Pass current point size
                    scene.add(neuron.group); // Add the neuron's group to the scene
                    createdNeurons.push(neuron);
                    activeStylizedNeurons.push(neuron); // Add to global list for updates
                });

                stylizedNeuronsByRegion[regionId] = createdNeurons; // Store the created neurons
                console.log(`Added ${createdNeurons.length} stylized neurons for region ${regionId}`);
            }

            // Remove Stylized Neurons for a Region ---
            function removeStylizedNeuronsForRegion(regionId) {
                const neuronsToRemove = stylizedNeuronsByRegion[regionId];
                if (neuronsToRemove && neuronsToRemove.length > 0) {
                    neuronsToRemove.forEach(neuron => {
                        scene.remove(neuron.group); // Remove from scene
                        neuron.dispose(); // Dispose THREE resources
                        // Remove from the active list
                        const indexInActive = activeStylizedNeurons.indexOf(neuron);
                        if (indexInActive > -1) {
                            activeStylizedNeurons.splice(indexInActive, 1);
                        }
                    });
                    console.log(`Removed ${neuronsToRemove.length} stylized neurons for region ${regionId}`);
                }
                delete stylizedNeuronsByRegion[regionId]; // Remove entry
            }

            // Point Texture Generation
            function generateNeuronTexture() {
                const size = 64;
                const canvas = document.createElement("canvas");
                canvas.width = size;
                canvas.height = size;
                const context = canvas.getContext("2d");
                const center = size / 2;
                const radius = size / 2;
                const gradient = context.createRadialGradient(center, center, 0, center, center, radius);
                gradient.addColorStop(0, "rgba(255,255,255,1)");
                gradient.addColorStop(0.2, "rgba(240,240,240,0.9)");
                gradient.addColorStop(0.5, "rgba(200,200,200,0.6)");
                gradient.addColorStop(1, "rgba(0,0,0,0)");
                context.fillStyle = gradient;
                context.beginPath();
                context.arc(center, center, radius, 0, Math.PI * 2);
                context.fill();
                return new THREE.CanvasTexture(canvas);
            }
            const neuronTexture = generateNeuronTexture();

            // Reset & Cleanup functions
            function resetBatchState() {
                accumulatedPositions = [];
                accumulatedColors = [];
                accumulatedPointRegionIDs = [];
                accumulatedIntensities = [];
                expectedTotalPoints = 0;
                receivedPoints = 0;
                isProcessingComplete = false;
                regionInfoList = [];
                finalPositions = null;
                finalColors = null;
                finalPointRegionIDs = null;
                finalIntensities = null;
            }

            function cleanupPreviousData() {
                console.log("Cleaning up previous data and simulation state...");
                resetBatchState(); // Clear batch accumulation arrays
                if (dataWorker) { dataWorker.terminate(); dataWorker = null; } // Terminate worker if running

                // --- Stop and dispose simulation FIRST ---
                console.log("Disposing simulation manager...");
                simulationManager.dispose(); // Calls stop internally and resets flags
                console.log("Disposing simulation visuals...");
                simulationVisuals.dispose(); // Removes markers, connections etc.

                // Stop continuous spiker if active
                if (continuousSpiker.isActive) {
                    console.log("Stopping continuous spiker...");
                    continuousSpiker.stop();
                    // Ensure toggle reflects state
                    const toggle = document.getElementById("toggleContinuousSpiking");
                    if (toggle) toggle.checked = false;
                }

                // --- Clear Scene Objects ---
                if (points) {
                    console.log("Removing points object...");
                    brainGroup.remove(points);
                    // Geometry and material are disposed below
                    points = null;
                }
                if (geometry) {
                    console.log("Disposing geometry...");
                    geometry.dispose();
                    geometry = null;
                }
                if (pointMaterial) {
                    console.log("Disposing point material...");
                    // Shader resources are managed by Three.js disposal
                    pointMaterial.dispose();
                    pointMaterial = null;
                }
                if (referencePlanes) {
                    console.log("Removing reference planes...");
                    brainGroup.remove(referencePlanes);
                    referencePlanes.children.forEach(p => {
                        if (p.geometry) p.geometry.dispose();
                        if (p.material) p.material.dispose();
                    });
                    referencePlanes = null;
                    planesVisible = false; // Reset visibility flag
                    // --- Remove ALL Stylized Neurons ---
                    console.log("Removing all stylized neurons...");
                    Object.keys(stylizedNeuronsByRegion).forEach(regionId => {
                        removeStylizedNeuronsForRegion(parseInt(regionId, 10));
                    });
                    activeStylizedNeurons = [];
                    stylizedNeuronsByRegion = {};
                    showStylizedNeuronsEnabled = false; // <<< RESET THE MASTER FLAG HERE
                    const toggleStylizedSwitch = document.getElementById("toggleStylizedNeurons");
                    if (toggleStylizedSwitch) {
                        toggleStylizedSwitch.checked = false; // Reset UI toggle
                    }
                    console.log("Stylized neuron cleanup complete and master flag reset.");
                }

                // --- Reset State Variables ---
                currentVisibleIndices = null;
                dataBounds = { center: new THREE.Vector3(), size: 1000, min: new THREE.Vector3(), max: new THREE.Vector3() };
                finalPositions = null; finalColors = null; finalPointRegionIDs = null; finalIntensities = null;

                // --- Reset UI ---
                if (regionFilterContainer) { regionFilterContainer.innerHTML = "<i>Load data first</i>"; }
                guiParams.regionSearch = ""; // Clear search
                gui.updateDisplay(); // Update GUI display for search

                // Reset brain group transforms
                brainGroup.scale.set(1, 1, 1);
                brainGroup.position.set(0, 0, 0);
                brainGroup.rotation.set(0, 0, 0);

                // Ensure simulation flags in params object are reset
                simulationParams.running = false;
                simulationParams.isInitialized = false;
                if (runningController) runningController.updateDisplay();

                // Reset keyframes
                keyframes = [];

                // Reset UI toggles to default state (if needed)
                const toggleManualFly = document.getElementById("toggleManualFly");
                if (toggleManualFly) toggleManualFly.checked = false; manualFlyMode = false; controls.enabled = true;
                const toggleAutoRotate = document.getElementById("toggleAutoRotate");
                if (toggleAutoRotate) toggleAutoRotate.checked = false; controls.autoRotate = false;
                const toggleGrayscale = document.getElementById("toggleGrayscale");
                // Reset grayscale toggle if needed (or rely on guiParams reset later)
                if (toggleGrayscale && !guiParams.useGrayscale) toggleGrayscale.checked = false;


                // Clear any existing download links for recordings
                if (downloadContainer) downloadContainer.innerHTML = "";

                console.log("Cleanup complete.");
            }

            // Material and Region Updates
            function updateMaterial() {
                if (pointMaterial) {
                    pointMaterial.size = guiParams.pointSize;
                    pointMaterial.opacity = guiParams.opacity;
                    pointMaterial.needsUpdate = true;
                }
            }

            function updateFilteredPoints() {
                if (!geometry || !finalPointRegionIDs || regionInfoList.length === 0) {
                    if (geometry) {
                        geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(0), 1));
                        geometry.setDrawRange(0, 0);
                    }
                    return;
                }
                const numPoints = finalPointRegionIDs.length;
                const visibleIndicesList = [];
                for (let i = 0; i < numPoints; i++) {
                    const regionID = finalPointRegionIDs[i];
                    if (regionInfoList[regionID] && (regionInfoList[regionID].visible === undefined || regionInfoList[regionID].visible === true)) {
                        visibleIndicesList.push(i);
                    }
                }
                if (visibleIndicesList.length === 0) {
                    currentVisibleIndices = new Uint32Array(0);
                    geometry.setIndex(new THREE.BufferAttribute(currentVisibleIndices, 1));
                    geometry.setDrawRange(0, 0);
                } else {
                    currentVisibleIndices = new Uint32Array(visibleIndicesList);
                    geometry.setIndex(new THREE.BufferAttribute(currentVisibleIndices, 1));
                    geometry.index.needsUpdate = true;
                    geometry.setDrawRange(0, currentVisibleIndices.length);
                }
            }

            function updateRegionColor(regionID, newColorHex) {
                if (!geometry || !geometry.attributes.color || !finalPointRegionIDs || !regionInfoList[regionID]) return;
                const colorAttribute = geometry.attributes.color;
                const numPoints = finalPointRegionIDs.length;
                const regionInfo = regionInfoList[regionID];
                const rByte = regionInfo.r, gByte = regionInfo.g, bByte = regionInfo.b;
                for (let i = 0; i < numPoints; i++) {
                    if (finalPointRegionIDs[i] === regionID) {
                        colorAttribute.array[i * 3 + 0] = rByte;
                        colorAttribute.array[i * 3 + 1] = gByte;
                        colorAttribute.array[i * 3 + 2] = bByte;
                    }
                }
                colorAttribute.needsUpdate = true;
            }

            // Reference Planes
            function buildReferencePlanes() {
                if (referencePlanes) {
                    brainGroup.remove(referencePlanes);
                    referencePlanes.children.forEach(p => {
                        if (p.geometry) p.geometry.dispose();
                        if (p.material) p.material.dispose();
                    });
                    referencePlanes = null;
                }
                const center = dataBounds.center;
                const size = dataBounds.size > 0 ? dataBounds.size : 1000;
                const planeSize = size * 1.5;
                referencePlanes = new THREE.Group();
                const sagGeo = new THREE.PlaneGeometry(planeSize, planeSize);
                const isWhiteMode = document.body.classList.contains('white-background-mode');
                const sagMat = new THREE.MeshBasicMaterial({ color: isWhiteMode ? 0xcc0000 : 0xff0000, transparent: true, opacity: isWhiteMode ? 0.25 : 0.15, side: THREE.DoubleSide, depthWrite: false });
                const sagittal = new THREE.Mesh(sagGeo, sagMat);
                sagittal.rotation.y = Math.PI / 2;
                sagittal.position.copy(center);
                const corGeo = new THREE.PlaneGeometry(planeSize, planeSize);
                const corMat = new THREE.MeshBasicMaterial({ color: isWhiteMode ? 0x00cc00 : 0x00ff00, transparent: true, opacity: isWhiteMode ? 0.25 : 0.15, side: THREE.DoubleSide, depthWrite: false });
                const coronal = new THREE.Mesh(corGeo, corMat);
                coronal.rotation.x = Math.PI / 2;
                coronal.position.copy(center);
                const axiGeo = new THREE.PlaneGeometry(planeSize, planeSize);
                const axiMat = new THREE.MeshBasicMaterial({ color: isWhiteMode ? 0x0000cc : 0x0000ff, transparent: true, opacity: isWhiteMode ? 0.25 : 0.15, side: THREE.DoubleSide, depthWrite: false });
                const axial = new THREE.Mesh(axiGeo, axiMat);
                axial.position.copy(center);
                referencePlanes.add(sagittal);
                referencePlanes.add(coronal);
                referencePlanes.add(axial);
                referencePlanes.visible = planesVisible;
                brainGroup.add(referencePlanes);
            }

            function toggleReferencePlanes() {
                if (referencePlanes) { planesVisible = !planesVisible; referencePlanes.visible = planesVisible; }
            }

            // Camera Controls
            function getBoundsCenterAndSize() { return { center: dataBounds.center, size: dataBounds.size }; }
            function setCameraView(axis) {
                const b = getBoundsCenterAndSize();
                const distance = b.size > 0 ? b.size * 1.8 : 5000;
                const offset = distance * 0.1;
                controls.target.copy(b.center);
                camera.up.set(0, 1, 0);
                switch (axis) {
                    case "x":
                        camera.position.set(b.center.x + distance, b.center.y + offset, b.center.z + offset);
                        break;
                    case "y":
                        camera.position.set(b.center.x + offset, b.center.y + distance, b.center.z + offset);
                        camera.up.set(0, 0, -1);
                        break;
                    case "z":
                        camera.position.set(b.center.x + offset, b.center.y + offset, b.center.z + distance);
                        break;
                }
                camera.lookAt(b.center);
                controls.update();
            }

            function resetCameraView(resetPosition = true) {
                const b = getBoundsCenterAndSize();
                controls.target.copy(b.center);
                if (resetPosition) {
                    const distance = b.size > 0 ? b.size * 1.8 : 10000;
                    camera.position.set(b.center.x + distance * 0.8, b.center.y + distance * 0.5, b.center.z + distance * 0.8);
                }
                camera.up.set(0, -1, 0);
                camera.lookAt(controls.target);
                controls.update();
            }

            // Raycaster & Tooltips
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            let lastIntersectedIndex = -1;

            function updateRaycasterThreshold() {
                if (raycaster) {
                    const threshold = Math.max(1.0, guiParams.pointSize * RAYCASTER_THRESHOLD_FACTOR);
                    raycaster.params.Points.threshold = threshold;
                }
            }
            updateRaycasterThreshold();

            let mouseMoveTimeout;
            window.addEventListener("mousemove", (event) => {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                const cx = event.clientX, cy = event.clientY;
                clearTimeout(mouseMoveTimeout);
                mouseMoveTimeout = setTimeout(() => {
                    if (selectedTooltip.style.display !== "block") updateHoverTooltip(cx, cy);
                    else hoverTooltip.style.display = "none";
                }, 30);
            }, false);

            function updateHoverTooltip(clientX, clientY) {
                if (!points || !points.visible || !geometry || !geometry.index || geometry.index.count === 0 ||
                    !finalPointRegionIDs || !currentVisibleIndices) {
                    hoverTooltip.style.display = "none";
                    return;
                }
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(points);
                if (intersects.length > 0) {
                    const idx = intersects[0].index;
                    if (idx < currentVisibleIndices.length) {
                        const bufIndex = currentVisibleIndices[idx];
                        if (bufIndex !== undefined && bufIndex < finalPointRegionIDs.length) {
                            const regionID = finalPointRegionIDs[bufIndex];
                            const info = regionInfoList[regionID];
                            if (info && geometry.attributes.position && geometry.attributes.intensity) {
                                const posAttr = geometry.attributes.position;
                                const x = posAttr.getX(bufIndex);
                                const y = posAttr.getY(bufIndex);
                                const z = posAttr.getZ(bufIndex);
                                const rawIntensity = geometry.attributes.intensity.getX(bufIndex);
                                hoverTooltip.innerHTML = "<b>" + info.acronym + "</b> (" + (info.fullName || "N/A") + ")<br>(" +
                                    x.toFixed(1) + ", " + y.toFixed(1) + ", " + z.toFixed(1) + ")<br>Raw Intensity: " +
                                    rawIntensity.toFixed(2);
                                hoverTooltip.style.left = (clientX + 15) + "px";
                                hoverTooltip.style.top = (clientY + 15) + "px";
                                hoverTooltip.style.display = "block";
                                lastIntersectedIndex = bufIndex;
                                return;
                            }
                        }
                    }
                }
                hoverTooltip.style.display = "none";
                lastIntersectedIndex = -1;
            }

            renderer.domElement.addEventListener("click", (event) => {
                if (lastIntersectedIndex !== -1 && geometry && geometry.attributes.position && finalPointRegionIDs && lastIntersectedIndex < finalPointRegionIDs.length) {
                    const regionID = finalPointRegionIDs[lastIntersectedIndex];
                    const info = regionInfoList[regionID];
                    if (info && geometry.attributes.intensity) {
                        const posAttr = geometry.attributes.position;
                        const x = posAttr.getX(lastIntersectedIndex);
                        const y = posAttr.getY(lastIntersectedIndex);
                        const z = posAttr.getZ(lastIntersectedIndex);
                        const rawIntensity = geometry.attributes.intensity.getX(lastIntersectedIndex);
                        selectedTooltipContent.innerHTML = "<b>" + info.acronym + "</b> (" + (info.fullName || "N/A") + ")<br>Coords: (" +
                            x.toFixed(1) + ", " + y.toFixed(1) + ", " + z.toFixed(1) + ")<br>Raw Intensity: " + rawIntensity.toFixed(2);
                        selectedTooltip.style.display = "block";
                        const rect = selectedTooltip.getBoundingClientRect();
                        let left = event.clientX + 15, top = event.clientY + 15;
                        if (left + rect.width > window.innerWidth) left = event.clientX - rect.width - 15;
                        if (top + rect.height > window.innerHeight) top = event.clientY - rect.height - 15;
                        left = Math.max(10, left);
                        top = Math.max(10, top);
                        selectedTooltip.style.left = left + "px";
                        selectedTooltip.style.top = top + "px";
                        hoverTooltip.style.display = "none";
                        return;
                    }
                }
                selectedTooltip.style.display = "none";
            }, false);

            if (selectedTooltipCloseBtn) {
                selectedTooltipCloseBtn.addEventListener("click", (e) => {
                    e.stopPropagation();
                    selectedTooltip.style.display = "none";
                    lastIntersectedIndex = -1;
                });
            }

            // Build Final Visualization Function
            function buildFinalVisualization() {
                console.log("Building final visualization from accumulated batches...");
                if (accumulatedPositions.length === 0 || receivedPoints !== expectedTotalPoints || expectedTotalPoints === 0) {
                    console.error("Data inconsistency or no points. Received: " + receivedPoints + ", Expected: " + expectedTotalPoints);
                    loadingMessage.textContent = "Error assembling data batches.";
                    loadingProgress.style.display = "none";
                    accumulatedPositions = []; accumulatedColors = []; accumulatedPointRegionIDs = []; accumulatedIntensities = [];
                    return;
                }
                console.log("Concatenating " + accumulatedPositions.length + " batches for " + expectedTotalPoints + " points...");
                console.time("ConcatenateBatches");
                finalPositions = new Float32Array(expectedTotalPoints * 3);
                finalColors = new Uint8Array(expectedTotalPoints * 3);
                finalPointRegionIDs = new Uint32Array(expectedTotalPoints);
                finalIntensities = new Float32Array(expectedTotalPoints);
                let currentOffset = 0;
                try {
                    for (let i = 0; i < accumulatedPositions.length; i++) {
                        if (!accumulatedPositions[i] || !accumulatedColors[i] || !accumulatedPointRegionIDs[i] || !accumulatedIntensities[i]) {
                            console.error("Batch " + i + " data is missing or invalid.");
                            continue;
                        }
                        const batchSize = accumulatedPointRegionIDs[i].length;
                        if (currentOffset + batchSize > expectedTotalPoints) {
                            console.error("Batch " + i + " exceeds expected total points. Current offset: " + currentOffset + ", batch size: " + batchSize);
                            break;
                        }
                        finalPositions.set(accumulatedPositions[i], currentOffset * 3);
                        finalColors.set(accumulatedColors[i], currentOffset * 3);
                        finalPointRegionIDs.set(accumulatedPointRegionIDs[i], currentOffset);
                        finalIntensities.set(accumulatedIntensities[i], currentOffset);
                        currentOffset += batchSize;
                    }
                    if (currentOffset !== expectedTotalPoints) {
                        console.warn("Final concatenated offset (" + currentOffset + ") does not match expected total points (" + expectedTotalPoints + ").");
                    }
                } catch (concatError) {
                    console.error("Error during concatenation: " + concatError);
                    loadingMessage.textContent = "Error assembling data.";
                    loadingProgress.style.display = "none";
                    finalPositions = null; finalColors = null; finalPointRegionIDs = null; finalIntensities = null;
                    return;
                }
                console.timeEnd("ConcatenateBatches");
                accumulatedPositions = [];
                accumulatedColors = [];
                accumulatedPointRegionIDs = [];
                accumulatedIntensities = [];
                console.log("Creating THREE geometry...");
                setTimeout(() => {
                    try {
                        if (points) { brainGroup.remove(points); points = null; }
                        if (geometry) { geometry.dispose(); geometry = null; }
                        if (pointMaterial) { pointMaterial.dispose(); pointMaterial = null; }

                        // Stop/dispose simulation FIRST
                        if (simulationManager && simulationManager.params.isInitialized) simulationManager.dispose();
                        if (simulationVisuals && simulationVisuals.isInitialized) simulationVisuals.dispose();

                        geometry = new THREE.BufferGeometry();
                        geometry.setAttribute("position", new THREE.BufferAttribute(finalPositions, 3));
                        geometry.setAttribute("color", new THREE.BufferAttribute(finalColors, 3, true));
                        geometry.setAttribute("intensity", new THREE.BufferAttribute(finalIntensities, 1));
                        const numPoints = expectedTotalPoints;
                        const initialIndices = new Uint32Array(numPoints);
                        for (let i = 0; i < numPoints; i++) { initialIndices[i] = i; }
                        geometry.setIndex(new THREE.BufferAttribute(initialIndices, 1));
                        currentVisibleIndices = initialIndices;
                        geometry.boundingBox = new THREE.Box3(dataBounds.min.clone(), dataBounds.max.clone());
                        geometry.boundingSphere = new THREE.Sphere();
                        geometry.boundingBox.getCenter(geometry.boundingSphere.center);
                        geometry.boundingSphere.radius = geometry.boundingBox.getSize(new THREE.Vector3()).length() / 2;
                        // Compute raw intensity range
                        let computedMinIntensity = Infinity, computedMaxIntensity = -Infinity;
                        for (let i = 0; i < finalIntensities.length; i++) {
                            computedMinIntensity = Math.min(computedMinIntensity, finalIntensities[i]);
                            computedMaxIntensity = Math.max(computedMaxIntensity, finalIntensities[i]);
                        }
                        guiParams.rawIntensityMin = computedMinIntensity;
                        guiParams.rawIntensityMax = computedMaxIntensity;
                        rawMinController.min(computedMinIntensity);
                        rawMinController.max(computedMaxIntensity);
                        rawMinController.setValue(computedMinIntensity);
                        rawMinController.updateDisplay();
                        rawMaxController.min(computedMinIntensity);
                        rawMaxController.max(computedMaxIntensity);
                        rawMaxController.setValue(9000);
                        rawMaxController.updateDisplay();
                        pointMaterial = new THREE.PointsMaterial({
                            vertexColors: true,
                            size: guiParams.pointSize,
                            map: neuronTexture,
                            transparent: true,
                            opacity: guiParams.opacity,
                            alphaTest: 0.05,
                            depthTest: true,
                            depthWrite: false,
                            sizeAttenuation: true
                        });
                        pointMaterial.onBeforeCompile = function (shader) {
                            shader.uniforms.rawMin = { value: guiParams.rawIntensityMin };
                            shader.uniforms.rawMax = { value: guiParams.rawIntensityMax };
                            shader.uniforms.grayContrast = { value: guiParams.grayContrast };
                            shader.uniforms.useGrayscale = { value: guiParams.useGrayscale };

                            // Add new uniforms for blinking effect
                            shader.uniforms.time = { value: 0.0 };
                            shader.uniforms.enableBlink = { value: false }; // false by default; enable it in fly-through

                            // Extend the vertex shader to output the normalized intensity to a varying
                            shader.vertexShader = "attribute float intensity;\n" +
                                "varying float vIntensity;\n" +
                                "uniform float rawMin;\n" +
                                "uniform float rawMax;\n" +
                                shader.vertexShader;
                            shader.vertexShader = shader.vertexShader.replace(
                                "#include <begin_vertex>",
                                "#include <begin_vertex>\n" +
                                "gl_PointSize = gl_PointSize * intensity;\n" +
                                "vIntensity = (intensity - rawMin) / max(rawMax - rawMin, 0.0001);\n"
                            );

                            // Extend the fragment shader by declaring the new uniforms
                            shader.fragmentShader = "varying float vIntensity;\n" +
                                "uniform bool useGrayscale;\n" +
                                "uniform float grayContrast;\n" +
                                "uniform float time;\n" +
                                "uniform bool enableBlink;\n" +
                                shader.fragmentShader;
                            // Replace final color assignment to include blinking effect conditionally
                            shader.fragmentShader = shader.fragmentShader.replace(
                                /gl_FragColor\s*=\s*vec4\s*\(\s*outgoingLight\s*,\s*diffuseColor\.a\s*\)\s*;/,
                                "float blink = enableBlink ? (0.5 + 0.5 * sin(time + vIntensity * 10.0)) : 1.0;\n" +
                                "float contrastValue = clamp((vIntensity - 0.5) * grayContrast + 0.5, 0.0, 1.0);\n" +
                                "gl_FragColor = mix(vec4(outgoingLight, diffuseColor.a), vec4(vec3(contrastValue), diffuseColor.a), (useGrayscale ? 1.0 : 0.0)) * blink;"
                            );
                            pointMaterial.userData.shader = shader;
                        };
                        pointMaterial.needsUpdate = true;
                        points = new THREE.Points(geometry, pointMaterial);
                        points.frustumCulled = true;
                        brainGroup.add(points);
                        console.log("Points created and added to scene.");
                        setupRegionFilterGUI();
                        updateFilteredPoints();
                        resetCameraView(true);
                        buildReferencePlanes();
                        loadingIndicator.style.display = "none";
                        console.log("Data loaded and visualization ready.");
                    } catch (error) {
                        console.error("Error building final visualization: " + error);
                        loadingMessage.textContent = "Error building visualization.";
                        loadingProgress.style.display = "none";
                    }
                }, 50);
                // Save the state after loading
                saveState();
            }

            // Global variable to keep track of our interval timer.
            let continuousSpikeTimer = null;
            // ============================================================
            // Tesla Coil Spike Audio Setup using Web Audio API
            // ============================================================
            function playNeuronSpikeSoundOscillator() {
                // Make sure the AudioContext is created once (reuse it for all calls)
                if (!window.audioCtx) {
                    window.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (window.audioCtx.state === 'suspended') {
                    window.audioCtx.resume();
                }

                // Create an oscillator burst using a short sine wave pulse.
                const oscillator = audioCtx.createOscillator();
                oscillator.type = 'sine'; // You can try 'triangle' or 'square' as alternatives.
                oscillator.frequency.setValueAtTime(1000, audioCtx.currentTime); // 1 kHz tone

                // Create a gain node to shape the envelope (a quick attack and decay)
                const gainNode = audioCtx.createGain();
                gainNode.gain.setValueAtTime(1.0, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.05);

                // Connect oscillator -> gain -> destination
                oscillator.connect(gainNode).connect(audioCtx.destination);

                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.05);
            }

            function continuousSpikeHandler() {
                // 1. Trigger the sound spike.
                playNeuronSpikeSoundOscillator();
            }

            function startContinuousSpiking() {
                // If already running, do nothing
                if (continuousSpikeTimer !== null) {
                    console.log("Continuous Spiking: Already running.");
                    return;
                }

                isContinuousSpikingActive = true;
                console.log("Continuous Spiking: Visual override ACTIVATED."); // Log activation

                // The handler only plays sound
                // Slowed down interval (e.g., 10Hz = 100ms interval) - adjust as needed
                const intervalMs = 200; // e.g., 10 Hz -> 100ms
                continuousSpikeTimer = setInterval(() => {
                    continuousSpikeHandler(); // Just plays sound
                }, intervalMs);
            }

            function stopContinuousSpiking() {
                if (continuousSpikeTimer !== null) {
                    clearInterval(continuousSpikeTimer);
                    continuousSpikeTimer = null;
                }
                isContinuousSpikingActive = false;
                console.log("Continuous Spiking: Visual override DEACTIVATED."); // Log deactivation
                // Explicitly reset marker visuals to default state when stopped
                if (networkSimulation && networkSimulation.neurons) {
                    networkSimulation.neurons.forEach((neuron, idx) => {
                        const marker = simNeuronMarkers[idx];
                        if (!marker) return;
                        // Reset to default appearance (match the 'resting' state in animate)
                        const baseScale = 8;
                        marker.scale.set(baseScale, baseScale, 1);
                        if (neuron.type === "excitatory") {
                            marker.material.opacity = 0.10;
                            marker.material.color.setHex(0x5588ff);
                        } else { // Inhibitory
                            marker.material.opacity = 0.15;
                            marker.material.color.setHex(0xaa55ff);
                        }
                    });
                } else {
                    // Fallback if simulation not running
                    simNeuronMarkers.forEach(marker => {
                        if (marker) {
                            marker.material.opacity = 0.1;
                            marker.scale.set(8, 8, 1);
                            // You might need a default color here if baseColor isn't set
                            marker.material.color.setHex(0x888888); // Default grey
                        }
                    });
                }
                // Also fade out any active dendrite pulses
                dendriteConnections.forEach(conn => {
                    if (conn.material.uniforms.pulseIntensity) {
                        conn.material.uniforms.pulseIntensity.value = 0.0;
                    }
                });
            }

            /**
             * Stops the current simulation (if any), disposes of its resources,
             * and resets simulation parameters to their default values.
             */
            function clearSimulationState() {
                console.log("Attempting to clear simulation state and reset parameters...");

                // --- Safety Check: Ensure default params are available ---
                if (typeof defaultSimulationParams === 'undefined' || defaultSimulationParams === null) {
                    console.error("FATAL: defaultSimulationParams is not defined or null when clearSimulationState runs!");
                    alert("Error: Cannot reset simulation - default parameters are missing. Check code order.");
                    return; // Exit early to prevent further errors
                }
                console.log("Accessing default simulation parameters:", defaultSimulationParams);

                // --- 1. Stop Running Simulation ---
                // Use the existing stopSimulation function as it handles the running flag and GUI toggle
                if (simulationParams.running) {
                    console.log(" -> Simulation is running, calling stopSimulation...");
                    simulationParams.stopSimulation(); // This sets running=false and updates GUI
                } else {
                    // Ensure flags are definitively false even if it wasn't running
                    simulationParams.running = false;
                    simulationParams.isInitialized = false;
                    if (runningController) runningController.updateDisplay(); // Update GUI just in case
                    console.log(" -> Simulation was already stopped.");
                }

                // --- 2. Dispose Simulation Manager Resources ---
                // Check the isInitialized flag *before* disposing
                // Accessing the flag via the manager instance itself is more direct
                if (simulationManager && simulationManager.params.isInitialized) {
                    console.log(" -> Disposing simulation manager...");
                    simulationManager.dispose(); // Clears neurons, connections, sets flags to false
                } else {
                    console.log(" -> Simulation manager not initialized or doesn't exist, skipping dispose.");
                }
                // Ensure the shared flag reflects the disposed state
                simulationParams.isInitialized = false;


                // --- 3. Dispose Simulation Visuals ---
                // Check the isInitialized flag *before* disposing
                if (simulationVisuals && simulationVisuals.isInitialized) {
                    console.log(" -> Disposing simulation visuals...");
                    simulationVisuals.dispose(); // Clears markers, lines, sets flag to false
                } else {
                    console.log(" -> Simulation visuals not initialized or don't exist, skipping dispose.");
                }

                // --- 4. Reset Simulation Parameters ---
                console.log(" -> Resetting simulation parameters to defaults...");
                let paramsReset = 0;
                for (const key in defaultSimulationParams) {
                    // Check if the key exists in the current params and is not a function
                    // Ensure we don't overwrite the essential function references
                    if (simulationParams.hasOwnProperty(key) && typeof simulationParams[key] !== 'function') {
                        // Deep copy for nested objects if any (though defaults are likely flat)
                        simulationParams[key] = JSON.parse(JSON.stringify(defaultSimulationParams[key]));
                        paramsReset++;
                    } else if (!simulationParams.hasOwnProperty(key)) {
                        console.warn(`   - Default param "${key}" not found in current simulationParams.`);
                    }
                }
                // Ensure crucial flags are reset even if not in defaults (though they should be)
                simulationParams.running = false;
                simulationParams.isInitialized = false;
                console.log(` -> Restored ${paramsReset} parameters. Running=${simulationParams.running}, Initialized=${simulationParams.isInitialized}`);

                // --- 5. Update dat.GUI Display ---
                // Iterate through controllers in the simulation folder and its subfolders
                console.log(" -> Updating GUI display for simulation parameters...");
                try {
                    if (gui && gui.__folders && gui.__folders["Neuron Firing Simulation"]) {
                        const simFolderGUI = gui.__folders["Neuron Firing Simulation"];

                        // Function to update controllers in a folder
                        const updateControllersInFolder = (folder) => {
                            if (!folder) return;
                            folder.__controllers.forEach(controller => {
                                // Update controllers only if the property exists in simulationParams
                                // and is not one of the action functions
                                if (simulationParams.hasOwnProperty(controller.property) &&
                                    controller.property !== 'startSimulation' &&
                                    controller.property !== 'stopSimulation' &&
                                    controller.property !== 'clearReset') // Exclude the reset button itself
                                {
                                    try {
                                        controller.updateDisplay();
                                    } catch (updateError) {
                                        console.warn(`    - Error updating GUI controller for '${controller.property}':`, updateError);
                                    }
                                }
                            });
                            // Recursively update subfolders
                            for (const subFolderName in folder.__folders) {
                                console.log(`    - Updating GUI for subfolder: ${subFolderName}`);
                                updateControllersInFolder(folder.__folders[subFolderName]);
                            }
                        };

                        // Start updating from the main simulation folder
                        updateControllersInFolder(simFolderGUI);

                        // Explicitly update the 'Running' controller state if it exists separately
                        if (runningController) {
                            runningController.updateDisplay();
                            console.log("   - Updated 'Running' toggle display.");
                        }

                    } else {
                        console.warn(" -> 'Neuron Firing Simulation' GUI folder not found for update.");
                    }

                    // Also update the sound settings GUI folder if it exists
                    if (gui && gui.__folders && gui.__folders["Sound Settings"]) {
                        console.log(" -> Updating GUI display for sound parameters...");
                        gui.__folders["Sound Settings"].__controllers.forEach(c => {
                            try {
                                c.updateDisplay();
                            } catch (soundUpdateError) {
                                console.warn(`    - Error updating GUI controller for sound setting '${c.property}':`, soundUpdateError);
                            }
                        });
                    }

                } catch (e) {
                    console.error(" -> Error updating GUI display after reset:", e);
                }


                // --- 6. Stop Continuous Spiker (Safety Check) ---
                if (continuousSpiker && continuousSpiker.isActive) {
                    console.log(" -> Stopping continuous spiker as part of reset...");
                    continuousSpiker.stop();
                    const toggleSpike = document.getElementById("toggleContinuousSpiking");
                    if (toggleSpike) {
                        toggleSpike.checked = false;
                        console.log("   - Unchecked continuous spiking toggle.");
                    }
                }

                console.log("Simulation cleared and parameters reset successfully.");
            } // End of clearSimulationState

            // ============================================================
            // Dendrite Connections (Persistent Connection Visuals)
            // ============================================================
            // Global array to hold dendrite connection meshes
            const dendriteConnections = [];

            // Function to create a dendrite (tube) between two neuron positions.
            function createDendriteConnection(startPos, endPos) {
                // Create a smooth curved path between start and end points.
                const path = new THREE.CatmullRomCurve3([startPos, endPos]);
                const tubeGeometry = new THREE.TubeGeometry(path, 20, 0.5, 8, false);
                const tubeMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        baseColor: { value: new THREE.Color(0x44ccff) },
                        pulseIntensity: { value: 0 }
                    },
                    vertexShader: `
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
                    fragmentShader: `
            uniform vec3 baseColor;
            uniform float pulseIntensity;
            varying vec2 vUv;
            void main() {
              // Mix the base color with white based on pulse intensity.
              vec3 color = mix(baseColor, vec3(1.0), pulseIntensity);
              gl_FragColor = vec4(color, 1.0);
            }
          `,
                    transparent: true
                });
                const tubeMesh = new THREE.Mesh(tubeGeometry, tubeMaterial);
                // Record a starting time (optional if you want to incorporate time‚Äìbased effects).
                tubeMesh.userData.startTime = performance.now() / 1000;
                return tubeMesh;
            }

            // Update function for dendrite pulses (to create a decaying or pulsating effect)
            function updateDendritePulses(deltaTime) {
                // Gamma frequency ~40 Hz is used as a reference.
                const gammaFrequency = 40.0;
                dendriteConnections.forEach(conn => {
                    // Here the pulseIntensity uniform decays over time.
                    // Optionally, you might also update using a sine function:
                    // const timeNow = performance.now() / 1000;
                    // conn.material.uniforms.pulseIntensity.value = 0.5 + 0.5 * Math.sin(2 * Math.PI * gammaFrequency * timeNow);
                    conn.material.uniforms.pulseIntensity.value *= 0.85;
                    if (conn.material.uniforms.pulseIntensity.value < 0.01) {
                        conn.material.uniforms.pulseIntensity.value = 0.0;
                    }
                });
            }


            // --- Spawn Lightning Bolts ---

            // --- Spawn Jagged Lightning Bolts (Excitatory) ---
            function spawnLightningBolts(firingNeuron, allNeurons) {
                if (!networkSimulation || !networkSimulation.connections) return;
                const startPos = firingNeuron.position;
                const firingNeuronIndex = firingNeuron.index;
                // Get outgoing connections from the firing neuron.
                const outgoingConnections = networkSimulation.connections.filter(conn => conn.from === firingNeuronIndex);
                // Shuffle and take a subset for visual effect.
                outgoingConnections.sort(() => 0.5 - Math.random());
                const boltsToDraw = outgoingConnections.slice(0, simulationParams.maxBoltsPerSpike);

                boltsToDraw.forEach(conn => {
                    const targetNeuron = allNeurons[conn.to];
                    if (!targetNeuron) return;
                    const endPos = targetNeuron.position;
                    // Create a dendrite connection mesh.
                    const dendrite = createDendriteConnection(startPos, endPos);
                    scene.add(dendrite);
                    dendriteConnections.push(dendrite);
                });
                //play neuron spike sound
                playNeuronSpikeSoundOscillator();
            }

            // --- Texture for Glow Sprites ---
            function createGlowTexture(color = 'white', size = 128) {
                const canvas = document.createElement("canvas");
                canvas.width = size; canvas.height = size;
                const context = canvas.getContext("2d");
                const center = size / 2; const radius = size / 2;
                const gradient = context.createRadialGradient(center, center, 0, center, center, radius);
                // More pronounced center glow
                gradient.addColorStop(0, `rgba(${color === 'white' ? '255,255,255' : '220,220,255'}, 1.0)`);
                gradient.addColorStop(0.2, `rgba(${color === 'white' ? '255,255,255' : '200,200,255'}, 0.8)`);
                gradient.addColorStop(0.5, `rgba(${color === 'white' ? '200,200,200' : '150,150,200'}, 0.4)`);
                gradient.addColorStop(1, `rgba(${color === 'white' ? '0,0,0' : '50,50,100'}, 0.0)`);
                context.fillStyle = gradient;
                context.fillRect(0, 0, size, size);
                return new THREE.CanvasTexture(canvas);
            }

            // Store a default glow texture
            const defaultGlowTexture = createGlowTexture();

            // --- Simulation Module ---
            // Create a sprite material for the firing glow effect
            function createGlowSpriteMaterial(regionColor) {
                const size = 256;
                const canvas = document.createElement("canvas");
                canvas.width = canvas.height = size;
                const ctx = canvas.getContext("2d");
                // Create a radial gradient for a bright central glow fading to transparent
                const grad = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
                grad.addColorStop(0, regionColor);
                grad.addColorStop(0.5, regionColor.replace("rgb", "rgba").replace(")", ", 0.4)"));
                grad.addColorStop(1, "rgba(0,0,0,0)");
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, size, size);
                const texture = new THREE.CanvasTexture(canvas);
                return new THREE.SpriteMaterial({
                    map: texture,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
            }

            // Initialize simulation fields for each region after data is loaded.
            function initializeNeuronFiringSimulation() {
                regionInfoList.forEach(region => {
                    if (!region) return;
                    // Set up simulation state for each region
                    region.activity = 0;            // current activity (0 to 1)
                    region.lastSpikeTime = 0;       // time (in seconds) of last spike
                    region.nextSpikeTime = performance.now() / 1000 + (Math.random() / simulationParams.firingProbability);
                    // Create a glow sprite for this region
                    const colorObj = new THREE.Color(region.colorHex);
                    const regionRGB = `rgb(${Math.floor(colorObj.r * 255)},${Math.floor(colorObj.g * 255)},${Math.floor(colorObj.b * 255)})`;
                    region.glowSprite = new THREE.Sprite(createGlowSpriteMaterial(regionRGB));
                    // Use region.center if available; otherwise default to origin
                    region.glowSprite.position.copy(region.center || new THREE.Vector3());
                    region.glowSprite.scale.set(0, 0, 0); // start off invisible
                    scene.add(region.glowSprite);
                    // Create a group to hold connectivity line objects
                    region.connectivityGroup = new THREE.Group();
                    scene.add(region.connectivityGroup);
                });
            }


            function updateNeuronMarkers() {
                const now = performance.now();
                simNeuronMarkers.forEach(marker => {
                    // If the marker spiked recently, show a flash effect.
                    const lastSpike = marker.userData.lastSpikeTime || 0;
                    const dt = now - lastSpike;
                    if (dt < 50) { // within 50 ms of spike
                        marker.material.opacity = 1.0;       // Full brightness flash
                        marker.scale.set(20, 20, 1);           // Increase size for dramatic effect
                        marker.material.color.setHex(0xffffff); // Flash white
                    } else {
                        // Fade back to normal state.
                        marker.material.opacity = 0.15;
                        marker.scale.set(8, 8, 1);
                        // Optionally, set the marker color back to its original base value.
                        // For example, if you have a property marker.userData.baseColor set during creation:
                        if (marker.userData.baseColor) {
                            marker.material.color.set(marker.userData.baseColor);
                        }
                    }
                });
            }


            // Trigger a spike event for a region (simulate firing)
            function triggerSpike(region) {
                region.activity = 1.0;
                region.lastSpikeTime = performance.now() / 1000;
                spawnConnectivityLines(region);
            }


            // Spawn connectivity lines (lighting storm effect) when a region fires
            function spawnConnectivityLines(region) {
                const center = region.center || new THREE.Vector3();
                const points = [];
                for (let i = 0; i < simulationParams.numConnectivityLines; i++) {
                    points.push(center.x, center.y, center.z);
                    const direction = new THREE.Vector3(
                        Math.random() * 2 - 1,
                        Math.random() * 2 - 1,
                        Math.random() * 2 - 1
                    ).normalize();
                    // Use simulationParams.maxGlowScale to define the line length
                    const length = simulationParams.maxGlowScale * (0.5 + Math.random() * 0.5);
                    direction.multiplyScalar(length).add(center);
                    points.push(direction.x, direction.y, direction.z);
                }
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute("position", new THREE.Float32BufferAttribute(points, 3));
                const material = new THREE.LineBasicMaterial({
                    color: region.colorHex,
                    transparent: true,
                    opacity: 1.0,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                const lineSegments = new THREE.LineSegments(geometry, material);
                lineSegments.userData.startTime = performance.now();
                region.connectivityGroup.add(lineSegments);
            }

            // --- Instantiate Simulation Components ---
            let simulationManager = new SimulationManager(simulationParams, physicsWorld); // Pass the GUI params object
            let simulationVisuals = new SimulationVisuals(scene, simulationParams, physicsWorld); // Pass scene and params
            // --- Refactored GUI Parameter Linking ---
            // Link dat.GUI controls to the manager actions
            simulationParams.startSimulation = function () {
                console.log("GUI: Requesting simulation start...");
                // 1. Get selected regions (same logic as before)
                const selectedRegionIDs = regionInfoList
                    .filter(region => region && region.visible)
                    .map(region => region.id);

                if (selectedRegionIDs.length === 0) {
                    console.warn("GUI: No regions selected for simulation. Cannot start.");
                    simulationParams.running = false; // Ensure GUI reflects stop state
                    if (runningController) runningController.updateDisplay();
                    return;
                }

                // 2. Gather and Sample Neuron Data (same logic as before)
                let allNeuronsData = [];
                if (!finalPointRegionIDs || !finalPositions) {
                    console.warn("GUI: No point cloud data available for simulation");
                    simulationParams.running = false;
                    if (runningController) runningController.updateDisplay();
                    return;
                }
                const selectedRegionIDSet = new Set(selectedRegionIDs);
                for (let i = 0; i < finalPointRegionIDs.length; i++) {
                    const regionID = finalPointRegionIDs[i];
                    if (selectedRegionIDSet.has(regionID)) {
                        let pos = new THREE.Vector3(finalPositions[i * 3], finalPositions[i * 3 + 1], finalPositions[i * 3 + 2]);
                        allNeuronsData.push({ position: pos, regionId: regionID });
                    }
                }
                if (allNeuronsData.length === 0) {
                    console.warn("GUI: No neurons found in selected regions.");
                    simulationParams.running = false;
                    if (runningController) runningController.updateDisplay();
                    return;
                }

                // Sample neurons
                let sampledNeuronsData = allNeuronsData;
                if (allNeuronsData.length > simulationParams.maxSimNeurons) {
                    console.log(`GUI: Sampling ${simulationParams.maxSimNeurons} neurons from ${allNeuronsData.length}.`);
                    // Simple random sampling (Fisher-Yates shuffle is better for large sets)
                    sampledNeuronsData = allNeuronsData.sort(() => 0.5 - Math.random()).slice(0, simulationParams.maxSimNeurons);
                }

                // 3. Initialize Simulation Manager
                const initSuccess = simulationManager.initialize(sampledNeuronsData);

                // 4. Initialize Simulation Visuals
                if (initSuccess) {
                    simulationVisuals.initialize(simulationManager.neurons); // Use neurons from manager
                    simulationManager.start(); // Start the manager's update cycle
                } else {
                    // Handle initialization failure
                    simulationParams.running = false;
                    if (runningController) runningController.updateDisplay();
                }
                if (runningController) runningController.updateDisplay(); // Update GUI state
            };

            simulationParams.stopSimulation = function () {
                console.log("GUI: Requesting simulation stop...");
                simulationManager.stop();
                // Visuals are reset automatically in the animate loop when running is false
                // simulationVisuals.dispose(); // Option: fully dispose visuals on stop? Or just reset? Resetting is usually better.
                simulationVisuals._resetVisuals(); // Explicitly reset visuals immediately

                // Ensure continuous spiker is also stopped
                if (continuousSpiker.isActive) {
                    continuousSpiker.stop();
                    // Also visually update the toggle if needed
                    const toggle = document.getElementById("toggleContinuousSpiking");
                    if (toggle) toggle.checked = false;
                }

                simulationParams.running = false; // Ensure param state matches
                if (runningController) runningController.updateDisplay(); // Update GUI
            };

            // Find the 'running' controller to update its display
            //runningController = null;
            if (gui.__folders && gui.__folders["Neuron Firing Simulation"]) {
                runningController = gui.__folders["Neuron Firing Simulation"].__controllers.find(c => c.property === 'running');
            }

            // Add the onChange handler to the 'running' controller if found
            if (runningController) {
                runningController.onChange(function (value) {
                    console.log(`GUI 'Running' toggle changed by user to: ${value}`);
                    if (value === true) {
                        // User wants to START
                        if (!simulationParams.running) { // Check internal state first
                            simulationParams.startSimulation(); // Call the manager-linked start function
                        }
                    } else {
                        // User wants to STOP
                        if (simulationParams.running) { // Check internal state first
                            simulationParams.stopSimulation(); // Call the manager-linked stop function
                        }
                    }
                });
            } else {
                console.warn("Could not find 'Running' controller in dat.GUI folder.");
            }

            // Maximum number of neurons to include in the detailed simulation for performance
            const MAX_SIM_NEURONS = 500;

            // Initialize simulation for ALL currently selected regions (with sampling)

            function initSimulationForSelectedRegions() {
                console.log("Initializing simulation for selected regions...");

                // --- 1. Cleanup previous simulation ---
                simulationParams.stopSimulation(); // Use the stop function for proper cleanup
                simulationParams.running = false;  // Ensure running state is false initially

                // --- 2. Identify Selected Regions ---
                const selectedRegionIDs = regionInfoList
                    .filter(region => region && region.visible)
                    .map(region => region.id);

                if (selectedRegionIDs.length === 0) {
                    console.warn("No regions selected for simulation.");
                    return; // Stop initialization
                }
                console.log(`Found ${selectedRegionIDs.length} selected regions.`);

                // --- 3. Gather ALL Neuron Data from Selected Regions ---
                let allNeuronsData = []; // Stores { position: Vector3, regionId: number }
                if (!finalPointRegionIDs || !finalPositions) {
                    console.warn("No point cloud data available for simulation");
                    return;
                }
                const selectedRegionIDSet = new Set(selectedRegionIDs);
                for (let i = 0; i < finalPointRegionIDs.length; i++) {
                    const regionID = finalPointRegionIDs[i];
                    if (selectedRegionIDSet.has(regionID)) {
                        let pos = new THREE.Vector3(
                            finalPositions[i * 3],
                            finalPositions[i * 3 + 1],
                            finalPositions[i * 3 + 2]
                        );
                        allNeuronsData.push({ position: pos, regionId: regionID });
                    }
                }
                console.log(`Gathered ${allNeuronsData.length} potential neurons from selected regions.`);

                if (allNeuronsData.length === 0) {
                    console.warn("No neurons found in selected regions.");
                    return;
                }

                // --- 4. SAMPLE Neurons for Detailed Simulation ---
                let sampledNeuronsData = allNeuronsData;
                if (allNeuronsData.length > simulationParams.maxSimNeurons) {
                    console.log(`Sampling ${simulationParams.maxSimNeurons} neurons from ${allNeuronsData.length}.`);
                    sampledNeuronsData = [];
                    const indices = Array.from({ length: allNeuronsData.length }, (_, i) => i);
                    for (let i = indices.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [indices[i], indices[j]] = [indices[j], indices[i]];
                    }
                    for (let i = 0; i < simulationParams.maxSimNeurons; i++) {
                        // Safety check in case maxSimNeurons > allNeuronsData.length after filtering
                        if (i < indices.length) {
                            sampledNeuronsData.push(allNeuronsData[indices[i]]);
                        }
                    }
                } else {
                    console.log(`Using all ${allNeuronsData.length} found neurons for simulation.`);
                }

                // --- 5. Create Neuron Objects (from sampled data) ---
                let simNeurons = []; // <<< Declare simNeurons here
                sampledNeuronsData.forEach((data, idx) => {
                    let type = (Math.random() < 0.8) ? "excitatory" : "inhibitory";
                    simNeurons.push(new Neuron(data.position, type, idx));
                });

                // --- 6. Create Connectivity (Local or Random) ---
                // <<< Move connection generation AFTER simNeurons exists >>>
                let connections = [];          // <<< Declare connections here
                const numSimNeurons = simNeurons.length; // <<< Declare numSimNeurons here

                if (numSimNeurons > 0) { // Only create connections if there are neurons
                    if (simulationParams.useLocalConnectivity) {
                        // --- LOCAL CONNECTIVITY based on Radius W ---
                        console.log(`Generating local connections with radius ${simulationParams.connectivityRadiusW} and prob ${simulationParams.localConnectionProbability}`);
                        let connectionCount = 0;
                        const radiusSq = simulationParams.connectivityRadiusW * simulationParams.connectivityRadiusW;

                        for (let i = 0; i < numSimNeurons; i++) {
                            const sourceNeuron = simNeurons[i];
                            for (let j = 0; j < numSimNeurons; j++) {
                                if (i === j) continue;

                                const targetNeuron = simNeurons[j];
                                const distSq = sourceNeuron.position.distanceToSquared(targetNeuron.position);

                                if (distSq <= radiusSq) {
                                    if (Math.random() < simulationParams.localConnectionProbability) {
                                        let initialWeight = (sourceNeuron.type === "excitatory")
                                            ? randomRange(0.6, 1.8) : randomRange(1.0, 2.5);
                                        connections.push({
                                            from: i, to: j, weight: initialWeight,
                                            lastPreSpikeTime: -Infinity, lastPostSpikeTime: -Infinity
                                        });
                                        connectionCount++;
                                    }
                                }
                            }
                        }
                        console.log(`Created ${connectionCount} local connections.`);
                    } else {
                        // --- GLOBAL RANDOM CONNECTIVITY ---
                        console.log("Generating global random connections.");
                        for (let i = 0; i < numSimNeurons; i++) {
                            let numConnections = Math.floor(randomRange(5, 15));
                            for (let j = 0; j < numConnections; j++) {
                                let targetIdx = Math.floor(randomRange(0, numSimNeurons));
                                if (targetIdx === i) continue;
                                let initialWeight = (simNeurons[i].type === "excitatory")
                                    ? randomRange(0.5, 1.5) : randomRange(0.8, 2.0);
                                connections.push({
                                    from: i, to: targetIdx, weight: initialWeight,
                                    lastPreSpikeTime: -Infinity, lastPostSpikeTime: -Infinity
                                });
                            }
                        }
                        console.log(`Created ~${connections.length} random connections.`);
                    }
                } // End if(numSimNeurons > 0)

                // --- 7. Instantiate Simulation ---
                networkSimulation = new NeuralNetworkSimulation(simNeurons, connections);

                // --- 8. Create Visual Markers (Sprites) ---
                // <<< Remove previous simNeuronMarkers first >>>
                simNeuronMarkers.forEach(marker => scene.remove(marker));
                simNeuronMarkers = []; // Reset the array

                const baseScale = 8;
                simNeurons.forEach((neuron) => {
                    const spriteMaterial = new THREE.SpriteMaterial({
                        map: defaultGlowTexture,
                        color: (neuron.type === "excitatory") ? 0x5588ff : 0xaa55ff,
                        transparent: true, blending: THREE.AdditiveBlending, depthWrite: false,
                        opacity: 0.15, sizeAttenuation: true
                    });
                    const sprite = new THREE.Sprite(spriteMaterial);
                    sprite.position.copy(neuron.position);
                    sprite.scale.set(baseScale, baseScale, 1);
                    scene.add(sprite);
                    simNeuronMarkers.push(sprite); // Add the NEW marker
                });

                // --- 9. Set Running State ---
                simulationParams.running = true;
                console.log(`Simulation initialized and running with ${numSimNeurons} neurons.`);
                // Update GUI running state
                if (gui.__folders && gui.__folders["Neuron Firing Simulation"]) {
                    const runningController = gui.__folders["Neuron Firing Simulation"].__controllers.find(c => c.property === 'running');
                    if (runningController) runningController.updateDisplay();
                }
            }


            function updateSimulation(simulation, currentTime_ms, delta) {
                if (!simulation) return;
                const steps = simulationParams.simulationStepsPerFrame;
                const dt_ms = Math.max(0.1, (delta * 1000) / steps);
                for (let i = 0; i < steps; i++) {
                    const stepTime = currentTime_ms - ((steps - 1 - i) * dt_ms);
                    simulation.step(stepTime);
                }
            }
            // === Visual Update for Continuous Spiking ===
            // Example: If simulation markers (simNeuronMarkers) are available,
            // we update their color, opacity, and scale.
            // Visual update: when a spike event occurs, make markers flash or glow.
            function updateContinuousSpikingVisuals() {
                if (!simNeuronMarkers || simNeuronMarkers.length === 0) {
                    console.warn("No simulation markers available for visual spiking!");
                    return;
                }
                simNeuronMarkers.forEach(marker => {
                    // Make the marker pulse: change color to white, increase scale.
                    marker.material.color.setHex(0xffffff);
                    marker.material.opacity = 1.0;
                    marker.scale.set(50, 50, 1);
                });
            }

            // Reset visuals: return markers to their baseline appearance.
            function resetSimulationMarkerVisuals() {
                if (!simNeuronMarkers) return;
                simNeuronMarkers.forEach(marker => {
                    // Use stored baseColor if available; otherwise use a default.
                    const baseColor = marker.userData.baseColor ? marker.userData.baseColor.getHex() : 0x5588ff;
                    marker.material.color.setHex(baseColor);
                    marker.material.opacity = marker.userData.defaultOpacity || 0.1;
                    marker.scale.set(8, 8, 1);
                });
            }

            // === Global Instances ===
            const continuousSpiker = new ContinuousSpikingController({
                intervalMs: 100, // 10 Hz
                soundHandler: playSpikeSound,
                visualHandler: updateContinuousSpikingVisuals,
                visualReset: resetSimulationMarkerVisuals,
            });

            // === Hooking up UI for Continuous Spiking ===
            // Example: A checkbox toggles continuous spiking.
            document.getElementById("toggleContinuousSpiking").addEventListener("change", function () {
                if (this.checked) {
                    if (!simulationVisuals || !simulationVisuals.isInitialized) {
                        alert("Simulation needs to be initialized first (Start Simulation).");
                        this.checked = false; return;
                    }
                    // Stop detailed sim if running
                    if (simulationManager.params.running) { simulationParams.stopSimulation(); } // Use the wrapper
                    continuousSpiker.start();
                } else {
                    continuousSpiker.stop();
                }
            });

            // Add volumetric fog to the scene.
            scene.fog = new THREE.FogExp2(0x000000, simulationParams.fogDensity);

            // Set up postprocessing for bloom.


            const composer = new THREE.EffectComposer(renderer);
            composer.addPass(new THREE.RenderPass(scene, camera));
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                simulationParams.bloomStrength, // Use initial value
                simulationParams.bloomRadius,   // Use initial value
                simulationParams.bloomThreshold // Use initial value
            );
            composer.addPass(bloomPass);

            // ===== End Neuron Firing Simulation Code =====

            // CSV Parsing with Inline Worker
            function loadCSV(file) {

                // Clear the previous cached state so a new CSV provides a fresh start.
                localStorage.removeItem("cachedPositions");
                localStorage.removeItem("cachedColors");
                localStorage.removeItem("cachedPointIDs");
                localStorage.removeItem("cachedIntensities");
                localStorage.removeItem("cachedRegionInfo");
                localStorage.removeItem("guiParams");
                localStorage.removeItem("cameraState");

                cleanupPreviousData();
                loadingIndicator.style.display = "block";
                loadingMessage.textContent = "Initializing Worker...";
                loadingProgress.value = 0;
                loadingProgress.style.display = "block";
                hoverTooltip.style.display = "none";
                selectedTooltip.style.display = "none";
                try {
                    const workerScriptContent = document.getElementById("worker-script").textContent;
                    const workerBlob = new Blob([workerScriptContent], { type: "application/javascript" });
                    const workerBlobURL = URL.createObjectURL(workerBlob);
                    dataWorker = new Worker(workerBlobURL);
                    dataWorker.onmessage = function (e) {
                        const msg = e.data;
                        if (msg.type === "progress") {
                            loadingMessage.textContent = "Parsing " + msg.processedRows.toLocaleString() + " rows...";
                            loadingProgress.value = msg.progress;
                        } else if (msg.type === "batch_data") {
                            const batch = msg.payload;
                            accumulatedPositions.push(batch.positions);
                            accumulatedColors.push(batch.colors);
                            accumulatedPointRegionIDs.push(batch.pointRegionIDs);
                            accumulatedIntensities.push(batch.intensities);
                            receivedPoints += batch.pointRegionIDs.length;
                            loadingMessage.textContent = "Received " + receivedPoints.toLocaleString() + " points...";
                            if (isProcessingComplete && receivedPoints >= expectedTotalPoints) {
                                buildFinalVisualization();
                                if (dataWorker) { dataWorker.terminate(); dataWorker = null; }
                            }
                        } else if (msg.type === "processing_complete") {
                            isProcessingComplete = true;
                            regionInfoList = msg.payload.regionInfoList;
                            expectedTotalPoints = msg.payload.totalPoints;
                            dataBounds = {
                                min: new THREE.Vector3(msg.payload.bounds.min.x, msg.payload.bounds.min.y, msg.payload.bounds.min.z),
                                max: new THREE.Vector3(msg.payload.bounds.max.x, msg.payload.bounds.max.y, msg.payload.bounds.max.z),
                                center: new THREE.Vector3(msg.payload.bounds.center.x, msg.payload.bounds.center.y, msg.payload.bounds.center.z),
                                size: msg.payload.bounds.size
                            };
                            loadingMessage.textContent = "Processing complete. Assembling " + expectedTotalPoints.toLocaleString() + " points...";
                            loadingProgress.value = 95;
                            if (receivedPoints >= expectedTotalPoints) {
                                buildFinalVisualization();
                                if (dataWorker) { dataWorker.terminate(); dataWorker = null; }
                            }
                        } else if (msg.type === "error") {
                            loadingMessage.textContent = "Error: " + msg.message;
                            loadingProgress.style.display = "none";
                            if (dataWorker) { dataWorker.terminate(); dataWorker = null; }
                        }
                    };
                    dataWorker.onerror = function (error) {
                        loadingMessage.textContent = "Worker Error: " + error.message + " (Check console)";
                        loadingProgress.style.display = "none";
                        if (dataWorker) { dataWorker.terminate(); dataWorker = null; }
                    };
                    dataWorker.postMessage({ file: file, config: { RESOLUTION: RESOLUTION } });
                } catch (error) {
                    loadingMessage.textContent = "Error creating worker: " + error.message;
                    loadingIndicator.style.display = "block";
                    loadingProgress.style.display = "none";
                    if (dataWorker) { dataWorker.terminate(); dataWorker = null; }
                }
                saveState();
            }

            const ATLAS_REGION_LEVEL_FIELDS = Array.from({ length: 10 }, (_, index) => `RegionLevel_${String(index + 1).padStart(2, "0")}`);

            function quoteCsvValue(value) {
                if (value === undefined || value === null) return "";
                const str = String(value);
                if (/["\n,]/.test(str)) {
                    return `"${str.replace(/"/g, '""')}"`;
                }
                return str;
            }

            function parseAtlasCSVToMap(file) {
                return new Promise((resolve, reject) => {
                    if (typeof Papa === "undefined") {
                        reject(new Error("PapaParse is not available in the main thread."));
                        return;
                    }
                    Papa.parse(file, {
                        header: true,
                        skipEmptyLines: true,
                        dynamicTyping: false,
                        complete(results) {
                            const map = {};
                            (results.data || []).forEach(row => {
                                if (!row) return;
                                const idValue = row.ID !== undefined ? String(row.ID).trim() : "";
                                if (!idValue) return;
                                const abbreviationCandidate = (row.Abbreviation || row["original_abbrev (with duplicates)"] || "").trim();
                                const abbreviation = abbreviationCandidate || `ID_${idValue}`;
                                let regionName = abbreviation;
                                for (const levelField of ATLAS_REGION_LEVEL_FIELDS) {
                                    if (typeof row[levelField] === "string") {
                                        const trimmed = row[levelField].trim();
                                        if (trimmed) {
                                            regionName = trimmed;
                                            break;
                                        }
                                    }
                                }
                                map[idValue] = { abbreviation, regionName };
                            });
                            resolve(map);
                        },
                        error(error) {
                            reject(error);
                        }
                    });
                });
            }

            function locateCandidateCellsFromDocuments(documents) {
                for (const doc of documents) {
                    if (!doc) continue;
                    if (Array.isArray(doc.candidate_cells) && doc.candidate_cells.length > 0) {
                        return doc.candidate_cells;
                    }
                    if (Array.isArray(doc) && doc.length > 0 && typeof doc[0] === "object" && "x" in doc[0]) {
                        return doc;
                    }
                    for (const value of Object.values(doc)) {
                        if (Array.isArray(value) && value.length > 0 && typeof value[0] === "object" && "x" in value[0]) {
                            return value;
                        }
                    }
                }
                return [];
            }

            async function convertYamlToCsv(yamlFile, atlasMap) {
                if (!yamlFile) throw new Error("YAML file is required.");
                if (yamlFile.stream && typeof yamlFile.stream === "function" && typeof TextDecoderStream !== "undefined") {
                    return streamAndConvertYaml(yamlFile, atlasMap);
                }
                const yamlText = await yamlFile.text();
                const yamlLib = typeof jsyaml !== "undefined" ? jsyaml : (window.jsyaml || null);
                if (!yamlLib) throw new Error("js-yaml is not loaded on the page.");
                const documents = [];
                yamlLib.loadAll(yamlText, doc => documents.push(doc));
                const candidateCells = locateCandidateCellsFromDocuments(documents);
                if (candidateCells.length === 0) throw new Error("YAML data did not contain any candidate_cells-like entries.");
                const lines = ["x,y,z,region_acronym,region_name,intensity"];
                for (const candidate of candidateCells) {
                    const rawX = candidate?.x;
                    const rawY = candidate?.y;
                    const rawZ = candidate?.z;
                    const x = Number(rawX);
                    const y = Number(rawY);
                    const z = Number(rawZ);
                    if (![x, y, z].every(value => typeof value === "number" && Number.isFinite(value))) continue;
                    const metadata = candidate.metadata || {};
                    const regionIdRaw = metadata.region_id ?? metadata.regionId;
                    const regionIdKey = regionIdRaw !== undefined && regionIdRaw !== null ? String(regionIdRaw).trim() : "";
                    const atlasEntry = regionIdKey ? atlasMap[regionIdKey] : undefined;
                    const regionAcronym = atlasEntry ? atlasEntry.abbreviation : (regionIdKey ? `ID_${regionIdKey}` : "unknown");
                    const regionName = atlasEntry ? atlasEntry.regionName : regionAcronym;
                    let intensity = 1;
                    const intensityKeys = ["center_intensity", "centerIntensity", "intensity"];
                    for (const key of intensityKeys) {
                        if (metadata[key] !== undefined && metadata[key] !== null) {
                            const parsed = Number(metadata[key]);
                            if (!isNaN(parsed) && Number.isFinite(parsed)) {
                                intensity = parsed;
                                break;
                            }
                        }
                    }
                    lines.push(`${x},${y},${z},${quoteCsvValue(regionAcronym)},${quoteCsvValue(regionName)},${intensity}`);
                }
                if (lines.length === 1) throw new Error("YAML candidate_cells did not yield any valid points.");
                return lines.join("\n");
            }

            function parseYamlPrimitive(value) {
                if (value === null || value === "" || value === undefined) return value;
                const numeric = Number(value);
                if (!isNaN(numeric) && Number.isFinite(numeric)) return numeric;
                return value;
            }

            async function streamAndConvertYaml(yamlFile, atlasMap) {
                const csvChunks = ["x,y,z,region_acronym,region_name,intensity\n"];
                const reader = yamlFile.stream().pipeThrough(new TextDecoderStream()).getReader();
                let leftover = "";
                let inCandidatesSection = false;
                let currentCell = null;
                let metadataBaseIndent = null;
                let insideMetadata = false;
                let foundCandidateLine = false;

                const flushCell = () => {
                    if (!currentCell) return;
                    const metadata = currentCell.metadata || {};
                    const x = Number(currentCell.x);
                    const y = Number(currentCell.y);
                    const z = Number(currentCell.z);
                    if (![x, y, z].every(value => typeof value === "number" && Number.isFinite(value))) {
                        currentCell = null;
                        return;
                    }
                    const regionIdRaw = metadata.region_id ?? metadata.regionId ?? metadata.ID ?? currentCell.region_id;
                    const regionIdKey = regionIdRaw !== undefined && regionIdRaw !== null ? String(regionIdRaw).trim() : "";
                    const atlasEntry = regionIdKey ? atlasMap[regionIdKey] : undefined;
                    const regionAcronym = atlasEntry ? atlasEntry.abbreviation : (regionIdKey ? `ID_${regionIdKey}` : "unknown");
                    const regionName = atlasEntry ? atlasEntry.regionName : regionAcronym;
                    const intensityKeys = ["center_intensity", "centerIntensity", "intensity"];
                    let intensity = 1;
                    for (const key of intensityKeys) {
                        if (metadata[key] !== undefined && metadata[key] !== null) {
                            const parsed = Number(metadata[key]);
                            if (!isNaN(parsed) && Number.isFinite(parsed)) {
                                intensity = parsed;
                                break;
                            }
                        }
                    }
                    csvChunks.push(`${x},${y},${z},${quoteCsvValue(regionAcronym)},${quoteCsvValue(regionName)},${intensity}\n`);
                    currentCell = null;
                    insideMetadata = false;
                    metadataBaseIndent = null;
                };

                const handleKeyValue = (entry, indent) => {
                    if (!currentCell) return;
                    const colonIndex = entry.indexOf(":");
                    if (colonIndex === -1) return;
                    const key = entry.slice(0, colonIndex).trim();
                    const value = entry.slice(colonIndex + 1).trim();
                    if (key === "metadata" && value === "") {
                        insideMetadata = true;
                        metadataBaseIndent = indent;
                        return;
                    }
                    if (insideMetadata && indent <= metadataBaseIndent) {
                        insideMetadata = false;
                        metadataBaseIndent = null;
                    }
                    const target = insideMetadata ? currentCell.metadata : currentCell;
                    target[key] = parseYamlPrimitive(value);
                };

                const processLine = (line) => {
                    const trimmed = line.trim();
                    if (!inCandidatesSection) {
                        if (trimmed.startsWith("candidate_cells")) {
                            inCandidatesSection = true;
                        }
                        return;
                    }
                    if (trimmed === "" || trimmed.startsWith("#")) return;
                    const indent = line.length - line.trimStart().length;
                    if (trimmed.startsWith("-")) {
                        foundCandidateLine = true;
                        flushCell();
                        currentCell = { metadata: {} };
                        insideMetadata = false;
                        metadataBaseIndent = null;
                        const remainder = trimmed.slice(1).trim();
                        if (remainder) {
                            handleKeyValue(remainder, indent + 1);
                        }
                        return;
                    }
                    handleKeyValue(trimmed, indent);
                };

                while (true) {
                    const { value, done } = await reader.read();
                    if (value) {
                        leftover += value;
                        let newlineIndex;
                        while ((newlineIndex = leftover.indexOf("\n")) >= 0) {
                            const line = leftover.slice(0, newlineIndex);
                            leftover = leftover.slice(newlineIndex + 1);
                            processLine(line.replace(/\r$/, ""));
                        }
                    }
                    if (done) break;
                }
                if (leftover.trim().length > 0) {
                    processLine(leftover.replace(/\r$/, ""));
                }
                flushCell();
                if (!foundCandidateLine && csvChunks.length === 1) {
                    throw new Error("YAML data did not contain any candidate_cells-like entries.");
                }
                if (csvChunks.length === 1) {
                    throw new Error("YAML candidate_cells did not yield any valid points.");
                }
                return csvChunks.join("");
            }

            const yamlInputElement = document.getElementById("yamlInput");
            const atlasInputElement = document.getElementById("atlasInput");
            const loadYamlButton = document.getElementById("loadYamlWithAtlas");

            async function handleYamlAtlasLoad() {
                const yamlFile = yamlInputElement?.files?.[0];
                const atlasFile = atlasInputElement?.files?.[0];
                if (!yamlFile || !atlasFile) {
                    alert("Please select both the candidate YAML file and the atlas CSV.");
                    return;
                }
                loadYamlButton.disabled = true;
                loadingMessage.textContent = "Preparing YAML + atlas data...";
                try {
                    const atlasMap = await parseAtlasCSVToMap(atlasFile);
                    if (!atlasMap || Object.keys(atlasMap).length === 0) {
                        throw new Error("Atlas CSV did not produce any region entries.");
                    }
                    const csvString = await convertYamlToCsv(yamlFile, atlasMap);
                    const csvBlob = new Blob([csvString], { type: "text/csv" });
                    const derivedName = yamlFile.name.replace(/\.[^/.]+$/, "") + "-with-atlas.csv";
                    const convertedFile = new File([csvBlob], derivedName, { type: "text/csv" });
                    loadCSV(convertedFile);
                } catch (error) {
                    alert("Failed to load YAML + atlas data: " + (error?.message || error));
                    console.error("YAML atlas conversion error:", error);
                    loadingMessage.textContent = "YAML + atlas load failed.";
                } finally {
                    loadYamlButton.disabled = false;
                }
            }

            if (loadYamlButton) {
                loadYamlButton.addEventListener("click", handleYamlAtlasLoad);
            }
            function tryLoadYamlAtlasIfReady() {
                if (!loadYamlButton || loadYamlButton.disabled) return;
                const yamlFile = yamlInputElement?.files?.[0];
                const atlasFile = atlasInputElement?.files?.[0];
                if (yamlFile && atlasFile) {
                    handleYamlAtlasLoad();
                }
            }
            yamlInputElement?.addEventListener("change", tryLoadYamlAtlasIfReady);
            atlasInputElement?.addEventListener("change", tryLoadYamlAtlasIfReady);

            document.getElementById("fileInput").addEventListener("change", function (event) {
                const file = event.target.files[0];
                if (file) {
                    if (!file.name.toLowerCase().endsWith(".csv")) {
                        alert("Please select a CSV file.");
                        event.target.value = null;
                        return;
                    }
                    loadCSV(file);
                }
            });

            document.getElementById("openInBrowser").addEventListener("click", function () {
                window.open(window.location.href, '_blank');
            });

            setupRegionFilterGUI();

            // Main Animation Loop
            const mainClock = new THREE.Clock();
            // --- Add a global flag for debug logging to avoid flooding the console ---
            let hasLoggedDebugState = false;
            let lastLogTime = 0;

            function animate() {
                requestAnimationFrame(animate);
                const delta = mainClock.getDelta(); // Time since last frame in seconds
                const nowMs = performance.now();    // Current time in milliseconds
                const elapsedTime = mainClock.getElapsedTime();

                // --- 1. Update Controls and Manual Fly Mode ---
                controls.update();
                updateFlyMode();

                // --- 2. Step the Physics World ---
                // Pass delta, physics world handles internal fixed time stepping
                simulationManager.stepPhysics(delta);

                // --- 3. Step the Biological Simulation ---
                simulationManager.step(delta); // Steps the HH models, detects spikes

                // --- 4. Update Visuals (Handles Soma Markers AND Synaptic Effects) ---
                const simState = simulationManager.getSimulationState();
                // Pass isContinuousSpikingActive to let visuals handle override
                simulationVisuals.update(simState, continuousSpiker.isActive, nowMs);


                // --- 4b. Update Stylized Neuron Firing ---
                if (activeStylizedNeurons.length > 0) {
                    // --- Link Simulation Spikes to Stylized Neurons ---
                    if (simState && simState.isRunning && simState.spikedIndices && simState.spikedIndices.size > 0) {
                        const simNeurons = simState.neurons; // Array of CompartmentalNeuron or Neuron
                        simState.spikedIndices.forEach(spikedSimIndex => {
                            const spikedNeuron = simNeurons[spikedSimIndex];
                            if (!spikedNeuron) return;

                            // Find potentially matching *visible* stylized neuron by position (approximation)
                            // TODO: Improve matching using originalDataIndex if available and reliable
                            const spikedPos = spikedNeuron.position; // Assumes CompartmentalNeuron has .position getter for soma
                            for (const stylizedNeuron of activeStylizedNeurons) {
                                // Check distance (adjust threshold as needed)
                                if (stylizedNeuron.position.distanceTo(spikedPos) < 0.1) {
                                    stylizedNeuron.startFiring();
                                    // break; // Assume one stylized neuron per sim neuron position
                                }
                            }
                        });
                    }

                    // --- Update ongoing firing animations ---
                    // Iterate over all active neurons
                    // Focos on the first stylied neuron
                    controls.target.copy(activeStylizedNeurons[0].position);
                    activeStylizedNeurons.forEach(neuron => {
                        // Random auto-fire trigger if not currently firing
                        if (!neuron.isFiring && Math.random() < AUTO_FIRE_CHANCE) {
                            neuron.startFiring();
                        }

                        // Update the neuron's firing animation
                        neuron.updateFiring(delta);

                        // Optional: Apply a subtle pulsing/breathing effect to the soma and dendrites
                        const pulseFactor = 0.95 + Math.sin(elapsedTime * 1.5) * 0.05;
                        neuron.group.children.forEach(child => {
                            if (child.userData.type === 'soma' || child.userData.type === 'dendrite') {
                                // Apply only if not currently firing (emissive might override)
                                if (!neuron.isFiring || child.userData.type === 'dendrite') {
                                    // child.scale.setScalar(pulseFactor); // Scaling looks weird on tubes
                                    // if (child.material.opacity) { // Add subtle opacity pulse
                                    //     child.material.opacity = originalOpacity * pulseFactor; // Needs storing original opacity
                                    // }
                                }
                            }
                        });
                    });
                }

                // --- End Stylized Neuron Update ---

                // --- 5. Update Other Shader Uniforms (e.g., for point cloud) ---
                if (pointMaterial?.userData?.shader?.uniforms?.time) {
                    pointMaterial.userData.shader.uniforms.time.value = mainClock.getElapsedTime();
                }

                // --- 6. Render Scene ---
                if (composer && bloomPass && bloomPass.enabled) {
                    composer.render();
                } else {
                    renderer.render(scene, camera);
                }
            }


            animate();

            window.addEventListener("resize", () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            function rotateX90() {
                brainGroup.rotateX(Math.PI / 2);
                console.log("Rotated group 90¬∞ on the X axis.");
            }

            function rotateY90() {
                brainGroup.rotateY(Math.PI / 2);
                console.log("Rotated group 90¬∞ on the Y axis.");
            }

            function rotateZ90() {
                brainGroup.rotateZ(Math.PI / 2);
                console.log("Rotated group 90¬∞ on the Z axis.");
            }

            // Axis Flipping
            function flipAxis(axis) {
                if (axis === "x") brainGroup.scale.x *= -1;
                else if (axis === "y") brainGroup.scale.y *= -1;
                else if (axis === "z") brainGroup.scale.z *= -1;
                console.log("Flipped axis:", axis, "New scale:",
                    brainGroup.scale.x.toFixed(1), brainGroup.scale.y.toFixed(1), brainGroup.scale.z.toFixed(1));
            }
            document.getElementById("viewX").addEventListener("click", () => setCameraView("x"));
            document.getElementById("viewY").addEventListener("click", () => setCameraView("y"));
            document.getElementById("viewZ").addEventListener("click", () => setCameraView("z"));
            document.getElementById("resetView").addEventListener("click", () => resetCameraView(true));
            document.getElementById("toggleAxes").addEventListener("click", () => { axesVisible = !axesVisible; axesHelper.visible = axesVisible; });
            document.getElementById("flipX").addEventListener("click", () => flipAxis("x"));
            document.getElementById("flipY").addEventListener("click", () => flipAxis("y"));
            document.getElementById("flipZ").addEventListener("click", () => flipAxis("z"));

            document.getElementById("rotateX90").addEventListener("click", rotateX90);
            document.getElementById("rotateY90").addEventListener("click", rotateY90);
            document.getElementById("rotateZ90").addEventListener("click", rotateZ90);

            document.getElementById("togglePlanes").addEventListener("click", () => toggleReferencePlanes());

            window.addEventListener("keydown", (event) => {
                if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
                const key = event.key.toLowerCase();
                switch (key) {
                    case "x": flipAxis("x"); break;
                    case "y": flipAxis("y"); break;
                    case "z": flipAxis("z"); break;
                    case "1": setCameraView("x"); break;
                    case "2": setCameraView("y"); break;
                    case "3": setCameraView("z"); break;
                    case "r": resetCameraView(true); break;
                    case "p": toggleReferencePlanes(); break;
                    case "a": axesVisible = !axesVisible; axesHelper.visible = axesVisible; break;
                }
            }); // End of keydown event


            /**
             * Custom replacer function for JSON.stringify.
             * This function checks for overly large properties (e.g. typed arrays, metadata)
             * and omits them so that the saved JSON does not become enormous.
             */
            function sceneReplacer(key, value) {
                // Skip large typed arrays.
                if (
                    value instanceof Float32Array ||
                    value instanceof Uint8Array ||
                    value instanceof Uint32Array
                ) {
                    return undefined;
                }
                // Omit common non-essential properties.
                if (key === "uuid" || key === "metadata") {
                    return undefined;
                }
                return value;
            }



            const SAVE_STATE_VERSION = 1.1; // Increment if format changes
            // Save state to file
            /**
         * Gathers the current application state and saves it to a JSON file.
         * @param {function} callback - Optional callback function(success: boolean).
         */
            function saveStateToFile(callback) {
                console.log("Gathering state for saving...");

                // --- Pre-check: Ensure base data is loaded ---
                // We need regionInfoList to save region state.
                // We don't strictly need finalPositions here, but it's a good proxy
                // for whether data has been loaded at all.
                if (!regionInfoList || regionInfoList.length === 0) {
                    alert("Cannot save state: No brain region data loaded.");
                    console.warn("Save aborted: regionInfoList is empty.");
                    if (typeof callback === "function") callback(false);
                    return;
                }

                // --- 1. Gather Visualization State ---
                const vizState = {
                    version: SAVE_STATE_VERSION, // Add version here for context
                    timestamp: new Date().toISOString(), // Add timestamp here
                    camera: {
                        position: camera.position.toArray(),
                        target: controls.target.toArray(),
                        up: camera.up.toArray()
                    },
                    controls: { // Save relevant OrbitControls state
                        autoRotate: controls.autoRotate,
                        // Add others if needed, e.g., zoom level? No, position/target capture this.
                        // Damping factor? Usually static.
                    },
                    guiParams: {}, // Initialize as empty object
                    regionInfoList: regionInfoList
                        .map(r => r ? ({ // Only save essential info per region
                            id: r.id,
                            acronym: r.acronym, // Good for reference, though ID is key
                            colorHex: r.colorHex,
                            visible: r.visible === undefined ? true : r.visible // Handle undefined explicitly
                        }) : null)
                        .filter(r => r !== null), // Remove potential null entries from sparse arrays
                    brainGroupTransform: {
                        scale: brainGroup.scale.toArray(),
                        position: brainGroup.position.toArray(),
                        // rotation: brainGroup.rotation.toArray(), // Only if explicitly rotated
                    },
                    helpers: {
                        axesVisible: axesHelper.visible,
                        planesVisible: planesVisible // Use the global tracker variable
                    }
                };
                // Clone guiParams safely, excluding functions
                for (const key in guiParams) {
                    if (typeof guiParams[key] !== 'function') {
                        vizState.guiParams[key] = guiParams[key];
                    }
                }


                // --- 2. Gather Simulation State ---
                // Use the new method from SimulationManager
                const simState = simulationManager.getSerializableState();


                // --- 3. Gather Animation State ---
                const animState = {
                    keyframes: keyframes.map(kf => ({
                        position: kf.position.toArray(),
                        target: kf.target.toArray()
                    }))
                };


                // --- 4. Gather UI State ---
                const uiState = {
                    manualFlyMode: manualFlyMode,
                    continuousSpikingActive: continuousSpiker.isActive,
                    sidebarHidden: leftSidebar.classList.contains('hidden'),
                    soundSettings: {} // Initialize as empty object
                };
                // Clone soundSettings safely, excluding functions
                for (const key in soundSettings) {
                    if (typeof soundSettings[key] !== 'function') {
                        uiState.soundSettings[key] = soundSettings[key];
                    }
                }


                // --- 5. Combine into Full State Object ---
                const fullState = {
                    // Metadata moved into vizState for this example, but could be top-level
                    // version: SAVE_STATE_VERSION,
                    // timestamp: new Date().toISOString(),
                    visualization: vizState,
                    simulation: simState, // This will be null if sim wasn't initialized
                    animation: animState,
                    ui: uiState
                    // Add identifier for the base dataset if possible? (e.g., original filename hash?)
                    // baseDataIdentifier: dataIdentifier, // Requires tracking this from file load
                };

                // --- 6. Serialize and Download ---
                try {
                    // Use pretty printing (null, 2) for readability of saved file
                    const stateJSON = JSON.stringify(fullState, null, 2);
                    const blob = new Blob([stateJSON], { type: "application/json;charset=utf-8" });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.style.display = "none";
                    a.href = url;
                    // Generate a more descriptive filename
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/[:T]/g, "-");
                    a.download = `mouse_brain_state_${timestamp}.json`;
                    document.body.appendChild(a);
                    a.click(); // Trigger download
                    document.body.removeChild(a); // Clean up link
                    URL.revokeObjectURL(url); // Release blob URL
                    console.log("State saved successfully to file:", a.download);
                    if (typeof callback === "function") callback(true); // Signal success
                } catch (error) {
                    console.error("Error serializing or saving state:", error);
                    alert(`Error saving state: ${error.message}\n(Check console for details)`);
                    if (typeof callback === "function") callback(false); // Signal failure
                }
            }

            /**
          * Loads application state from a selected JSON file.
          * @param {File} file - The JSON file selected by the user.
          * @param {function} callback - Optional callback function(success: boolean).
          */
            function loadStateFromFile(file, callback) {
                console.log("Loading state from file:", file.name);

                // --- Pre-check: Ensure base data is already loaded ---
                // We need finalPositions, finalColors, etc. to exist before applying state.
                // regionInfoList is also essential for matching regions.
                if (!finalPositions || !finalColors || !finalPointRegionIDs || !finalIntensities || !regionInfoList || regionInfoList.length === 0) {
                    alert("Cannot load state: Please load the corresponding brain CSV data first.");
                    console.error("Load aborted: Base visualization data not present.");
                    if (typeof callback === "function") callback(false);
                    return;
                }

                const reader = new FileReader();

                reader.onload = function (event) {
                    let loadedState;
                    try {
                        loadedState = JSON.parse(event.target.result);
                        // Basic validation: Check for top-level keys
                        if (!loadedState || !loadedState.visualization || !loadedState.animation || !loadedState.ui) {
                            throw new Error("Invalid state file format: Missing top-level keys.");
                        }
                        const loadedVersion = loadedState.visualization?.version || loadedState.version || 0; // Allow version at top or in viz
                        console.log(`State file parsed successfully. Format Version: ${loadedVersion}`);

                        // --- Version Check ---
                        if (loadedVersion < SAVE_STATE_VERSION) {
                            console.warn(`Loading state version ${loadedVersion}, which is older than the current version ${SAVE_STATE_VERSION}. Compatibility issues may arise.`);
                            // Add specific migration logic here if needed for older versions
                        } else if (loadedVersion > SAVE_STATE_VERSION) {
                            console.warn(`Loading state version ${loadedVersion}, which is newer than the current version ${SAVE_STATE_VERSION}.`);
                            // Might be incompatible
                        }

                    } catch (e) {
                        console.error("Error parsing state file JSON:", e);
                        alert(`Error reading state file: ${e.message}`);
                        if (typeof callback === "function") callback(false);
                        return;
                    }

                    // --- Apply Loaded State ---
                    try {
                        console.log("Applying loaded state...");

                        // --- Stop current activities BEFORE applying state ---
                        simulationManager.stop();
                        simulationVisuals.dispose(); // Dispose old visuals
                        if (continuousSpiker.isActive) continuousSpiker.stop();
                        stopFlyThrough(); // Stop fly-through if active
                        if (mediaRecorder && mediaRecorder.state !== "inactive") stopRecording(); // Stop recording

                        // --- Restore Visualization State (Order Matters!) ---
                        console.group("Restoring Visualization");
                        if (loadedState.visualization) {
                            const viz = loadedState.visualization;

                            // 1. Apply GUI Params (affects material setup)
                            if (viz.guiParams) {
                                console.log("Applying GUI parameters...");
                                // Only restore parameters that exist in the current guiParams object
                                Object.keys(viz.guiParams).forEach(key => {
                                    if (guiParams.hasOwnProperty(key) && typeof guiParams[key] !== 'function') {
                                        guiParams[key] = viz.guiParams[key];
                                    } else if (!guiParams.hasOwnProperty(key)) {
                                        console.warn(`Saved GUI param "${key}" not found in current application.`);
                                    }
                                });
                                gui.updateDisplay(); // Refresh all GUI controllers
                                // Apply effects of loaded GUI params immediately
                                updateMaterial(); // Applies point size/opacity
                                if (pointMaterial?.userData?.shader) { // Apply shader uniforms
                                    pointMaterial.userData.shader.uniforms.useGrayscale.value = guiParams.useGrayscale;
                                    pointMaterial.userData.shader.uniforms.rawMin.value = guiParams.rawIntensityMin;
                                    pointMaterial.userData.shader.uniforms.rawMax.value = guiParams.rawIntensityMax;
                                    pointMaterial.userData.shader.uniforms.grayContrast.value = guiParams.grayContrast;
                                    console.log(`Shader uniforms updated: Grayscale=${guiParams.useGrayscale}, Min=${guiParams.rawIntensityMin}, Max=${guiParams.rawIntensityMax}, Contrast=${guiParams.grayContrast}`);
                                } else {
                                    console.warn("Point material or shader not found, cannot apply shader uniforms.");
                                }
                                updateRaycasterThreshold(); // Apply point size to raycaster
                                console.log("GUI parameters applied.");
                            }

                            // 2. Apply Region Visibility & Colors
                            if (viz.regionInfoList && regionInfoList) {
                                console.log("Applying region visibility and colors...");
                                const loadedRegionsMap = new Map();
                                viz.regionInfoList.forEach(r => loadedRegionsMap.set(r.id, r));

                                let colorsNeedUpdate = false;
                                let visibilityChanged = false;

                                // Update current regionInfoList based on loaded data
                                regionInfoList.forEach(currentRegion => {
                                    if (!currentRegion) return; // Skip empty slots if any
                                    const loadedRegion = loadedRegionsMap.get(currentRegion.id);
                                    if (loadedRegion) {
                                        // Apply visibility
                                        const newVisibility = loadedRegion.visible === undefined ? true : loadedRegion.visible;
                                        if (currentRegion.visible !== newVisibility) {
                                            currentRegion.visible = newVisibility;
                                            visibilityChanged = true;
                                        }
                                        // Apply color
                                        if (currentRegion.colorHex !== loadedRegion.colorHex) {
                                            currentRegion.colorHex = loadedRegion.colorHex;
                                            const tempColor = new THREE.Color(currentRegion.colorHex); // Use THREE.Color for parsing
                                            currentRegion.r = Math.floor(tempColor.r * 255);
                                            currentRegion.g = Math.floor(tempColor.g * 255);
                                            currentRegion.b = Math.floor(tempColor.b * 255);
                                            colorsNeedUpdate = true;
                                        }
                                    } else {
                                        // Region exists in current data but not in save file?
                                        // Decide default behavior: keep current, or set default?
                                        // Let's default to visible and keep current color.
                                        if (currentRegion.visible !== true) {
                                            currentRegion.visible = true;
                                            visibilityChanged = true;
                                        }
                                        console.warn(`Region ID ${currentRegion.id} (${currentRegion.acronym}) present in base data but not in save file. Setting to visible.`);
                                    }
                                });

                                // Refresh the Region Filter GUI
                                filterAndRebuildRegionGUI();

                                // Apply visibility filter to the points geometry if changes occurred
                                if (visibilityChanged) {
                                    console.log("Updating point visibility...");
                                    updateFilteredPoints();
                                }

                                // If colors changed, update the geometry color buffer directly
                                if (colorsNeedUpdate && geometry && geometry.attributes.color) {
                                    console.log("Updating point colors in buffer...");
                                    const colorAttribute = geometry.attributes.color;
                                    const numPoints = finalPointRegionIDs.length;
                                    let updatedPoints = 0;
                                    for (let i = 0; i < numPoints; i++) {
                                        const regionID = finalPointRegionIDs[i];
                                        // Find the updated region info (could optimize with a map if many regions)
                                        const regionInfo = regionInfoList[regionID]; // Assumes regionInfoList index === ID
                                        if (regionInfo) {
                                            colorAttribute.array[i * 3 + 0] = regionInfo.r;
                                            colorAttribute.array[i * 3 + 1] = regionInfo.g;
                                            colorAttribute.array[i * 3 + 2] = regionInfo.b;
                                            updatedPoints++;
                                        }
                                    }
                                    colorAttribute.needsUpdate = true; // Crucial!
                                    console.log(`Updated colors for ${updatedPoints} points.`);
                                }
                                console.log("Region state applied.");
                            }

                            // 3. Apply Brain Group Transform
                            if (viz.brainGroupTransform) {
                                console.log("Applying brain group transform...");
                                brainGroup.scale.fromArray(viz.brainGroupTransform.scale || [1, 1, 1]);
                                brainGroup.position.fromArray(viz.brainGroupTransform.position || [0, 0, 0]);
                                // brainGroup.rotation.fromArray(viz.brainGroupTransform.rotation || [0, 0, 0]); // Apply if saved
                                console.log(`Scale set to: ${brainGroup.scale.toArray().map(n => n.toFixed(2))}`);
                            }

                            // 4. Apply Helper Visibility
                            if (viz.helpers) {
                                console.log("Applying helper visibility...");
                                axesVisible = viz.helpers.axesVisible === undefined ? true : viz.helpers.axesVisible;
                                axesHelper.visible = axesVisible;
                                planesVisible = viz.helpers.planesVisible === undefined ? false : viz.helpers.planesVisible;
                                if (!referencePlanes && planesVisible) {
                                    // If planes are needed but not built yet (e.g., first load after refresh)
                                    buildReferencePlanes();
                                }
                                if (referencePlanes) {
                                    referencePlanes.visible = planesVisible;
                                }
                                console.log(`Axes: ${axesVisible}, Planes: ${planesVisible}`);
                            }

                            // 5. Apply Controls State (like autoRotate)
                            if (viz.controls) {
                                console.log("Applying controls state...");
                                controls.autoRotate = viz.controls.autoRotate || false;
                                const toggle = document.getElementById("toggleAutoRotate");
                                if (toggle) toggle.checked = controls.autoRotate; // Update UI toggle
                                console.log(`AutoRotate: ${controls.autoRotate}`);
                            }

                            // 6. Apply Camera State (Apply AFTER other transforms/bounds might change)
                            if (viz.camera) {
                                console.log("Applying camera state...");
                                camera.position.fromArray(viz.camera.position);
                                controls.target.fromArray(viz.camera.target);
                                camera.up.fromArray(viz.camera.up || [0, 1, 0]);
                                camera.lookAt(controls.target); // Ensure camera looks at the new target
                                controls.update(); // IMPORTANT: Update controls internal state
                                console.log("Camera position and target updated.");
                            } else {
                                // If no camera state saved, reset the view based on loaded data bounds
                                console.warn("No camera state found in save file. Resetting view.");
                                resetCameraView(true);
                            }
                        } else {
                            console.warn("No 'visualization' section found in state file.");
                            // Reset to defaults? Or leave as is? Let's leave as is for now.
                        }
                        console.groupEnd(); // End Visualization group

                        // --- Restore Simulation State ---
                        console.group("Restoring Simulation");
                        // Dispose existing simulation resources FIRST
                        simulationManager.dispose();
                        simulationVisuals.dispose(); // Ensure visuals are cleared
                        simulationParams.isInitialized = false; // Reset flag

                        if (loadedState.simulation) {
                            console.log("Simulation state found in file. Attempting restore...");
                            const savedSimState = loadedState.simulation;

                            // 1. Apply Simulation Parameters
                            if (savedSimState.params) {
                                console.log("Applying simulation parameters...");
                                // Safely merge loaded params into current simulationParams object
                                Object.keys(savedSimState.params).forEach(key => {
                                    if (simulationParams.hasOwnProperty(key) && typeof simulationParams[key] !== 'function') {
                                        simulationParams[key] = savedSimState.params[key];
                                    } else if (!simulationParams.hasOwnProperty(key)) {
                                        console.warn(`Saved simulation param "${key}" not found in current application.`);
                                    }
                                });
                                // Crucially, restore the initialization and running flags
                                simulationParams.isInitialized = savedSimState.params.isInitialized || false;
                                simulationParams.running = savedSimState.params.running || false;
                                gui.updateDisplay(); // Update dat.GUI with loaded params
                                console.log(`Params applied. isInitialized=${simulationParams.isInitialized}, running=${simulationParams.running}`);
                            } else {
                                console.warn("No simulation parameters found in saved state. Using defaults.");
                                simulationParams.isInitialized = false; // Assume not initialized if params missing
                                simulationParams.running = false;
                            }

                            // 2. Re-initialize Simulation Manager & Visuals *IF* saved state indicates it was initialized
                            if (simulationParams.isInitialized) {
                                console.log("Re-initializing simulation manager based on loaded state...");
                                // --- Re-sample neurons based on CURRENT (loaded) visibility and parameters ---
                                // This step is critical to ensure the loaded dynamic state matches the neuron set.
                                const selectedRegionIDs = regionInfoList.filter(r => r && r.visible).map(r => r.id);
                                let sampledNeuronsData = []; // To hold { position, regionId }

                                if (selectedRegionIDs.length > 0) {
                                    let allNeuronsData = [];
                                    const selectedRegionIDSet = new Set(selectedRegionIDs);
                                    console.log(`Gathering neurons for re-initialization from ${selectedRegionIDs.length} visible regions...`);
                                    for (let i = 0; i < finalPointRegionIDs.length; i++) {
                                        if (selectedRegionIDSet.has(finalPointRegionIDs[i])) {
                                            let pos = new THREE.Vector3(finalPositions[i * 3], finalPositions[i * 3 + 1], finalPositions[i * 3 + 2]);
                                            allNeuronsData.push({ position: pos, regionId: finalPointRegionIDs[i] });
                                        }
                                    }
                                    console.log(`Found ${allNeuronsData.length} potential neurons.`);

                                    // Apply sampling based on loaded params
                                    if (allNeuronsData.length > simulationParams.maxSimNeurons) {
                                        console.log(`Sampling ${simulationParams.maxSimNeurons} neurons...`);
                                        sampledNeuronsData = allNeuronsData.sort(() => 0.5 - Math.random()).slice(0, simulationParams.maxSimNeurons);
                                    } else {
                                        sampledNeuronsData = allNeuronsData;
                                    }
                                } else {
                                    console.warn("No regions visible after loading state. Cannot re-initialize simulation.");
                                    simulationParams.isInitialized = false;
                                    simulationParams.running = false;
                                }
                                // --- End Re-sampling ---

                                if (sampledNeuronsData.length > 0) {
                                    // Now, initialize the manager with the correctly sampled neurons
                                    const initSuccess = simulationManager.initialize(sampledNeuronsData);

                                    if (initSuccess) {
                                        console.log("Simulation manager re-initialized successfully.");
                                        // 3. Load the DYNAMIC state (V, m, h, n, weights, time)
                                        const loadDynamicSuccess = simulationManager.loadState(savedSimState);

                                        if (loadDynamicSuccess) {
                                            // 4. Initialize Visuals with the neurons that have restored state
                                            simulationVisuals.initialize(simulationManager.neurons);
                                            console.log("Simulation dynamic state and visuals restored.");

                                            // 5. Start simulation *only if* loaded state indicates it should be running
                                            if (simulationParams.running) {
                                                console.log("Restarting simulation based on loaded running state.");
                                                simulationManager.start(); // Use the manager's start method
                                            } else {
                                                console.log("Simulation was not running in loaded state.");
                                            }
                                        } else {
                                            console.error("Failed to load simulation dynamic state even after re-initialization. Simulation will remain stopped.");
                                            simulationParams.isInitialized = false; // Mark as failed
                                            simulationParams.running = false;
                                        }
                                    } else {
                                        console.error("Failed to re-initialize simulation manager during load process.");
                                        simulationParams.isInitialized = false;
                                        simulationParams.running = false;
                                    }
                                } else if (simulationParams.isInitialized) {
                                    // If state *said* initialized, but we couldn't find neurons (e.g., all regions hidden)
                                    console.warn("Simulation state indicated initialization, but no neurons were sampled based on current visibility.");
                                    simulationParams.isInitialized = false;
                                    simulationParams.running = false;
                                }
                            } else {
                                console.log("Loaded state indicates simulation was not initialized. Skipping simulation restore.");
                                simulationParams.running = false; // Ensure running is false
                            }
                            // Final check: Update the GUI's running toggle to reflect the final state
                            if (runningController) runningController.updateDisplay();

                        } else {
                            console.log("No simulation state found in the loaded file.");
                            // Ensure sim is marked as not running/initialized
                            simulationParams.running = false;
                            simulationParams.isInitialized = false;
                            if (runningController) runningController.updateDisplay();
                        }
                        console.groupEnd(); // End Simulation group


                        // --- Restore Animation State ---
                        console.group("Restoring Animation");
                        if (loadedState.animation && loadedState.animation.keyframes) {
                            keyframes = loadedState.animation.keyframes.map(kf => ({
                                position: new THREE.Vector3().fromArray(kf.position),
                                target: new THREE.Vector3().fromArray(kf.target)
                            }));
                            console.log(`Restored ${keyframes.length} keyframes.`);
                        } else {
                            keyframes = []; // Clear keyframes if none were saved
                            console.log("No keyframes found or 'animation' section missing. Keyframes cleared.");
                        }
                        console.groupEnd(); // End Animation group


                        // --- Restore UI State ---
                        console.group("Restoring UI");
                        if (loadedState.ui) {
                            const ui = loadedState.ui;

                            // Manual Fly Mode Toggle
                            manualFlyMode = ui.manualFlyMode || false;
                            controls.enabled = !manualFlyMode; // Disable orbit controls if flying
                            const toggleFly = document.getElementById("toggleManualFly");
                            if (toggleFly) toggleFly.checked = manualFlyMode;
                            console.log(`Manual Fly Mode: ${manualFlyMode}`);

                            // Continuous Spiking Toggle
                            // Stop any current first, regardless of loaded state
                            if (continuousSpiker.isActive) continuousSpiker.stop();
                            const toggleSpike = document.getElementById("toggleContinuousSpiking");
                            if (ui.continuousSpikingActive) {
                                // Only *start* if simulation visuals were successfully initialized earlier
                                if (simulationVisuals.isInitialized) {
                                    console.log("Starting continuous spiking based on loaded state.");
                                    continuousSpiker.start();
                                    if (toggleSpike) toggleSpike.checked = true;
                                } else {
                                    console.warn("Continuous spiking was active in save file, but simulation visuals are not ready. Cannot start.");
                                    if (toggleSpike) toggleSpike.checked = false;
                                }
                            } else {
                                console.log("Continuous spiking was not active in loaded state.");
                                if (toggleSpike) toggleSpike.checked = false;
                            }

                            // Sidebar Visibility
                            const sidebarHidden = ui.sidebarHidden || false;
                            if (sidebarHidden !== leftSidebar.classList.contains('hidden')) {
                                // Only toggle if state needs changing
                                leftSidebar.classList.toggle('hidden');
                                toggleSidebarButton.classList.toggle('hidden');
                                // Update arrow icon
                                toggleSidebarButton.innerHTML = sidebarHidden ? "‚ñ∂" : "‚óÄ";
                            }
                            console.log(`Sidebar Hidden: ${sidebarHidden}`);

                            // Sound Settings
                            if (ui.soundSettings) {
                                console.log("Applying sound settings...");
                                Object.keys(ui.soundSettings).forEach(key => {
                                    if (soundSettings.hasOwnProperty(key) && typeof soundSettings[key] !== 'function') {
                                        soundSettings[key] = ui.soundSettings[key];
                                    }
                                });
                                // Update GUI display for sound settings if the folder is open
                                if (gui.__folders && gui.__folders["Sound Settings"]) {
                                    gui.__folders["Sound Settings"].__controllers.forEach(c => c.updateDisplay());
                                }
                                console.log("Sound settings applied.");
                            }
                        } else {
                            console.warn("No 'ui' section found in state file. UI elements retain current state.");
                        }
                        console.groupEnd(); // End UI group


                        console.log("State loaded and applied successfully.");
                        if (typeof callback === "function") callback(true); // Signal success

                    } catch (error) {
                        console.error("Error applying loaded state:", error);
                        alert(`Error applying loaded state: ${error.message}\nApplication might be in an inconsistent state. Check console.`);
                        // Attempt to reset to a safe state? Or just report error?
                        // For now, just report.
                        if (typeof callback === "function") callback(false); // Signal failure
                    }
                }; // end reader.onload

                reader.onerror = function (error) {
                    console.error("Error reading state file:", error);
                    alert(`Error reading file: ${error.message}`);
                    if (typeof callback === "function") callback(false); // Signal failure
                };

                reader.readAsText(file); // Start reading the file
            }

        }); // End of DOMContentLoaded
    </script>

    <!-- Inline Worker Code (CSV Parser with intensity support) -->
    <script id="worker-script" type="text/plain">
    // Worker script: CSV parser with intensity support
    console.log("Worker script execution started.");
    const THREE = {
      Color: class Color {
        constructor(r, g, b) {
          this.isColor = true;
          this.r = 1; this.g = 1; this.b = 1;
          if (g !== undefined && b !== undefined) { this.setRGB(r, g, b); }
          else if (r !== undefined) { this.set(r); }
        }
        set(value) {
          if (value && value.isColor) { this.copy(value); }
          else if (typeof value === "number") { this.setHex(value); }
          else if (typeof value === "string") { this.setStyle(value); }
          return this;
        }
        setHex(hex) {
          hex = Math.floor(hex);
          this.r = ((hex >> 16) & 255) / 255;
          this.g = ((hex >> 8) & 255) / 255;
          this.b = ((hex & 255)) / 255;
          return this;
        }
        setRGB(r, g, b) { this.r = r; this.g = g; this.b = b; return this; }
        setStyle(style) {
          if (/^#([A-Fa-f0-9]{6})$/.test(style)) {
            const hex = parseInt(style.substring(1), 16);
            this.setHex(hex);
          }
          return this;
        }
        copy(color) { this.r = color.r; this.g = color.g; this.b = color.b; return this; }
        getHexString() {
          const r = Math.floor(this.r * 255).toString(16).padStart(2, "0");
          const g = Math.floor(this.g * 255).toString(16).padStart(2, "0");
          const b = Math.floor(this.b * 255).toString(16).padStart(2, "0");
          return r + g + b;
        }
        setHSL(h, s, l) {
          h = ((h % 1) + 1) % 1;
          s = Math.max(0, Math.min(1, s));
          l = Math.max(0, Math.min(1, l));
          if (s === 0) { this.r = this.g = this.b = l; }
          else {
            const hue2rgb = (p, q, t) => {
              if (t < 0) t += 1;
              if (t > 1) t -= 1;
              if (t < 1/6) return p + (q - p) * 6 * t;
              if (t < 1/2) return q;
              if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
              return p;
            };
            const p = l <= 0.5 ? l * (1+s) : l+s-l*s;
            const q = 2*l - p;
            this.r = hue2rgb(q, p, h + 1/3);
            this.g = hue2rgb(q, p, h);
            this.b = hue2rgb(q, p, h - 1/3);
          }
          return this;
        }
      }
    };
    try {
      self.importScripts('https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js');
    } catch (e) {
      self.postMessage({ type: "error", message: "Failed to load PapaParse: " + e });
      throw e;
    }
    const BATCH_SIZE = 1 * 1000 * 1000;
    self.onmessage = function (e) {
      const { file, config } = e.data;
      const RESOLUTION = config.RESOLUTION;
      let batchPositions = [];
      let batchColorsUint8 = [];
      let batchPointRegionIDsList = [];
      let batchIntensities = [];
      let batchPointCounter = 0;
      let totalPointCounter = 0;
      let regionAcronymToId = {};
      let regionInfoList = [];
      let nextRegionID = 0;
      let minX = Infinity, minY = Infinity, minZ = Infinity;
      let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
      let processedRows = 0;
      const estimatedBytesPerRow = 60;
      const estimatedTotalRows = file.size / estimatedBytesPerRow;
      const startTime = performance.now();
      function sendBatch() {
        if (batchPointCounter === 0) return;
        const positionsTyped = new Float32Array(batchPositions);
        const colorsTyped = new Uint8Array(batchColorsUint8);
        const pointRegionIDsTyped = new Uint32Array(batchPointRegionIDsList);
        const intensitiesTyped = new Float32Array(batchIntensities);
        self.postMessage({
          type: "batch_data",
          payload: {
            positions: positionsTyped,
            colors: colorsTyped,
            pointRegionIDs: pointRegionIDsTyped,
            intensities: intensitiesTyped,
            startIndex: totalPointCounter - batchPointCounter
          }
        }, [positionsTyped.buffer, colorsTyped.buffer, pointRegionIDsTyped.buffer, intensitiesTyped.buffer]);
        batchPositions = [];
        batchColorsUint8 = [];
        batchPointRegionIDsList = [];
        batchIntensities = [];
        batchPointCounter = 0;
      }
      Papa.parse(file, {
        header: true,
        skipEmptyLines: true,
        dynamicTyping: false,
        worker: false,
        step: function (results, parser) {
          processedRows++;
          const row = results.data;
          if (!row || typeof row.x !== "string" || typeof row.y !== "string" || typeof row.z !== "string" || typeof row.region_acronym !== "string")
            return;
          const regionAcronym = row.region_acronym.trim();
          if (regionAcronym === "") return;
          const x = Number(row.x.trim());
          const y = Number(row.y.trim());
          const z = Number(row.z.trim());
          if (!isNaN(x) && !isNaN(y) && !isNaN(z) && isFinite(x) && isFinite(y) && isFinite(z)) {
            const scaledX = x * RESOLUTION.x;
            const scaledY = y * RESOLUTION.y;
            const scaledZ = z * RESOLUTION.z;
            batchPositions.push(scaledX, scaledY, scaledZ);
            if (scaledX < minX) minX = scaledX; if (scaledX > maxX) maxX = scaledX;
            if (scaledY < minY) minY = scaledY; if (scaledY > maxY) maxY = scaledY;
            if (scaledZ < minZ) minZ = scaledZ; if (scaledZ > maxZ) maxZ = scaledZ;
            let regionID;
            if (regionAcronymToId[regionAcronym] === undefined) {
              regionID = nextRegionID++;
              regionAcronymToId[regionAcronym] = regionID;
              let hash = 0;
              for (let i = 0; i < regionAcronym.length; i++) {
                hash = regionAcronym.charCodeAt(i) + ((hash << 5) - hash);
                hash = hash & hash;
              }
              const randHue = (parseInt(hash.toString().slice(-5)) % 360) / 360;
              const color = new THREE.Color().setHSL(randHue, 0.6 + Math.random() * 0.3, 0.5 + Math.random() * 0.2);
              const regionFullName = row.region_name && typeof row.region_name === "string" ? row.region_name.trim() : regionAcronym;
              regionInfoList[regionID] = {
                id: regionID,
                acronym: regionAcronym,
                fullName: regionFullName,
                colorHex: "#" + color.getHexString(),
                lowerAcronym: regionAcronym.toLowerCase(),
                lowerFullName: regionFullName.toLowerCase(),
                r: Math.floor(color.r * 255),
                g: Math.floor(color.g * 255),
                b: Math.floor(color.b * 255)
              };
            } else {
              regionID = regionAcronymToId[regionAcronym];
            }
            const regionInfo = regionInfoList[regionID];
            if (regionInfo) {
              batchColorsUint8.push(regionInfo.r, regionInfo.g, regionInfo.b);
              batchPointRegionIDsList.push(regionID);
              let intensity = 1.0;
              if (row.intensity && row.intensity.trim() !== "") intensity = parseFloat(row.intensity);
              batchIntensities.push(intensity);
              batchPointCounter++;
              totalPointCounter++;
              if (batchPointCounter >= BATCH_SIZE) sendBatch();
            }
          }
          if (processedRows % 100000 === 0 && estimatedTotalRows > 0) {
            const progress = Math.round((processedRows / estimatedTotalRows) * 90);
            self.postMessage({ type: "progress", processedRows: processedRows, progress: Math.min(90, progress > 0 ? progress : 0) });
          }
        },
        complete: function () {
          sendBatch();
          const centerX = (minX + maxX) / 2;
          const centerY = (minY + maxY) / 2;
          const centerZ = (minZ + maxZ) / 2;
          const sizeX = maxX - minX;
          const sizeY = maxY - minY;
          const sizeZ = maxZ - minZ;
          const maxSize = Math.max(sizeX, sizeY, sizeZ);
          const bounds = {
            min: { x: minX === Infinity ? 0 : minX, y: minY === Infinity ? 0 : minY, z: minZ === Infinity ? 0 : minZ },
            max: { x: maxX === -Infinity ? 0 : maxX, y: maxY === -Infinity ? 0 : maxY, z: maxZ === -Infinity ? 0 : maxZ },
            center: { x: isNaN(centerX) ? 0 : centerX, y: isNaN(centerY) ? 0 : centerY, z: isNaN(centerZ) ? 0 : centerZ },
            size: isNaN(maxSize) || maxSize <= 0 ? 1000 : maxSize
          };
          self.postMessage({ type: "processing_complete", payload: { regionInfoList: regionInfoList, bounds: bounds, totalPoints: totalPointCounter } });
          const endTime = performance.now();
          console.log("Worker parsing took " + ((endTime - startTime) / 1000).toFixed(2) + " seconds.");
        },
        error: function (error) {
          self.postMessage({ type: "error", message: error.message || "Unknown parsing error" });
        }
      });
    };
    console.log("Worker script execution finished.");
  </script>
</body>

</html>
