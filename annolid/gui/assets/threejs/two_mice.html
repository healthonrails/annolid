<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Annolid: High-Fidelity Mouse Genetics Lab</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

    :root {
      color-scheme: dark;
    }

    html,
    body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #030405;
      font-family: 'Share Tech Mono', monospace;
      user-select: none;
    }

    #c {
      display: block;
      width: 100%;
      height: 100%;
    }

    .overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      background: radial-gradient(circle at 50% 50%, transparent 40%, rgba(0, 0, 0, 0.85) 120%);
      box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.8);
    }

    .hud {
      position: absolute;
      bottom: 40px;
      left: 40px;
      color: rgba(200, 230, 255, 0.9);
      font-size: 13px;
      border-left: 3px solid #00f0ff;
      padding: 15px 20px;
      background: linear-gradient(90deg, rgba(0, 15, 30, 0.85) 0%, rgba(0, 0, 0, 0) 100%);
      backdrop-filter: blur(5px);
      text-transform: uppercase;
      letter-spacing: 1px;
      pointer-events: none;
    }

    .hud h1 {
      margin: 0 0 10px 0;
      font-size: 16px;
      letter-spacing: 3px;
      color: #fff;
      text-shadow: 0 0 10px rgba(0, 240, 255, 0.5);
    }

    .data-row {
      display: flex;
      justify-content: space-between;
      width: 280px;
      margin-bottom: 4px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      padding-bottom: 2px;
    }

    .label {
      color: #6a95b8;
    }

    .val {
      color: #00f0ff;
      font-weight: bold;
    }

    .val.alert {
      color: #ff3366;
      text-shadow: 0 0 8px rgba(255, 51, 102, 0.6);
    }


    .lil-gui {
      --background-color: rgba(0, 15, 30, 0.9);
      --text-color: #00f0ff;
      --title-background-color: #004466;
      --widget-color: #005577;
      --hover-color: #007799;
      --focus-color: #0099bb;
      --font-family: 'Share Tech Mono', monospace;
      border: 1px solid #00f0ff;
      box-shadow: 0 0 20px rgba(0, 240, 255, 0.2);
      right: 20px !important;
      top: 20px !important;
    }
  </style>
</head>

<body>
  <canvas id="c"></canvas>
  <div class="overlay"></div>
  <div class="hud">
    <h1>PRIMARY SUBJECT TELEMETRY</h1>
    <div class="data-row"><span class="label">SUBJECT COUNT</span><span class="val" id="hud-count">0</span></div>
    <div class="data-row"><span class="label">STATE</span><span class="val" id="hud-state">--</span></div>
    <div class="data-row"><span class="label">HEART RATE</span><span class="val alert" id="hud-hr">-- BPM</span></div>
    <div class="data-row"><span class="label">RESPIRATION</span><span class="val" id="hud-resp">-- BPM</span></div>
    <div class="data-row"><span class="label">COORD XZ</span><span class="val" id="hud-coord">0.00, 0.00</span></div>
  </div>

  <script type="module">
    import {
      THREE,
      OrbitControls,
      RoomEnvironment,
      GUI
    } from './annolid_threejs_runtime.js';

    import { AnnolidShaders } from './annolid_shaders.js';

    // ═══════════════════════════════════════════════════════════════
    // 1. CORE RENDERER SETUP
    // ═══════════════════════════════════════════════════════════════
    const canvas = document.querySelector('#c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: "high-performance" });
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.4;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0a0c10, 0.012);

    const camera = new THREE.PerspectiveCamera(35, innerWidth / innerHeight, 0.03, 500);
    camera.position.set(0, 20, 50);

    const controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(0, 1.5, 0);
    controls.maxPolarAngle = Math.PI / 2 - 0.02;

    // IBL environment (True HDR Studio Lighting)
    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    pmremGenerator.compileEquirectangularShader();
    const roomEnvironment = new RoomEnvironment();
    scene.environment = pmremGenerator.fromScene(roomEnvironment).texture;
    roomEnvironment.dispose();

    // ═══════════════════════════════════════════════════════════════
    // 2. PROPORTIONS SYSTEM (ratio-driven placement)
    // ═══════════════════════════════════════════════════════════════
    function defaultProportions() {
      return {
        bodyLength: 3.0, bodyGirthX: 1.50, bodyGirthY: 1.44,
        ribcageDepth: 1.0, waistTaper: 0.64, haunchWidth: 1.00, shoulderWidth: 0.82,
        neckLength: 0.8, neckGirth: 0.55,
        headSize: 0.98, snoutLength: 1.44, snoutWidth: 1.10, cheekFullness: 0.34,
        earSize: 0.85, earSetBack: -0.35, earYaw: 0.75, earThickness: 0.06,
        eyeSize: 0.16, eyeSpacing: 0.50, eyeProtrusion: 1.15, eyeYaw: 0.5,
        foreLimbLength: 1.0, hindLimbLength: 0.78,
        forePawSize: 1.0, hindPawSize: 0.88,
        tailLength: 1.0, tailThickness: 1.0, tailTaper: 0.88, tailSag: 0.02,
      };
    }
    const PROP = defaultProportions();

    // ═══════════════════════════════════════════════════════════════
    // 3. PROCEDURAL CANVAS TEXTURES (micro-normal + roughness)
    // ═══════════════════════════════════════════════════════════════
    function createPadNormalMap(size = 128) {
      const c = document.createElement('canvas'); c.width = c.height = size;
      const ctx = c.getContext('2d');
      ctx.fillStyle = '#8080ff';
      ctx.fillRect(0, 0, size, size);
      // Micro bumps
      for (let i = 0; i < 800; i++) {
        const x = Math.random() * size, y = Math.random() * size;
        const r = 1 + Math.random() * 2;
        const v = 120 + Math.floor(Math.random() * 16);
        ctx.fillStyle = `rgb(${v},${v},255)`;
        ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
      }
      const tex = new THREE.CanvasTexture(c);
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      return tex;
    }
    function createTailRingRoughnessMap(size = 256) {
      const c = document.createElement('canvas'); c.width = size; c.height = size;
      const ctx = c.getContext('2d');
      for (let y = 0; y < size; y++) {
        // More pronounced annular ring segmentation
        const band = Math.sin(y * 0.5) * 0.4 + Math.sin(y * 1.2) * 0.2 + 0.5;
        const v = Math.floor(130 + band * 75);
        ctx.fillStyle = `rgb(${v},${v},${v})`;
        ctx.fillRect(0, y, size, 1);
      }
      // Faint scale-like cross-hatch pattern
      ctx.globalAlpha = 0.08;
      for (let i = 0; i < 60; i++) {
        const y0 = Math.random() * size;
        const x0 = Math.random() * size;
        ctx.strokeStyle = `rgb(${140 + Math.floor(Math.random() * 40)},${140 + Math.floor(Math.random() * 40)},${140 + Math.floor(Math.random() * 40)})`;
        ctx.lineWidth = 0.5 + Math.random();
        ctx.beginPath(); ctx.moveTo(x0, y0); ctx.lineTo(x0 + 8 + Math.random() * 12, y0 + (Math.random() - 0.5) * 4); ctx.stroke();
      }
      ctx.globalAlpha = 1.0;
      const tex = new THREE.CanvasTexture(c);
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      return tex;
    }
    function createEarNormalMap(size = 256) {
      const c = document.createElement('canvas'); c.width = c.height = size;
      const ctx = c.getContext('2d');
      ctx.fillStyle = '#8080ff';
      ctx.fillRect(0, 0, size, size);
      const cx = size * 0.5;
      const cy = size * 0.58;
      const maxR = size * 0.48;
      // Fine cartilage grain
      for (let i = 0; i < 220; i++) {
        const a = Math.random() * Math.PI * 2;
        const r = Math.pow(Math.random(), 0.55) * maxR;
        const x = cx + Math.cos(a) * r;
        const y = cy + Math.sin(a) * r * 0.92;
        const d = Math.hypot(x - cx, y - cy);
        if (d > maxR) continue;
        const h = Math.floor(120 + Math.random() * 25);
        ctx.fillStyle = `rgba(${h},${h},255,0.55)`;
        ctx.beginPath();
        ctx.ellipse(x, y, 1.0 + Math.random() * 2.2, 0.7 + Math.random() * 1.6, a, 0, Math.PI * 2);
        ctx.fill();
      }
      // Subtle radial striations (magnified ear look)
      ctx.lineCap = 'round';
      for (let i = 0; i < 120; i++) {
        const a = -Math.PI * 0.75 + Math.random() * Math.PI * 1.5;
        const r0 = maxR * (0.08 + Math.random() * 0.10);
        const r1 = maxR * (0.55 + Math.random() * 0.40);
        const x0 = cx + Math.cos(a) * r0;
        const y0 = cy + Math.sin(a) * r0 * 0.90;
        const x1 = cx + Math.cos(a) * r1;
        const y1 = cy + Math.sin(a) * r1 * 0.92;
        const dx = Math.cos(a) * (8 + Math.random() * 10);
        const dy = Math.sin(a) * (5 + Math.random() * 9);
        const r = Math.max(98, Math.min(158, 128 + dx));
        const g = Math.max(98, Math.min(158, 128 + dy));
        ctx.strokeStyle = `rgba(${Math.floor(r)},${Math.floor(g)},255,${0.06 + Math.random() * 0.07})`;
        ctx.lineWidth = 0.6 + Math.random() * 1.2;
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        const mx = (x0 + x1) * 0.5 + (Math.random() - 0.5) * 6;
        const my = (y0 + y1) * 0.5 + (Math.random() - 0.5) * 6;
        ctx.quadraticCurveTo(mx, my, x1, y1);
        ctx.stroke();
      }
      const tex = new THREE.CanvasTexture(c);
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      return tex;
    }
    function createEarRoughnessMap(size = 256) {
      const c = document.createElement('canvas'); c.width = c.height = size;
      const ctx = c.getContext('2d');
      const g = ctx.createRadialGradient(size * 0.5, size * 0.55, size * 0.08, size * 0.5, size * 0.55, size * 0.52);
      g.addColorStop(0.0, '#9a9a9a');
      g.addColorStop(0.55, '#b8b8b8');
      g.addColorStop(1.0, '#d0d0d0');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, size, size);
      for (let i = 0; i < 900; i++) {
        const x = Math.random() * size;
        const y = Math.random() * size;
        const v = 140 + Math.floor(Math.random() * 80);
        ctx.fillStyle = `rgb(${v},${v},${v})`;
        ctx.fillRect(x, y, 1, 1);
      }
      const tex = new THREE.CanvasTexture(c);
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      return tex;
    }
    function createEarAlbedoMap(size = 512) {
      const c = document.createElement('canvas'); c.width = c.height = size;
      const ctx = c.getContext('2d');
      const cx = size * 0.5;
      const cy = size * 0.6;
      const maxR = size * 0.48;
      // Warm pinkish base with cooler translucent edges
      const base = ctx.createRadialGradient(cx, cy, size * 0.04, cx, cy, maxR);
      base.addColorStop(0.0, '#f5d0b8');  // warm pink center
      base.addColorStop(0.35, '#f0c5a8');
      base.addColorStop(0.65, '#e8b8a0');
      base.addColorStop(0.85, '#daa890'); // cooler outer
      base.addColorStop(1.0, '#c99882');  // cool rim
      ctx.fillStyle = base;
      ctx.fillRect(0, 0, size, size);
      // Root/base warmth near ear attachment — stronger
      const root = ctx.createRadialGradient(cx, cy + maxR * 0.25, size * 0.04, cx, cy + maxR * 0.30, maxR * 0.60);
      root.addColorStop(0.0, 'rgba(200,130,110,0.18)');
      root.addColorStop(0.5, 'rgba(185,120,100,0.10)');
      root.addColorStop(1.0, 'rgba(170,118,98,0.0)');
      ctx.fillStyle = root;
      ctx.fillRect(0, 0, size, size);
      // PROMINENT VASCULAR NETWORK — main arteries branching from base
      const drawVein = (x0, y0, x1, y1, width, opacity, branches) => {
        ctx.strokeStyle = `rgba(195,110,100,${opacity})`;
        ctx.lineWidth = width;
        ctx.beginPath();
        const mx = (x0 + x1) * 0.5 + (Math.random() - 0.5) * 12;
        const my = (y0 + y1) * 0.5 + (Math.random() - 0.5) * 8;
        ctx.moveTo(x0, y0);
        ctx.quadraticCurveTo(mx, my, x1, y1);
        ctx.stroke();
        // Recursive branching
        if (branches > 0 && width > 0.5) {
          for (let b = 0; b < 2; b++) {
            const bt = 0.5 + Math.random() * 0.4;
            const bx = x0 + (x1 - x0) * bt + (Math.random() - 0.5) * 15;
            const by = y0 + (y1 - y0) * bt + (Math.random() - 0.5) * 15;
            const bx2 = bx + (Math.random() - 0.5) * size * 0.18;
            const by2 = by - Math.random() * size * 0.12;
            drawVein(bx, by, bx2, by2, width * 0.6, opacity * 0.75, branches - 1);
          }
        }
      };
      // Main arteries radiating from ear base
      for (let i = 0; i < 8; i++) {
        const a = -Math.PI * 0.55 + (i / 7) * Math.PI * 1.1;
        const r0 = size * 0.08;
        const r1 = size * 0.38 + Math.random() * size * 0.08;
        const x0 = cx + Math.cos(a) * r0;
        const y0 = cy + Math.sin(a) * r0;
        const x1 = cx + Math.cos(a) * r1;
        const y1 = cy + Math.sin(a) * r1;
        drawVein(x0, y0, x1, y1, 1.4 + Math.random() * 1.2, 0.14 + Math.random() * 0.08, 2);
      }
      // Secondary capillary network — finer veins
      for (let i = 0; i < 20; i++) {
        const a = -Math.PI * 0.70 + Math.random() * Math.PI * 1.4;
        const r0 = size * (0.12 + Math.random() * 0.15);
        const r1 = size * (0.30 + Math.random() * 0.14);
        const x0 = cx + Math.cos(a) * r0;
        const y0 = cy + Math.sin(a) * r0 * 0.94;
        const x1 = cx + Math.cos(a) * r1;
        const y1 = cy + Math.sin(a) * r1 * 0.96;
        ctx.strokeStyle = `rgba(200,140,125,${0.08 + Math.random() * 0.06})`;
        ctx.lineWidth = 0.6 + Math.random() * 0.8;
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        const mx = (x0 + x1) * 0.5 + (Math.random() - 0.5) * 14;
        const my = (y0 + y1) * 0.5 + (Math.random() - 0.5) * 10;
        ctx.quadraticCurveTo(mx, my, x1, y1);
        ctx.stroke();
      }
      // Translucent rim glow (cooler at edges)
      const rim = ctx.createRadialGradient(cx, cy, maxR * 0.75, cx, cy, maxR * 1.05);
      rim.addColorStop(0.0, 'rgba(255,255,255,0.0)');
      rim.addColorStop(0.40, 'rgba(255,245,235,0.0)');
      rim.addColorStop(0.70, 'rgba(240,225,212,0.22)');
      rim.addColorStop(1.0, 'rgba(220,195,175,0.35)');
      ctx.fillStyle = rim;
      ctx.fillRect(0, 0, size, size);
      // Micro mottling for skin texture
      for (let i = 0; i < 1500; i++) {
        const x = Math.random() * size;
        const y = Math.random() * size;
        const v = 200 + Math.floor(Math.random() * 40);
        ctx.fillStyle = `rgba(${v},${v - 15},${v - 25},0.04)`;
        ctx.fillRect(x, y, 1, 1);
      }
      const tex = new THREE.CanvasTexture(c);
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      return tex;
    }
    function createNoseAlbedoMap(size = 256) {
      const c = document.createElement('canvas'); c.width = c.height = size;
      const ctx = c.getContext('2d');
      const cx = size * 0.5;
      const cy = size * 0.55;
      const g = ctx.createRadialGradient(cx, cy, size * 0.03, cx, cy, size * 0.50);
      g.addColorStop(0.0, '#e38f87');
      g.addColorStop(0.42, '#d07e76');
      g.addColorStop(1.0, '#a16861');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, size, size);
      // Warm red wet ring around nostril region.
      const ring = ctx.createRadialGradient(cx, cy, size * 0.06, cx, cy, size * 0.18);
      ring.addColorStop(0.0, 'rgba(140,35,35,0.10)');
      ring.addColorStop(0.55, 'rgba(170,50,50,0.28)');
      ring.addColorStop(1.0, 'rgba(120,30,30,0.0)');
      ctx.fillStyle = ring;
      ctx.fillRect(0, 0, size, size);
      // subtle philtrum tone
      ctx.strokeStyle = 'rgba(165,100,96,0.30)';
      ctx.lineWidth = 2.0;
      ctx.beginPath();
      ctx.moveTo(cx, cy - size * 0.03);
      ctx.quadraticCurveTo(cx + size * 0.01, cy + size * 0.05, cx, cy + size * 0.14);
      ctx.stroke();
      for (let i = 0; i < 350; i++) {
        const x = Math.random() * size;
        const y = Math.random() * size;
        const v = 170 + Math.floor(Math.random() * 40);
        ctx.fillStyle = `rgba(${v},${v - 15},${v - 20},0.12)`;
        ctx.fillRect(x, y, 1, 1);
      }
      const tex = new THREE.CanvasTexture(c);
      tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
      return tex;
    }
    function createNoseNormalMap(size = 256) {
      const c = document.createElement('canvas'); c.width = c.height = size;
      const ctx = c.getContext('2d');
      ctx.fillStyle = '#8080ff';
      ctx.fillRect(0, 0, size, size);
      for (let i = 0; i < 480; i++) {
        const x = Math.random() * size;
        const y = Math.random() * size;
        const v = 120 + Math.floor(Math.random() * 22);
        ctx.fillStyle = `rgb(${v},${v},255)`;
        ctx.beginPath();
        ctx.arc(x, y, 0.4 + Math.random() * 1.0, 0, Math.PI * 2);
        ctx.fill();
      }
      const tex = new THREE.CanvasTexture(c);
      tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
      return tex;
    }
    function createNoseRoughnessMap(size = 256) {
      const c = document.createElement('canvas'); c.width = c.height = size;
      const ctx = c.getContext('2d');
      const g = ctx.createRadialGradient(size * 0.5, size * 0.54, size * 0.03, size * 0.5, size * 0.54, size * 0.52);
      g.addColorStop(0.0, '#666666');
      g.addColorStop(1.0, '#c2c2c2');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, size, size);
      for (let i = 0; i < 900; i++) {
        const x = Math.random() * size;
        const y = Math.random() * size;
        const v = 120 + Math.floor(Math.random() * 90);
        ctx.fillStyle = `rgb(${v},${v},${v})`;
        ctx.fillRect(x, y, 1, 1);
      }
      const tex = new THREE.CanvasTexture(c);
      tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
      return tex;
    }
    const padNormalMap = createPadNormalMap();
    const tailRoughnessMap = createTailRingRoughnessMap();
    const earNormalMap = createEarNormalMap();
    const earRoughnessMap = createEarRoughnessMap();
    const earAlbedoMap = createEarAlbedoMap();
    const noseAlbedoMap = createNoseAlbedoMap();
    const noseNormalMap = createNoseNormalMap();
    const noseRoughnessMap = createNoseRoughnessMap();

    // ═══════════════════════════════════════════════════════════════
    // 4. PBR MATERIALS
    // ═══════════════════════════════════════════════════════════════
    const fleshMatBase = new THREE.MeshPhysicalMaterial({
      roughness: 0.55, transmission: 0.15, thickness: 1.5,
      attenuationDistance: 1.0, clearcoat: 0.1, clearcoatRoughness: 0.2,
      sheen: 1.0, sheenColor: new THREE.Color(0xffeebb),
    });
    const clawMat = new THREE.MeshPhysicalMaterial({
      color: 0xd7cdc2, roughness: 0.15, metalness: 0.05,
      clearcoat: 1.0, clearcoatRoughness: 0.08,
      transmission: 0.08, thickness: 0.3,
      ior: 1.54, // keratin IOR
    });
    // Two-layer eye
    const eyeMat = new THREE.MeshPhysicalMaterial({
      color: 0x020202, roughness: 0.0, metalness: 0.05,
      clearcoat: 1.0, clearcoatRoughness: 0.02, envMapIntensity: 4.0,
      sheen: 0.5, sheenColor: new THREE.Color(0x333344),
    });
    const corneaMat = new THREE.MeshPhysicalMaterial({
      color: 0x000000, transparent: true, opacity: 0.12,
      roughness: 0.0, metalness: 0.0, ior: 1.38,
      clearcoat: 1.0, clearcoatRoughness: 0.0, envMapIntensity: 5.0,
    });

    // ═══════════════════════════════════════════════════════════════
    // 5. DEFORMATION FUNCTIONS
    // ═══════════════════════════════════════════════════════════════
    function deform(geometry, deformFn) {
      const pos = geometry.attributes.position;
      const v = new THREE.Vector3();
      for (let i = 0; i < pos.count; i++) {
        v.fromBufferAttribute(pos, i);
        deformFn(v);
        pos.setXYZ(i, v.x, v.y, v.z);
      }
      geometry.computeVertexNormals();
      return geometry;
    }

    const deformBody = (v) => {
      const zNorm = (v.z + 1) / 2;
      // Side-view profile: rear-dominant body mass with lower shoulders.
      const rearMass = Math.exp(-Math.pow((zNorm - 0.26) / 0.22, 2.0));
      let shoulderDrop = THREE.MathUtils.clamp((zNorm - 0.68) / 0.32, 0, 1);
      shoulderDrop = shoulderDrop * shoulderDrop * (3.0 - 2.0 * shoulderDrop);
      const waistNarrow = Math.exp(-Math.pow((zNorm - 0.56) / 0.14, 2.0));
      // Narrower front torso than rear (asymmetric taper)
      const frontNarrow = THREE.MathUtils.smoothstep(0.60, 0.90, zNorm) * 0.08;
      const lateral = (1.0 + rearMass * 0.28 - shoulderDrop * 0.22 - waistNarrow * (1.0 - PROP.waistTaper) * 0.26 - frontNarrow);
      v.x *= lateral * PROP.bodyGirthX;
      v.y *= (1.0 - zNorm * 0.26) * PROP.bodyGirthY;
      v.z *= PROP.bodyLength;
      // Rounder cross-section so top view does not show a hard flank shelf.
      const sideBlend = THREE.MathUtils.clamp((Math.abs(v.y) - 0.06) / 0.72, 0, 1);
      v.x *= 0.95 + sideBlend * 0.05;

      // Dorsal line: peak around rear-mid, shoulder and tail-base slightly lower.
      const hump = Math.exp(-Math.pow((zNorm - 0.34) / 0.19, 2.0));
      const rump = Math.exp(-Math.pow((zNorm - 0.12) / 0.10, 2.0));
      v.y += hump * 0.38 + rump * 0.16 - shoulderDrop * 0.16;

      // Ventrum: continuous shaping (avoid crease/cut line in top view).
      const yRef = v.y;
      const bellyWidth = Math.exp(-Math.pow((zNorm - 0.52) / 0.30, 2.0));
      const bellyMask = THREE.MathUtils.smoothstep(0.18, -0.65, yRef);
      const bellyInfluence = bellyWidth * bellyMask;
      v.x *= 1.0 + bellyInfluence * 0.16;
      const dropMask = THREE.MathUtils.smoothstep(0.24, -0.22, yRef);
      v.y -= bellyWidth * dropMask * 0.12;

      const lowerBlend = THREE.MathUtils.clamp((0.10 - yRef) / 0.46, 0, 1);
      const groinTuck = Math.exp(-Math.pow((zNorm - 0.18) / 0.15, 2.0)) * 0.10;
      let chestDrop = THREE.MathUtils.clamp((zNorm - 0.72) / 0.28, 0, 1);
      chestDrop = chestDrop * chestDrop * (3.0 - 2.0 * chestDrop) * 0.05;
      const targetY = v.y * 0.76 + groinTuck - chestDrop;
      v.y = THREE.MathUtils.lerp(v.y, targetY, lowerBlend);

      // Subtle scapular and haunch emphasis from side.
      if (zNorm > 0.68 && zNorm < 0.86 && Math.abs(v.x) > 0.26) {
        const scapBulge = 1.0 - Math.abs(zNorm - 0.76) * 10.0;
        if (scapBulge > 0) { v.x *= 1.0 + scapBulge * 0.07; if (v.y > 0) v.y += scapBulge * 0.05; }
      }
      if (zNorm > 0.14 && zNorm < 0.36 && Math.abs(v.x) > 0.26) {
        const hB = 1.0 - Math.abs(zNorm - 0.25) * 6.0;
        if (hB > 0) { v.x *= 1.0 + hB * 0.14; if (v.y < 0) v.y *= 1.0 + hB * 0.08; }
      }

      // Tail base integration: gradual taper into pelvis
      if (zNorm < 0.10) {
        const tailBlend = zNorm / 0.10;
        v.x *= 0.7 + tailBlend * 0.3;
        v.y *= 0.8 + tailBlend * 0.2;
      }

      // Narrow neck root at very front.
      if (zNorm > 0.86) {
        const neckT = (zNorm - 0.86) / 0.14;
        v.x *= 1.0 - neckT * 0.35;
        v.y *= 1.0 - neckT * 0.20;
      }
    };

    const deformHead = (v) => {
      const zNorm = (v.z + 1) / 2;
      const snoutTaper = Math.pow(1.0 - zNorm * 0.46, 1.0);
      v.x *= snoutTaper * PROP.snoutWidth;
      v.y *= snoutTaper * 0.98;
      v.z *= PROP.snoutLength;
      v.y -= zNorm * 0.11;
      // Cheeks
      if (zNorm < 0.55) {
        const cF = (0.55 - zNorm) * PROP.cheekFullness;
        v.x *= 1.0 + cF;
        if (v.y < 0) v.x *= 1.0 + cF * 0.25;
      }
      // Vibrissal pad bulge — fleshy muzzle mass at whisker roots
      if (zNorm > 0.55 && zNorm < 0.78 && Math.abs(v.x) > 0.18) {
        const padBulge = Math.exp(-Math.pow((zNorm - 0.66) / 0.08, 2.0));
        const latBulge = Math.exp(-Math.pow((Math.abs(v.x) - 0.38) / 0.12, 2.0));
        v.x *= 1.0 + padBulge * latBulge * 0.12;
        if (v.y < 0.05) v.y -= padBulge * latBulge * 0.03;
      }
      // Snout wedge with softer, rounder tip.
      if (zNorm > 0.64) {
        const p = (zNorm - 0.64) / 0.36;
        v.x *= 1.0 - p * 0.12;
        v.y *= 1.0 - p * 0.08;
        v.y -= p * 0.02;
        if (v.y < 0) v.x *= 1.0 + p * 0.08;
      }
      if (zNorm > 0.82) {
        const tip = (zNorm - 0.82) / 0.18;
        v.x *= 1.0 + tip * 0.16;
        v.y *= 1.0 + tip * 0.08;
      }
      // Cranium: fuller at back, shallower near frontal region.
      if (zNorm > 0.08 && zNorm < 0.50 && v.y > 0) {
        const dF = 1.0 - Math.abs(zNorm - 0.25) * 2.9;
        v.y += Math.max(0, dF) * 0.26;
      }
      if (zNorm > 0.50 && zNorm < 0.78 && v.y > 0) {
        const frontalDrop = 1.0 - Math.abs(zNorm - 0.64) * 5.5;
        if (frontalDrop > 0) v.y -= frontalDrop * 0.04;
      }
      // Orbital ridges — slightly more prominent for side-view realism
      if (zNorm > 0.32 && zNorm < 0.54 && Math.abs(v.x) > 0.26) {
        v.y += 0.04;
        v.x *= 1.0 + 0.03; // slight lateral orbital bulge
      }
    };

    const deformThigh = (v) => {
      const yN = (v.y + 1) / 2; // 0=bottom(knee), 1=top(hip)
      // Stronger lateral mass with taper toward knee
      v.x *= 0.6 * (0.85 + yN * 0.2);
      v.y *= 1.25;
      v.z *= 1.25 * (0.9 + yN * 0.15);
      v.z -= v.y * 0.3;
      // Gluteal bulge near hip joint for rear-view mass
      const gluteal = Math.exp(-Math.pow((yN - 0.85) / 0.15, 2.0));
      v.x *= 1.0 + gluteal * 0.12;
      if (v.z > 0) v.z += gluteal * 0.04;
    };

    const deformEar = (v) => {
      const y01 = (v.y + 1.0) * 0.5;
      const r = Math.sqrt(v.x * v.x + v.y * v.y);

      // 1. Tall rounded petal shape — narrow base, wide upper body
      v.x *= 1.35;
      v.y *= 1.08;

      // 2. Thin but visible membrane (not paper-flat)
      v.z *= 0.08;

      // 3. Very narrow base where ear attaches to skull
      const baseTaper = THREE.MathUtils.smoothstep(0.0, 0.30, y01);
      v.x *= 0.22 + baseTaper * 0.78;

      // 4. Deep concave bowl curvature — visible cup/scoop shape
      v.z += r * r * 0.28;
      v.z -= (1.0 - r * r) * 0.08;

      // 5. Rounded dome top — softer apex
      if (y01 > 0.78) {
        const blend = (y01 - 0.78) / 0.22;
        const sq = blend * blend;
        v.y *= 1.0 - sq * 0.20;
        v.x *= 1.0 - sq * 0.08;
      }

      // 6. Slight rim thickening for rolled edge
      if (r > 0.78) {
        const rimT = (r - 0.78) / 0.22;
        v.z *= 1.0 + rimT * 1.2;
      }
    };
    function createEarInnerGeometry(depthMul = 1.0) {
      const geo = new THREE.CircleGeometry(1, 56);
      const pos = geo.attributes.position;
      const v = new THREE.Vector3();
      for (let i = 0; i < pos.count; i++) {
        v.fromBufferAttribute(pos, i);
        const r = Math.sqrt(v.x * v.x + v.y * v.y);
        const y01 = (v.y + 1.0) * 0.5;
        const ang = Math.atan2(v.y, v.x);
        const rootTaper = THREE.MathUtils.smoothstep(0.0, 0.30, y01);
        v.x *= 0.30 + rootTaper * 0.70;
        const shoulder = Math.exp(-Math.pow((y01 - 0.72) / 0.18, 2.0));
        v.x *= 1.0 + shoulder * 0.13;
        // Soft concha depression with gentle mouse-like folds.
        v.z = -Math.pow(r, 1.5) * 0.22 * depthMul;
        const ridge = Math.exp(-(v.x * v.x * 2.1 + Math.pow(v.y - 0.24, 2.0) * 3.0));
        v.z += ridge * 0.062 * depthMul;
        const fold = Math.exp(-(Math.pow(v.x - 0.02, 2.0) * 2.8 + Math.pow(v.y + 0.08, 2.0) * 3.4));
        v.z += fold * 0.026 * depthMul;
        v.z += Math.sin(ang * 1.8) * (0.003 + (1.0 - r) * 0.004) * depthMul;
        // Rim thickening so the cavity reads in close-up.
        const rim = THREE.MathUtils.smoothstep(0.70, 0.94, r);
        v.z += rim * 0.020 * Math.min(1.2, depthMul);
        // Small lower-front nub only (avoid human tragus shape).
        const nub = Math.exp(-(Math.pow(v.x + 0.14, 2.0) * 8.0 + Math.pow(v.y + 0.66, 2.0) * 15.0));
        v.z += nub * 0.016 * depthMul;
        if (y01 > 0.80) {
          const tipTaper = 1.0 - (y01 - 0.82) / 0.18;
          v.x *= Math.max(0.94, tipTaper);
          const cap = THREE.MathUtils.smoothstep(0.88, 1.0, y01);
          v.x *= 1.0 + cap * 0.30;
          v.y *= 1.0 - cap * 0.10;
        }
        if (y01 > 0.90) {
          const flatten = (y01 - 0.90) / 0.10;
          v.y -= flatten * 0.04;
        }
        pos.setXYZ(i, v.x, v.y * 0.95, v.z);
      }
      geo.computeVertexNormals();
      return geo;
    }

    // Upper arm / forearm deform
    const deformUpperArm = (v) => {
      // Slight taper from shoulder to elbow
      const t = (v.y + 1) / 2;
      v.x *= 0.7 - t * 0.15;
      v.z *= 0.7 - t * 0.15;
      v.y *= 0.45;
    };

    const bodyGeo = deform(new THREE.SphereGeometry(1, 64, 64), deformBody);
    const headGeo = deform(new THREE.SphereGeometry(1, 48, 48), deformHead);
    const thighGeo = deform(new THREE.SphereGeometry(1, 32, 32), deformThigh);
    const earGeo = deform(new THREE.SphereGeometry(1, 32, 32), deformEar);
    const earInnerGeo = createEarInnerGeometry(1.0);
    const earConchaGeo = createEarInnerGeometry(2.25);


    // ═══════════════════════════════════════════════════════════════
    // 6. PAW BUILDER (anatomically correct forepaw vs hindpaw)
    // ═══════════════════════════════════════════════════════════════
    function createPaw(mat, isFore = false, strain = {}) {
      const paw = new THREE.Group();
      const pawFleshMat = mat.clone();
      pawFleshMat.color.set(strain.pawColor ?? '#e6b0a7');
      pawFleshMat.transmission = 0.22;
      pawFleshMat.thickness = 0.22;
      pawFleshMat.roughness = 0.42;
      pawFleshMat.clearcoat = 0.22;
      pawFleshMat.clearcoatRoughness = 0.28;
      const padMat = mat.clone();
      padMat.color.set(strain.pawPadColor ?? strain.pawColor ?? '#e9b8ae');
      padMat.color.multiplyScalar(strain.padDarken ?? 0.9);
      padMat.transmission = 0.28; padMat.thickness = 0.26;
      padMat.roughness = 0.36; padMat.clearcoat = 0.32; padMat.clearcoatRoughness = 0.18;
      padMat.normalMap = padNormalMap;
      padMat.normalScale = new THREE.Vector2(0.22, 0.22);

      const pawScale = isFore ? (PROP.forePawSize) : (PROP.hindPawSize);

      if (isFore) {
        // Palm pad
        const palm = new THREE.Mesh(new THREE.SphereGeometry(0.08, 16, 16), padMat);
        palm.scale.set(0.95 * pawScale, 0.38, 0.85 * pawScale); // slimmer manipulative shape
        palm.position.set(0, -0.04, 0.05);
        palm.castShadow = true; paw.add(palm);
        // 3 interdigital pads
        for (let p = 0; p < 3; p++) {
          const iPad = new THREE.Mesh(new THREE.SphereGeometry(0.045, 12, 12), padMat);
          iPad.scale.set(1 * pawScale, 0.5, 1 * pawScale);
          iPad.position.set((p - 1) * 0.05 * pawScale, -0.04, 0.0);
          iPad.castShadow = true; paw.add(iPad);
        }
      } else {
        // Hind sole - elongated and slimmer (digitigrade contact strip)
        const sole = new THREE.Mesh(new THREE.SphereGeometry(0.14, 20, 20), padMat);
        sole.scale.set(0.95 * pawScale, 0.32, 1.85 * pawScale);
        sole.position.set(0, -0.045, 0.06);
        sole.castShadow = true; paw.add(sole);
        // Heel pad (small posterior pad)
        const heelPad = new THREE.Mesh(new THREE.SphereGeometry(0.07, 12, 12), padMat);
        heelPad.scale.set(0.95, 0.45, 1.05);
        heelPad.position.set(0, -0.032, -0.16 * pawScale);
        heelPad.castShadow = true; paw.add(heelPad);
        // Mid pad transitions metatarsus to toes.
        const midPad = new THREE.Mesh(new THREE.SphereGeometry(0.07, 12, 12), padMat);
        midPad.scale.set(0.9, 0.4, 1.3);
        midPad.position.set(0, -0.04, 0.14 * pawScale);
        midPad.castShadow = true; paw.add(midPad);
      }

      const pawSpreadMul = strain.pawSpreadMul ?? 1.0;
      const toeCount = isFore ? 4 : 5;
      const baseSpread = isFore ? 0.11 : 0.102;
      const spread = baseSpread * pawSpreadMul * pawScale;

      const clawLocalMat = new THREE.MeshPhysicalMaterial({
        color: strain.clawColor ?? 0xf0e7df, roughness: 0.18, clearcoat: 1.0, clearcoatRoughness: 0.12
      });

      for (let i = 0; i < toeCount; i++) {
        const t = (i - (toeCount - 1) * 0.5) * spread;
        const arc = (Math.abs(i - (toeCount - 1) * 0.5) / (toeCount * 0.5 + 0.01));
        const toe = new THREE.Group();
        let lenMul = 1.0;
        if (isFore && (i === 0 || i === 3)) lenMul = 0.8;
        if (!isFore && (i === 0 || i === 4)) lenMul = 0.75;
        const toeLen = (isFore ? 0.20 : 0.27) * (strain.toeLenMul ?? 1.0) * lenMul * pawScale;
        const p1 = new THREE.Mesh(new THREE.CapsuleGeometry(isFore ? 0.024 : 0.026, toeLen, 10, 10), pawFleshMat);
        p1.rotation.x = Math.PI / 2;
        p1.castShadow = true; toe.add(p1);
        if (isFore) {
          const knuckle = new THREE.Mesh(new THREE.SphereGeometry(0.030, 10, 10), pawFleshMat);
          knuckle.position.set(0, 0.012, -toeLen * 0.35);
          knuckle.castShadow = true; toe.add(knuckle);
          p1.rotation.x = Math.PI / 2 - 0.15;
        } else {
          const knuckle = new THREE.Mesh(new THREE.SphereGeometry(0.028, 10, 10), pawFleshMat);
          knuckle.position.set(0, 0.006, -toeLen * 0.32);
          knuckle.castShadow = true; toe.add(knuckle);
          p1.rotation.x = Math.PI / 2 - 0.26;
        }
        let zPos = isFore ? (0.145 - arc * 0.035) : (0.255 - arc * 0.045);
        zPos *= pawScale;
        toe.position.set(t, isFore ? (-0.035 + arc * 0.012) : (-0.045 + arc * 0.006), zPos);
        // Slight toe splay/curvature
        toe.rotation.y = t * (isFore ? 0.3 : 0.45);
        toe.rotation.x = isFore ? (-0.06 - arc * 0.08) : (-0.18 - arc * 0.07);
        paw.add(toe);
        // Distal fleshy toe tip.
        const toeTip = new THREE.Mesh(new THREE.SphereGeometry(isFore ? 0.020 : 0.022, 10, 10), pawFleshMat);
        toeTip.scale.set(1.25, 0.82, 1.05);
        toeTip.position.set(t, isFore ? (-0.082 + arc * 0.006) : (-0.09 + arc * 0.005), zPos + (isFore ? 0.11 : 0.12) * lenMul);
        toeTip.castShadow = true; paw.add(toeTip);
        const toePad = new THREE.Mesh(new THREE.SphereGeometry(isFore ? 0.035 : 0.045, 10, 10), padMat);
        toePad.scale.set(isFore ? 1.15 : 1.0, isFore ? 0.48 : 0.38, isFore ? 1.0 : 1.1);
        toePad.position.set(t, isFore ? (-0.108 + arc * 0.008) : (-0.102 + arc * 0.004), zPos + (isFore ? 0.08 : 0.088) * lenMul);
        toePad.castShadow = true; paw.add(toePad);
        const clawLength = isFore ? 0.045 : 0.052;
        // Tapered capsule claw instead of cone for more natural keratin shape
        const clawGeo = new THREE.CapsuleGeometry(isFore ? 0.008 : 0.009, clawLength, 6, 6);
        clawGeo.translate(0, -clawLength / 2, 0);
        // Taper the tip via deformation
        deform(clawGeo, (cv) => {
          const yN = (cv.y + clawLength) / clawLength;
          cv.x *= 1.0 - yN * 0.35;
          cv.z *= 1.0 - yN * 0.25;
          cv.z -= yN * 0.005; // slight downward curve
        });
        const claw = new THREE.Mesh(clawGeo, clawLocalMat);
        claw.rotation.x = Math.PI / 2 + (isFore ? -0.22 : -0.16);
        claw.position.set(t, isFore ? (-0.055 + arc * 0.004) : (-0.072 + arc * 0.004), zPos + (isFore ? 0.115 : 0.165) * lenMul * pawScale);
        claw.castShadow = true; paw.add(claw);
      }
      return paw;
    }

    // ═══════════════════════════════════════════════════════════════
    // 7. LIMB CHAIN BUILDERS
    // ═══════════════════════════════════════════════════════════════
    function createForelimbChain(fleshMat, strain, density, furColor, side) {
      const sign = side === 'L' ? 1 : -1;
      const chain = new THREE.Group();
      const fl = PROP.foreLimbLength;
      // Scapula/shoulder anchor — place at shoulder width, slightly below spine
      chain.position.set(sign * 0.76 * PROP.shoulderWidth / 0.85, -0.14, PROP.bodyLength * 0.70);

      // Upper arm (humerus) — substantial visible segment
      const upperArm = new THREE.Group();
      const uaLen = 0.5 * fl;
      const upperArmMesh = new THREE.Mesh(
        new THREE.CapsuleGeometry(0.16, uaLen, 10, 10), fleshMat
      );
      upperArmMesh.position.y = -uaLen * 0.5;
      upperArmMesh.castShadow = true;
      upperArm.add(upperArmMesh);
      upperArm.rotation.x = -0.26;
      // Shoulder joint sphere (visible scapula bump)
      const shoulderJoint = new THREE.Mesh(new THREE.SphereGeometry(0.18, 12, 12), fleshMat);
      shoulderJoint.scale.set(1.1, 0.9, 1.0);
      shoulderJoint.castShadow = true;
      upperArm.add(shoulderJoint);
      chain.add(upperArm);

      // Forearm (radius/ulna) — attached at elbow
      const forearm = new THREE.Group();
      const faLen = 0.45 * fl;
      forearm.position.set(0, -uaLen - 0.01, 0.08);
      // Soft-tissue bridge to avoid segmented look between upper arm and forearm.
      const elbowBridge = new THREE.Mesh(new THREE.CapsuleGeometry(0.125, 0.09, 10, 10), fleshMat);
      elbowBridge.position.set(0, -uaLen * 0.92, 0.03);
      elbowBridge.rotation.x = 0.15;
      elbowBridge.castShadow = true;
      upperArm.add(elbowBridge);
      // Elbow joint
      const elbowJoint = new THREE.Mesh(new THREE.SphereGeometry(0.12, 10, 10), fleshMat);
      elbowJoint.scale.set(1.08, 0.95, 1.0);
      elbowJoint.castShadow = true;
      forearm.add(elbowJoint);
      const forearmMesh = new THREE.Mesh(
        new THREE.CapsuleGeometry(0.11, faLen, 8, 8), fleshMat
      );
      forearmMesh.position.y = -faLen * 0.5;
      forearmMesh.castShadow = true;
      forearm.add(forearmMesh);
      upperArm.add(forearm);

      // Wrist joint
      const wrist = new THREE.Group();
      wrist.position.set(0, -faLen - 0.018, 0.08);
      const wristJoint = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), fleshMat);
      wristJoint.scale.set(1.1, 0.95, 1.05);
      wristJoint.castShadow = true;
      wrist.add(wristJoint);
      const wristCuff = new THREE.Mesh(new THREE.CapsuleGeometry(0.09, 0.08, 8, 8), fleshMat);
      wristCuff.position.set(0, -0.03, 0.02);
      wristCuff.rotation.x = 0.18;
      wristCuff.castShadow = true;
      wrist.add(wristCuff);
      forearm.add(wrist);

      // Paw — sits at bottom of wrist
      const paw = createPaw(fleshMat, true, strain);
      paw.position.set(0, -0.095, 0.055);
      paw.scale.set(1.08, 1.08, 1.08);
      paw.rotation.x = -0.18;
      wrist.add(paw);

      // Short fur on upper arm + forearm
      const furCount = Math.floor(2000 * density);
      if (furCount > 0) {
        const fGeo = new THREE.ConeGeometry(0.006, 0.08, 3);
        fGeo.translate(0, 0.04, 0);
        const fMat = new THREE.MeshPhysicalMaterial({ color: new THREE.Color(furColor), roughness: 0.7, transparent: true, opacity: 0.8 });
        const fInst = new THREE.InstancedMesh(fGeo, fMat, furCount);
        const d = new THREE.Object3D();
        for (let i = 0; i < furCount; i++) {
          const h = (Math.random() - 0.5) * uaLen * 0.9;
          const ang = Math.random() * Math.PI * 2;
          const r = 0.12 + Math.random() * 0.05;
          d.position.set(Math.cos(ang) * r, h, Math.sin(ang) * r);
          const nrm = new THREE.Vector3(Math.cos(ang), 0.3, Math.sin(ang)).normalize();
          d.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), nrm);
          const s = 0.7 + Math.random() * 0.6;
          d.scale.set(s, s, s); d.updateMatrix();
          fInst.setMatrixAt(i, d.matrix);
        }
        upperArmMesh.add(fInst);
      }

      chain._upperArm = upperArm;
      chain._forearm = forearm;
      chain._wrist = wrist;
      chain._paw = paw;
      return chain;
    }

    function createHindlimbChain(fleshMat, strain, density, furColor, side) {
      const sign = side === 'L' ? 1 : -1;
      const chain = new THREE.Group();
      const hl = PROP.hindLimbLength;
      // Hip anchor — at widest haunch point
      chain.position.set(sign * 0.68 * PROP.haunchWidth / 1.2, 0.06, -PROP.bodyLength * 0.35);

      // Hip joint (visible mass)
      const hipJoint = new THREE.Mesh(new THREE.SphereGeometry(0.15, 12, 12), fleshMat);
      hipJoint.scale.set(0.95, 0.80, 1.0); // wider for smoother transition
      hipJoint.castShadow = true;
      chain.add(hipJoint);
      // Soft blend into lower back (wider for smoother pelvis-hip transition)
      const hipBlend = new THREE.Mesh(new THREE.CapsuleGeometry(0.13, 0.26, 10, 10), fleshMat);
      hipBlend.position.set(0, 0.07, -0.03);
      hipBlend.rotation.x = 0.34;
      hipBlend.scale.set(1.14, 0.92, 1.28);
      hipBlend.castShadow = true;
      chain.add(hipBlend);
      // Inboard pelvis bridge to blend hip into torso and avoid detached look.
      const pelvisBridge = new THREE.Mesh(new THREE.CapsuleGeometry(0.11, 0.30, 10, 10), fleshMat);
      pelvisBridge.position.set(-sign * 0.14, 0.08, -0.02);
      pelvisBridge.rotation.z = Math.PI / 2;
      pelvisBridge.rotation.x = 0.16;
      pelvisBridge.scale.set(1.0, 0.88, 1.15);
      pelvisBridge.castShadow = true;
      chain.add(pelvisBridge);
      const hipSkirt = new THREE.Mesh(new THREE.SphereGeometry(0.13, 12, 12), fleshMat);
      hipSkirt.position.set(-sign * 0.10, -0.01, 0.02);
      hipSkirt.scale.set(1.20, 0.82, 1.08);
      hipSkirt.castShadow = true;
      chain.add(hipSkirt);
      // Extra local fur on hip blend to hide seam against back.
      const hipFurCount = Math.floor(5200 * density);
      if (hipFurCount > 0) {
        const hfGeo = new THREE.ConeGeometry(0.006, 0.09, 3);
        hfGeo.translate(0, 0.045, 0);
        const hfMat = new THREE.MeshPhysicalMaterial({
          color: new THREE.Color(furColor), roughness: 0.78, transparent: true, opacity: 0.84
        });
        const hfInst = new THREE.InstancedMesh(hfGeo, hfMat, hipFurCount);
        const hDummy = new THREE.Object3D();
        const hNrm = new THREE.Vector3();
        for (let i = 0; i < hipFurCount; i++) {
          const theta = Math.random() * Math.PI * 2;
          const y = (Math.random() - 0.5) * 1.6;
          hNrm.set(Math.cos(theta) * 0.95, y * 0.48 - 0.12, Math.sin(theta) * 1.1).normalize();
          hDummy.position.set(hNrm.x * 0.16, hNrm.y * 0.18, hNrm.z * 0.17);
          hDummy.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), hNrm);
          const s = 0.72 + Math.random() * 0.55;
          hDummy.scale.set(s, s, s);
          hDummy.updateMatrix();
          hfInst.setMatrixAt(i, hDummy.matrix);
        }
        hipBlend.add(hfInst);
      }

      // Thigh (femur) — enlarged deformed sphere
      const thigh = new THREE.Mesh(thighGeo, fleshMat);
      thigh.position.set(0, -0.08, 0.05);
      thigh.scale.set(0.92, 0.88 * hl, 1.02);
      thigh.castShadow = true;
      chain.add(thigh);
      thigh.add(generateFurLayer(deformThigh, Math.floor(8200 * density), furColor, 0.15, false));

      // Shank (tibia/fibula) — substantial capsule
      const shank = new THREE.Group();
      shank.position.set(0.03 * sign, -0.73 * hl, 0.23);
      thigh.add(shank);

      // Knee joint (visible bump)
      const kneeJoint = new THREE.Mesh(new THREE.SphereGeometry(0.12, 10, 10), fleshMat);
      kneeJoint.position.set(0, 0.05, 0);
      kneeJoint.castShadow = true;
      shank.add(kneeJoint);

      const shankLen = 0.60 * hl;
      const shankMesh = new THREE.Mesh(new THREE.CapsuleGeometry(0.088, shankLen, 8, 8), fleshMat);
      shankMesh.rotation.x = -0.16;
      shankMesh.position.set(0, -shankLen * 0.5, 0.09);
      shankMesh.castShadow = true;
      shank.add(shankMesh);

      // Ankle/heel (digitigrade visible heel rise)
      const ankle = new THREE.Group();
      ankle.position.set(0, -shankLen - 0.06, 0.20);
      shank.add(ankle);

      const ankleJoint = new THREE.Mesh(new THREE.SphereGeometry(0.085, 10, 10), fleshMat);
      ankleJoint.castShadow = true;
      ankle.add(ankleJoint);

      // Heel bone (calcaneus) - visible heel rise
      const heel = new THREE.Mesh(new THREE.SphereGeometry(0.11, 14, 14), fleshMat);
      heel.scale.set(0.82, 1.18, 1.45);
      heel.position.set(0, 0.02, -0.09);
      heel.castShadow = true;
      ankle.add(heel);

      // Metatarsals (connects heel to toes) — angled forward
      const metaLen = 0.36 * PROP.hindPawSize;
      const metaMesh = new THREE.Mesh(new THREE.CapsuleGeometry(0.055, metaLen, 6, 6), fleshMat);
      metaMesh.rotation.x = Math.PI / 2 - 0.22;
      metaMesh.position.set(0, -0.125, 0.18);
      metaMesh.castShadow = true;
      ankle.add(metaMesh);

      // Hindpaw — planted on ground
      const paw = createPaw(fleshMat, false, strain);
      paw.position.set(0, -0.19, 0.31);
      paw.rotation.x = -0.12;
      paw.scale.set(1.08, 1.08, 1.08);
      ankle.add(paw);

      // Baseline crouched posture so underside view reads organic, not columnar.
      chain.rotation.x = -0.08;
      shank.rotation.x = 0.24;
      ankle.rotation.x = -0.10;

      chain._thigh = thigh;
      chain._shank = shank;
      chain._ankle = ankle;
      chain._paw = paw;
      return chain;
    }

    // ═══════════════════════════════════════════════════════════════
    // 8. WHISKERS + FUR (preserved from original with detail-level support)
    // ═══════════════════════════════════════════════════════════════
    function createVolumetricWhiskers(colorHex, isLeft) {
      const group = new THREE.Group();
      const sign = isLeft ? 1 : -1;
      // Mouse mystacial vibrissae: 5 rows (A–E), shorter with directional randomness
      const rows = [
        { y: 0.07, z: 0.06, count: 4, lenBase: 0.95, fanZ: 0.50 },
        { y: 0.03, z: 0.03, count: 4, lenBase: 1.05, fanZ: 0.55 },
        { y: -0.01, z: 0.00, count: 5, lenBase: 1.25, fanZ: 0.65 },
        { y: -0.05, z: -0.02, count: 4, lenBase: 0.95, fanZ: 0.50 },
        { y: -0.09, z: -0.05, count: 3, lenBase: 0.72, fanZ: 0.40 },
      ];
      for (const row of rows) {
        for (let i = 0; i < row.count; i++) {
          const t = row.count > 1 ? i / (row.count - 1) : 0.5;
          const len = row.lenBase * (0.55 + t * 0.55) * (0.85 + Math.random() * 0.30);
          const yJ = (Math.random() - 0.5) * 0.03;
          const droop = -0.08 * t + (Math.random() - 0.5) * 0.08;
          const splayZ = row.fanZ * (0.3 + t * 0.7) + (Math.random() - 0.5) * 0.12;
          const curve = new THREE.QuadraticBezierCurve3(
            new THREE.Vector3(0, row.y + yJ, row.z),
            new THREE.Vector3(sign * (0.55 + t * 0.25), row.y + yJ + droop * 0.4, row.z + splayZ * 0.4),
            new THREE.Vector3(sign * len, row.y + yJ + droop, row.z + splayZ)
          );
          const radius = 0.007 * (1.0 - t * 0.3);
          const mat = new THREE.MeshBasicMaterial({
            color: colorHex, transparent: true, opacity: 0.48 + Math.random() * 0.14
          });
          group.add(new THREE.Mesh(new THREE.TubeGeometry(curve, 8, radius, 5, false), mat));
        }
      }
      return group;
    }

    function generateFurLayer(deformFn, count, colorHex, length, isHead, isUndercoat = false) {
      if (count <= 0) return new THREE.Group();
      const radius = isUndercoat ? 0.025 : 0.016;
      const geo = new THREE.ConeGeometry(radius, length, 4);
      geo.translate(0, length / 2, 0); geo.rotateX(-Math.PI / 2);
      const mat = new THREE.MeshPhysicalMaterial({
        color: colorHex, roughness: isUndercoat ? 0.92 : 0.75,
        clearcoat: isUndercoat ? 0.0 : 0.12,
        sheen: isUndercoat ? 0.7 : 1.2, sheenColor: new THREE.Color(0xffffff),
        sheenRoughness: isUndercoat ? 0.7 : 0.35,
      });
      const inst = new THREE.InstancedMesh(geo, mat, count);
      inst.receiveShadow = true;
      inst.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(count * 3), 3);
      const baseColor = new THREE.Color(colorHex);
      const strandColor = new THREE.Color();
      const dummy = new THREE.Object3D();
      const pos = new THREE.Vector3(), normal = new THREE.Vector3();
      for (let i = 0; i < count; i++) {
        const u = Math.random(), vv = Math.random();
        const theta = u * 2 * Math.PI, phi = Math.acos(2 * vv - 1);
        pos.set(Math.sin(phi) * Math.cos(theta), Math.sin(phi) * Math.sin(theta), Math.cos(phi));
        normal.copy(pos).normalize();
        const preZ = pos.z;
        const preY = pos.y;
        deformFn(pos);
        pos.addScaledVector(normal, isUndercoat ? 0.005 : 0.012);
        let flowDir;
        if (isHead) {
          // Face: fur sweeps toward nose on snout, backward on cranium
          if (preZ > 0.3) flowDir = new THREE.Vector3(normal.x * 0.22, -0.10, -0.72).normalize();
          else flowDir = new THREE.Vector3(normal.x * 0.3, normal.y * 0.2, -1).normalize();
        } else {
          // Body: region-specific fur flow
          const isHaunch = preZ < -0.3;
          const isShoulder = preZ > 0.5;
          const isDorsal = preY > 0.3;
          const isVentral = preY < -0.3;
          const isTailBase = preZ < -0.7;
          if (isTailBase) {
            // Tail base: converge toward tail
            flowDir = new THREE.Vector3(normal.x * 0.15, -0.08, -0.9).normalize();
          } else if (isHaunch) {
            // Haunches: posterior sweep with slight outward fan
            flowDir = new THREE.Vector3(normal.x * 0.6, normal.y * 0.2 - 0.1, -0.8).normalize();
          } else if (isShoulder) {
            // Shoulders: caudal flow with tight body-hugging direction
            flowDir = new THREE.Vector3(normal.x * 0.35, normal.y * 0.15 - 0.12, -0.9).normalize();
          } else if (isDorsal) {
            // Dorsal: follows spine line caudally
            flowDir = new THREE.Vector3(normal.x * 0.2, 0.05, -0.95).normalize();
          } else if (isVentral) {
            // Ventral: fans outward and slightly caudal
            flowDir = new THREE.Vector3(normal.x * 0.7, normal.y * 0.5 - 0.2, -0.6).normalize();
          } else {
            // Flanks: general caudal flow
            flowDir = new THREE.Vector3(normal.x * 0.5, normal.y * 0.3 - 0.15, -1).normalize();
          }
        }
        if (isUndercoat) { flowDir.lerp(new THREE.Vector3(0, 0, -1), 0.3); flowDir.normalize(); }
        dummy.position.copy(pos);
        dummy.lookAt(pos.clone().add(flowDir));
        let scale = 0.5 + Math.random() * 0.7;
        if (isHead && preZ > 0.4) scale *= 0.42;
        if (isHead && preZ > 0.2 && preZ <= 0.4) scale *= 0.6;
        if (!isHead && preZ < -0.6) scale *= 1.25;
        if (isUndercoat) scale = 0.6 + Math.random() * 0.3;
        const jitter = isUndercoat ? 0.15 : 0.08;
        dummy.rotation.x += (Math.random() - 0.5) * jitter;
        dummy.rotation.y += (Math.random() - 0.5) * jitter;
        dummy.scale.set(scale, scale, scale); dummy.updateMatrix();
        inst.setMatrixAt(i, dummy.matrix);
        strandColor.copy(baseColor);
        const hsl = {}; strandColor.getHSL(hsl);
        const lumV = isUndercoat ? 0.06 : 0.08;
        const ventrum = isHead ? 0.0 : THREE.MathUtils.clamp((-preY - 0.18) / 1.05, 0, 1);
        const ventrumBlend = ventrum * ventrum * (3.0 - 2.0 * ventrum);
        const isVeryLight = hsl.l > 0.74;
        const ventrumSatDrop = isVeryLight ? 0.010 : (hsl.l < 0.35 ? 0.020 : 0.040);
        const ventrumLift = isVeryLight
          ? (isUndercoat ? 0.010 : 0.006)
          : (hsl.l < 0.35 ? (isUndercoat ? 0.030 : 0.020) : (isUndercoat ? 0.060 : 0.042));
        strandColor.setHSL(hsl.h + (Math.random() - 0.5) * 0.02,
          Math.max(0, Math.min(1, hsl.s + (Math.random() - 0.5) * 0.05 - ventrumBlend * ventrumSatDrop)),
          Math.max(0, Math.min(1, hsl.l + (Math.random() - 0.5) * lumV + ventrumBlend * ventrumLift)));
        inst.instanceColor.setXYZ(i, strandColor.r, strandColor.g, strandColor.b);
      }
      return inst;
    }

    // Fur detail-level multipliers
    const FUR_DETAIL = { High: 1.0, Med: 0.5, Low: 0.15, Off: 0.0 };

    function generateMultiLayerFur(deformFn, density, furColor, isHead) {
      const group = new THREE.Group();
      if (density <= 0) return group;
      const vellusCount = Math.floor((isHead ? 8000 : 15000) * density);
      const underCount = Math.floor((isHead ? 18000 : 35000) * density);
      const guardCount = Math.floor((isHead ? 20000 : 40000) * density);
      group.add(generateFurLayer(deformFn, vellusCount, furColor, isHead ? 0.03 : 0.05, isHead, true));
      group.add(generateFurLayer(deformFn, underCount, furColor, isHead ? 0.07 : 0.12, isHead, true));
      group.add(generateFurLayer(deformFn, guardCount, furColor, isHead ? 0.14 : 0.24, isHead, false));
      return group;
    }


    // ═══════════════════════════════════════════════════════════════
    // 9. ENCLOSURE + CONTACT SHADOW + POSE CONSTANTS
    // ═══════════════════════════════════════════════════════════════
    const ENCLOSURE_W = 36, ENCLOSURE_H = 9, ENCLOSURE_D = 26, ENCLOSURE_PAD = 1.6;
    const ENCLOSURE_HALF_X = ENCLOSURE_W * 0.5 - ENCLOSURE_PAD;
    const ENCLOSURE_HALF_Z = ENCLOSURE_D * 0.5 - ENCLOSURE_PAD;

    // Contact shadow (soft AO disc under each mouse)
    function createContactShadow() {
      const c = document.createElement('canvas'); c.width = c.height = 64;
      const ctx = c.getContext('2d');
      const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
      grad.addColorStop(0, 'rgba(0,0,0,0.35)');
      grad.addColorStop(0.5, 'rgba(0,0,0,0.15)');
      grad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = grad; ctx.fillRect(0, 0, 64, 64);
      const tex = new THREE.CanvasTexture(c);
      const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, depthWrite: false, depthTest: false });
      const geo = new THREE.PlaneGeometry(5, 4);
      const mesh = new THREE.Mesh(geo, mat);
      mesh.rotation.x = -Math.PI / 2;
      mesh.position.y = 0.02;
      mesh.renderOrder = 5;
      return mesh;
    }

    const POSE_CONNECTIONS = [
      ['snout', 'lear'], ['snout', 'rear'], ['lear', 'neck'], ['rear', 'neck'],
      ['neck', 'spine1'], ['spine1', 'spine2'], ['spine2', 'tailbase'],
      ['neck', 'lforepaw'], ['neck', 'rforepaw'],
      ['spine2', 'lhindpaw'], ['spine2', 'rhindpaw'],
      ['tailbase', 'tailmid'], ['tailmid', 'tailend']
    ];
    const POSE_COLORS = {
      snout: 0xff0055, lear: 0xff5500, rear: 0xff5500, neck: 0x00ffaa,
      spine1: 0x00aaff, spine2: 0x0055ff, tailbase: 0xaa00ff,
      lforepaw: 0xaaff00, rforepaw: 0xaaff00, lhindpaw: 0x00ff00, rhindpaw: 0x00ff00,
      tailmid: 0xff00ff, tailend: 0xff00aa
    };

    // ═══════════════════════════════════════════════════════════════
    // 10. EXPERT MOUSE CLASS (with new anatomy)
    // ═══════════════════════════════════════════════════════════════
    class ExpertMouse {
      constructor(params) {
        this.mesh = new THREE.Group();
        this.timeOffset = Math.random() * 1000;
        this.locomotionTime = 0;
        this.guiParams = params;

        // Physics state
        this.velocity = new THREE.Vector2(0, 0);
        this.force = new THREE.Vector2(0, 0);
        this.heading = new THREE.Vector2(0, 1);
        this.mass = 0.025 + Math.random() * 0.010;
        this.maxSpeed = 8.0 + Math.random() * 3.0;
        this.drag = 2.5;
        this.wanderAngle = Math.random() * Math.PI * 2;
        this.wanderRate = 0.8 + Math.random() * 0.6;
        this.wanderStrength = 2.5 + Math.random() * 1.5;
        this.burstPhase = Math.random() * Math.PI * 2;
        this.speedMult = 0.8 + Math.random() * 0.5;
        this.dir = Math.random() > 0.5 ? 1 : -1;
        this.wallFollowDir = Math.random() > 0.5 ? 1 : -1;
        this.lastPos = new THREE.Vector2(0, 0);
        this.stuckTimer = 0;
        this.lowSpeedTimer = 0;
        this.tailSegLen = 0.22;
        this.rearAmount = 0;
        this.rearVel = 0;
        this.rearCooldown = 0;
        this.prevVelocity = new THREE.Vector2(0, 0);
        this.prevHeadingAngle = Math.atan2(this.heading.x, this.heading.y);
        this.yawAngle = this.prevHeadingAngle;
        this.yawVel = 0;
        this.bodyDyn = { y: 1.3, vy: 0, pitch: 0, pitchV: 0, roll: 0, rollV: 0 };
        this.tailDyn = { sway: 0, swayV: 0, lift: 0, liftV: 0 };

        const furColor = params.furColor;
        const skinColor = params.skinColor;
        const density = FUR_DETAIL[params.furDetailLevel || 'Med'] * (params.furDensity || 0.85);
        const chonk = params.chonkiness;
        const earScaleByHead = THREE.MathUtils.clamp(0.9 + (params.headSize - 1.0) * 0.18, 0.82, 1.08);
        const eSize = params.earSize * earScaleByHead;
        const strain = getStrainProfile(params.presets);

        // Per-instance subtle asymmetry
        this.asymmetry = {
          earTiltL: (Math.random() - 0.5) * 0.06,
          earTiltR: (Math.random() - 0.5) * 0.06,
          earYawDelta: (Math.random() - 0.5) * 0.05,
          earHeightDiff: (Math.random() - 0.5) * 0.03,
          noseYaw: (Math.random() - 0.5) * 0.03,
          haunchDiff: (Math.random() - 0.5) * 0.02,
          eyeOffsetL: (Math.random() - 0.5) * 0.01,
          eyeOffsetR: (Math.random() - 0.5) * 0.01,
        };

        this.motion = {
          gaitAmpMul: strain.gaitAmpMul ?? 1.0,
          headIdleYawMul: strain.headIdleYawMul ?? 1.0,
          headIdlePitchMul: strain.headIdlePitchMul ?? 1.0,
          sniffAmpMul: strain.sniffAmpMul ?? 1.0,
          breathIdleAmp: strain.breathIdleAmp ?? 0.013,
          breathMoveAmp: strain.breathMoveAmp ?? 0.016,
          breathIdleFreq: strain.breathIdleFreq ?? 12.0,
          breathMoveFreq: strain.breathMoveFreq ?? 20.0,
          tailWaveAmpMul: strain.tailWaveAmpMul ?? 1.0,
          tailWaveFreqMul: strain.tailWaveFreqMul ?? 1.0
        };

        // Ear micro-twitch state (independent per ear)
        this.earMicro = {
          twitchTimerL: Math.random() * 3,
          twitchTimerR: Math.random() * 3 + 1.5,
          twitchAngleL: 0, twitchAngleR: 0,
          nextIntervalL: 1.0 + Math.random() * 3.0,
          nextIntervalR: 1.5 + Math.random() * 3.5,
          baseRotL: null, baseRotR: null,
        };

        // Flesh material
        this.fleshMat = fleshMatBase.clone();
        this.fleshMat.color.set(skinColor);
        const skinHSL = {}; this.fleshMat.color.getHSL(skinHSL);
        this.fleshMat.attenuationColor.setHSL(skinHSL.h, skinHSL.s, skinHSL.l * 0.5);

        // ═══ APPLY GLSL SHADERS ═══
        if (params.enableSSS !== false) {
          annolidShaders.applySSSShader(this.fleshMat, {
            scatterColor: [this.fleshMat.color.r * 0.9, this.fleshMat.color.g * 0.9, this.fleshMat.color.b * 0.9],
            thickness: params.sssThickness ?? 0.45,
            distortion: 0.2,
            wrap: params.sssWrap ?? 0.5,
            backlight: params.sssBacklight ?? 0.6
          });
        }
        if (params.enableContactAO !== false) {
          annolidShaders.applyContactAO(this.fleshMat, {
            groundY: 0.0,
            radius: params.aoRadius ?? 1.5,
            intensity: params.aoIntensity ?? 0.35,
            color: [0.02, 0.01, 0.0]
          });
        }
        if (params.enableMicroDetail !== false) {
          annolidShaders.applyMicroDetail(this.fleshMat, {
            scale: params.microScale ?? 40.0,
            strength: params.microStrength ?? 0.06
          });
        }

        // --- RIG HIERARCHY ---
        this.rig = new THREE.Group();
        this.mesh.add(this.rig);

        // BODY
        this.bodyMesh = new THREE.Mesh(bodyGeo, this.fleshMat);
        this.bodyMesh.scale.set(1, chonk, chonk);
        this.bodyMesh.castShadow = true;
        this.rig.add(this.bodyMesh);
        this.bodyMesh.add(generateMultiLayerFur(deformBody, density, furColor, false));

        // NECK
        const neckGeo = new THREE.CapsuleGeometry(PROP.neckGirth, PROP.neckLength, 12, 12);
        const neckMesh = new THREE.Mesh(neckGeo, this.fleshMat);
        neckMesh.position.set(0, 0.08, PROP.bodyLength * 0.79);
        neckMesh.rotation.x = Math.PI / 2 + 0.08;
        neckMesh.scale.set(0.96, 0.95, 0.82);
        neckMesh.castShadow = true;
        this.rig.add(neckMesh);
        // Neck fur
        const neckFurCount = Math.floor(4000 * density);
        if (neckFurCount > 0) {
          const nfGeo = new THREE.ConeGeometry(0.008, 0.12, 3);
          nfGeo.translate(0, 0.06, 0);
          const nfMat = new THREE.MeshPhysicalMaterial({ color: new THREE.Color(furColor), roughness: 0.7, transparent: true, opacity: 0.85 });
          const nfInst = new THREE.InstancedMesh(nfGeo, nfMat, neckFurCount);
          const nkDummy = new THREE.Object3D(), nkNrm = new THREE.Vector3();
          for (let i = 0; i < neckFurCount; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = (Math.random() - 0.5) * Math.PI * 0.8;
            nkNrm.set(Math.cos(theta) * Math.cos(phi) * 0.55, Math.sin(phi) * 0.4, Math.sin(theta) * Math.cos(phi) * 0.55);
            nkDummy.position.copy(nkNrm); nkDummy.position.y += (Math.random() - 0.5) * 0.6;
            nkNrm.normalize();
            nkDummy.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), nkNrm);
            const s = 0.8 + Math.random() * 0.4;
            nkDummy.scale.set(s, s, s); nkDummy.updateMatrix();
            nfInst.setMatrixAt(i, nkDummy.matrix);
          }
          neckMesh.add(nfInst);
        }

        // BELLY FUR ANCHOR (no visible geometry; avoids hard side cut-lines from above)
        const bellyFurAnchor = new THREE.Group();
        bellyFurAnchor.position.set(0, -0.43, PROP.bodyLength * 0.56);
        bellyFurAnchor.rotation.x = Math.PI / 2;
        bellyFurAnchor.scale.set(0.82, 0.76, 0.58);
        this.rig.add(bellyFurAnchor);
        // Add short ventral + flank fur to soften the dorsal/ventral transition.
        const bellyFurCount = Math.floor(7000 * density);
        if (bellyFurCount > 0) {
          const bfGeo = new THREE.ConeGeometry(0.006, 0.09, 3);
          bfGeo.translate(0, 0.045, 0);
          const bfMat = new THREE.MeshPhysicalMaterial({
            color: new THREE.Color(furColor), roughness: 0.76, transparent: true, opacity: 0.82
          });
          const bfInst = new THREE.InstancedMesh(bfGeo, bfMat, bellyFurCount);
          const bDummy = new THREE.Object3D();
          const bNrm = new THREE.Vector3();
          for (let i = 0; i < bellyFurCount; i++) {
            const flank = Math.random() < 0.42;
            const theta = flank
              ? ((Math.random() < 0.5 ? 0 : Math.PI) + (Math.random() - 0.5) * 0.90)
              : (Math.random() * Math.PI * 2);
            const r = Math.pow(Math.random(), 0.70);
            const x = Math.cos(theta) * r * (flank ? 0.30 : 0.24);
            const z = Math.sin(theta) * r * 0.23;
            const y = flank ? (-0.06 + (Math.random() - 0.5) * 0.30) : (-0.18 + (Math.random() - 0.5) * 0.22);
            bDummy.position.set(x, y, z);
            bNrm.set(x, y * 1.35 - 0.06, z).normalize();
            bDummy.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), bNrm);
            const s = 0.65 + Math.random() * 0.45;
            bDummy.scale.set(s, s, s);
            bDummy.updateMatrix();
            bfInst.setMatrixAt(i, bDummy.matrix);
          }
          bellyFurAnchor.add(bfInst);
        }

        // HEAD
        this.headGroup = new THREE.Group();
        this.headGroup.position.set(0, 0.24 * chonk, PROP.bodyLength * 0.96);
        this.rig.add(this.headGroup);

        this.head = new THREE.Mesh(headGeo, this.fleshMat);
        this.head.castShadow = true;
        this.headGroup.add(this.head);
        this.head.add(generateMultiLayerFur(deformHead, density, furColor, true));

        // SNOUT — Anatomically correct rhinarium
        const noseMat = this.fleshMat.clone();
        noseMat.color.set(strain.noseColor ?? skinColor);
        noseMat.map = noseAlbedoMap;
        noseMat.normalMap = noseNormalMap;
        noseMat.normalScale = new THREE.Vector2(0.18, 0.18);
        noseMat.roughnessMap = noseRoughnessMap;
        noseMat.roughness = 0.32;
        noseMat.transmission = 0.14;
        noseMat.thickness = 0.12;
        noseMat.clearcoat = 0.48;
        noseMat.clearcoatRoughness = 0.18;
        // Triangular rhinarium with philtrum groove and alar bulges
        const rhinariumGeo = new THREE.SphereGeometry(0.14, 28, 28);
        deform(rhinariumGeo, (v) => {
          const yN = (v.y + 1) / 2;
          v.x *= 1.10 - yN * 0.24;   // wider bottom = inverted triangle
          v.y *= 0.66;                // flatten vertically
          v.z *= 0.68;
          // Philtrum groove at center front
          if (Math.abs(v.x) < 0.035 && v.z > 0) v.z -= (0.035 - Math.abs(v.x)) * 0.7;
          // Alar bulge around nostril positions
          const nDist = Math.sqrt(Math.pow(Math.abs(v.x) - 0.04, 2) + Math.pow(v.y + 0.02, 2));
          if (nDist < 0.055 && v.z > 0.01) v.z += (0.055 - nDist) * 0.32;
        });
        this.snoutTip = new THREE.Mesh(rhinariumGeo, noseMat);
        this.snoutTip.scale.set(1.06, 0.76, 0.72);
        this.snoutTip.position.set(this.asymmetry.noseYaw * 0.65, -0.158, PROP.snoutLength * 0.99);
        this.head.add(this.snoutTip);
        // Moist tip overlay — wet specular on nose center
        const moistMat = noseMat.clone();
        moistMat.roughness = 0.10; moistMat.clearcoat = 0.88;
        moistMat.clearcoatRoughness = 0.04; moistMat.transmission = 0.05;
        const moistTip = new THREE.Mesh(new THREE.SphereGeometry(0.06, 14, 14), moistMat);
        moistTip.scale.set(1.0, 0.7, 0.55);
        moistTip.position.set(0, 0.012, 0.048);
        this.snoutTip.add(moistTip);
        // Nostrils — forward-facing elongated slits
        const nostrilMat = new THREE.MeshPhysicalMaterial({
          color: 0x2a1210, roughness: 0.82, clearcoat: 0.15, clearcoatRoughness: 0.4
        });
        const nSlitGeo = new THREE.CapsuleGeometry(0.009, 0.016, 8, 8);
        const nL = new THREE.Mesh(nSlitGeo, nostrilMat);
        nL.scale.set(0.80, 1.0, 0.60); nL.rotation.z = 0.35;
        nL.position.set(0.033, -0.008, 0.074); this.snoutTip.add(nL);
        const nR = new THREE.Mesh(nSlitGeo, nostrilMat);
        nR.scale.set(0.80, 1.0, 0.60); nR.rotation.z = -0.35;
        nR.position.set(-0.033, -0.008, 0.074); this.snoutTip.add(nR);
        // Nostril rim moisture rings
        const rimMoistMat = noseMat.clone();
        rimMoistMat.roughness = 0.18; rimMoistMat.clearcoat = 0.65;
        for (const s of [1, -1]) {
          const rim = new THREE.Mesh(new THREE.TorusGeometry(0.013, 0.0035, 8, 12), rimMoistMat);
          rim.position.set(s * 0.033, -0.006, 0.070);
          rim.rotation.y = Math.PI / 2; rim.rotation.z = s * 0.35;
          this.snoutTip.add(rim);
        }
        // Philtrum groove
        const philtrumMat = new THREE.MeshPhysicalMaterial({
          color: 0x3a1d1c, roughness: 0.65, transparent: true, opacity: 0.55
        });
        const philtrum = new THREE.Mesh(new THREE.CapsuleGeometry(0.005, 0.038, 4, 8), philtrumMat);
        philtrum.position.set(0, -0.020, 0.068); this.snoutTip.add(philtrum);
        // Alar bulge accents
        for (const s of [1, -1]) {
          const alar = new THREE.Mesh(new THREE.SphereGeometry(0.020, 12, 12), noseMat);
          alar.scale.set(0.9, 0.60, 0.65);
          alar.position.set(s * 0.040, -0.003, 0.058);
          this.snoutTip.add(alar);
        }

        // MOUTH + INCISORS
        const mouthMat = new THREE.MeshPhysicalMaterial({
          color: 0x7b4b45, roughness: 0.68, metalness: 0.0, clearcoat: 0.08, transparent: true, opacity: 0.94
        });
        this.mouth = new THREE.Mesh(new THREE.CapsuleGeometry(0.042, 0.085, 10, 10), mouthMat);
        this.mouth.rotation.z = Math.PI / 2;
        this.mouth.position.set(0, -0.262, PROP.snoutLength * 0.985);
        this.head.add(this.mouth);
        const lowerLip = new THREE.Mesh(new THREE.SphereGeometry(0.035, 12, 12), this.fleshMat);
        lowerLip.scale.set(1.35, 0.52, 0.72);
        lowerLip.position.set(0, -0.282, PROP.snoutLength * 0.955);
        lowerLip.castShadow = true;
        this.head.add(lowerLip);

        const toothMat = new THREE.MeshPhysicalMaterial({
          color: 0xf5e9cf, roughness: 0.35, metalness: 0.0, clearcoat: 0.35, clearcoatRoughness: 0.2
        });
        const addIncisor = (xSign) => {
          const tooth = new THREE.Mesh(new THREE.BoxGeometry(0.028, 0.07, 0.022), toothMat);
          tooth.position.set(0.02 * xSign, -0.235, PROP.snoutLength * 1.06);
          tooth.rotation.x = -0.22;
          tooth.castShadow = true;
          this.head.add(tooth);
        };
        addIncisor(-1);
        addIncisor(1);

        // WHISKERS
        const wColor = skinHSL.l > 0.5 ? 0xaaaaaa : 0x444444;
        this.padL = new THREE.Group(); this.padL.position.set(0.1, -0.05, 1.1); this.head.add(this.padL);
        this.padR = new THREE.Group(); this.padR.position.set(-0.1, -0.05, 1.1); this.head.add(this.padR);
        this.padL.add(createVolumetricWhiskers(wColor, true));
        this.padR.add(createVolumetricWhiskers(wColor, false));

        // EARS (with asymmetry) — paper-thin translucent pinna
        const earOuterMat = this.fleshMat.clone();
        earOuterMat.color.set(strain.earOuterColor ?? skinColor);
        // Keep ear color close to skin tone
        earOuterMat.color.lerp(new THREE.Color(skinColor), 0.82);
        earOuterMat.transmission = strain.earOuterTransmission ?? 0.52;
        earOuterMat.ior = 1.38;
        earOuterMat.thickness = 0.035; // very thin for translucency
        earOuterMat.roughness = strain.earOuterRoughness ?? 0.48;
        earOuterMat.map = earAlbedoMap;
        earOuterMat.roughnessMap = earRoughnessMap;
        earOuterMat.normalMap = earNormalMap;
        earOuterMat.normalScale = new THREE.Vector2(0.34, 0.28);
        earOuterMat.clearcoat = 0.06; // subtle oil sheen
        earOuterMat.clearcoatRoughness = 0.25;
        earOuterMat.sheen = 0.42;
        earOuterMat.sheenColor = new THREE.Color(0xffd8c0);
        earOuterMat.side = THREE.DoubleSide;
        earOuterMat.attenuationColor = new THREE.Color(0xf0a890);
        earOuterMat.attenuationDistance = 0.3;
        const earInnerMat = this.fleshMat.clone();
        earInnerMat.color.set(strain.earInnerColor ?? strain.earOuterColor ?? skinColor);
        earInnerMat.color.lerp(new THREE.Color(skinColor), 0.78);
        earInnerMat.color.offsetHSL(0.0, strain.earInnerSatOffset ?? 0.06, strain.earInnerLightOffset ?? 0.04);
        earInnerMat.transmission = strain.earInnerTransmission ?? 0.72;
        earInnerMat.ior = 1.38;
        earInnerMat.thickness = 0.025; // even thinner inside
        earInnerMat.roughness = 0.45;
        earInnerMat.map = earAlbedoMap;
        earInnerMat.roughnessMap = earRoughnessMap;
        earInnerMat.normalMap = earNormalMap;
        earInnerMat.normalScale = new THREE.Vector2(0.40, 0.32);
        earInnerMat.clearcoat = 0.04;
        earInnerMat.clearcoatRoughness = 0.22;
        earInnerMat.sheen = 0.55;
        earInnerMat.sheenColor = new THREE.Color(0xffdfc8);
        earInnerMat.side = THREE.DoubleSide;
        earInnerMat.attenuationColor = new THREE.Color(0xf0a890);
        earInnerMat.attenuationDistance = 0.2;

        // Deeper cavity material for internal cup shading.
        const earCavityMat = earInnerMat.clone();
        earCavityMat.color = earCavityMat.color.clone();
        earCavityMat.color.offsetHSL(0.0, -0.01, -0.10);
        earCavityMat.transmission = Math.min(0.22, earInnerMat.transmission);
        earCavityMat.thickness = 0.055;
        earCavityMat.roughness = 0.60;
        earCavityMat.clearcoat = 0.0;

        // Ear size and placement
        const earScale = 1.25;
        const earL = new THREE.Mesh(earGeo, earOuterMat);
        earL.position.set(0.54, 0.50 + (strain.earHeightOffset ?? 0.0) + this.asymmetry.earHeightDiff, PROP.earSetBack - 0.02);
        // Ears stand upright with slight outward tilt
        earL.rotation.set(-0.10 + this.asymmetry.earTiltL, -((strain.earYaw ?? PROP.earYaw) * 0.20 + this.asymmetry.earYawDelta), 0.22);
        earL.scale.set(eSize * earScale, eSize * 0.92 * earScale, eSize * 0.85 * earScale);
        earL.castShadow = true; this.head.add(earL);
        const earLCav = new THREE.Group();
        earLCav.position.set(0, 0.0, 0.02);
        earL.add(earLCav);
        const earLI = new THREE.Mesh(earInnerGeo, earInnerMat);
        earLI.scale.set(0.72, 0.88, 1.0);
        earLI.castShadow = true;
        earLCav.add(earLI);
        const conchaL = new THREE.Mesh(earConchaGeo, earCavityMat);
        conchaL.scale.set(0.55, 0.65, 1.0);
        conchaL.position.set(-0.02, -0.06, -0.06);
        conchaL.rotation.set(0.02, 0.02, -0.01);
        conchaL.castShadow = true;
        earLCav.add(conchaL);

        const earR = new THREE.Mesh(earGeo, earOuterMat);
        earR.position.set(-0.54, 0.50 + (strain.earHeightOffset ?? 0.0) - this.asymmetry.earHeightDiff, PROP.earSetBack - 0.02);
        earR.rotation.set(-0.10 + this.asymmetry.earTiltR, (strain.earYaw ?? PROP.earYaw) * 0.20 + this.asymmetry.earYawDelta, -0.22);
        earR.scale.set(eSize * earScale, eSize * 0.92 * earScale, eSize * 0.85 * earScale);
        earR.castShadow = true; this.head.add(earR);
        const earRCav = new THREE.Group();
        earRCav.position.set(0, 0.0, 0.02);
        earR.add(earRCav);
        const earRI = new THREE.Mesh(earInnerGeo, earInnerMat);
        earRI.scale.set(0.72, 0.88, 1.0);
        earRI.castShadow = true;
        earRCav.add(earRI);
        const conchaR = new THREE.Mesh(earConchaGeo, earCavityMat);
        conchaR.scale.set(0.55, 0.65, 1.0);
        conchaR.position.set(0.02, -0.06, -0.06);
        conchaR.rotation.set(0.02, -0.02, 0.01);
        conchaR.castShadow = true;
        earRCav.add(conchaR);

        // Store ear refs for micro-motion
        this.earL = earL; this.earR = earR;
        this.earMicro.baseRotL = earL.rotation.clone();
        this.earMicro.baseRotR = earR.rotation.clone();

        // EYES (lateral placement with asymmetry, two-layer)
        const eyeL = new THREE.Mesh(new THREE.SphereGeometry(PROP.eyeSize, 20, 20), eyeMat);
        eyeL.scale.set(1.0, 0.95, PROP.eyeProtrusion);
        eyeL.position.set(PROP.eyeSpacing + this.asymmetry.eyeOffsetL, 0.15, PROP.eyeYaw);
        eyeL.castShadow = true; this.head.add(eyeL);
        const cL = new THREE.Mesh(new THREE.SphereGeometry(PROP.eyeSize + 0.005, 20, 20), corneaMat);
        cL.scale.set(1.0, 0.95, PROP.eyeProtrusion + 0.05);
        cL.position.copy(eyeL.position); this.head.add(cL);
        // Tear line highlight
        const tearL = new THREE.Mesh(new THREE.TorusGeometry(PROP.eyeSize * 0.85, 0.008, 6, 16, Math.PI * 0.6),
          new THREE.MeshBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.3 }));
        tearL.position.copy(eyeL.position); tearL.position.y -= 0.02;
        tearL.rotation.y = Math.PI / 2; this.head.add(tearL);

        const eyeR = new THREE.Mesh(new THREE.SphereGeometry(PROP.eyeSize, 20, 20), eyeMat);
        eyeR.scale.set(1.0, 0.95, PROP.eyeProtrusion);
        eyeR.position.set(-PROP.eyeSpacing + this.asymmetry.eyeOffsetR, 0.15, PROP.eyeYaw);
        eyeR.castShadow = true; this.head.add(eyeR);
        const cR = new THREE.Mesh(new THREE.SphereGeometry(PROP.eyeSize + 0.005, 20, 20), corneaMat);
        cR.scale.set(1.0, 0.95, PROP.eyeProtrusion + 0.05);
        cR.position.copy(eyeR.position); this.head.add(cR);
        const tearR = new THREE.Mesh(new THREE.TorusGeometry(PROP.eyeSize * 0.85, 0.008, 6, 16, Math.PI * 0.6),
          new THREE.MeshBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.3 }));
        tearR.position.copy(eyeR.position); tearR.position.y -= 0.02;
        tearR.rotation.y = -Math.PI / 2; this.head.add(tearR);

        // ═══ LIMBS (anatomically correct chains) ═══
        // Hindlimbs
        this.hindL = createHindlimbChain(this.fleshMat, strain, density, furColor, 'L');
        this.rig.add(this.hindL);
        this.hindR = createHindlimbChain(this.fleshMat, strain, density, furColor, 'R');
        this.rig.add(this.hindR);

        // Forelimbs
        this.armL = createForelimbChain(this.fleshMat, strain, density, furColor, 'L');
        this.rig.add(this.armL);
        this.armR = createForelimbChain(this.fleshMat, strain, density, furColor, 'R');
        this.rig.add(this.armR);

        // References for animation
        this.thighL = this.hindL._thigh;
        this.thighR = this.hindR._thigh;
        this.shankL = this.hindL._shank;
        this.shankR = this.hindR._shank;

        // CONTACT SHADOW
        this.contactShadow = createContactShadow();
        this.mesh.add(this.contactShadow);

        // TAIL
        this.tailCount = 45;
        const tailMat = this.fleshMat.clone();
        tailMat.roughness = 0.6; tailMat.transmission = 0.25;
        tailMat.thickness = 0.4; tailMat.clearcoat = 0.15;
        tailMat.roughnessMap = tailRoughnessMap;
        const tGeo = new THREE.CylinderGeometry(0.08, 0.08, 1, 12);
        tGeo.translate(0, 0.5, 0); tGeo.rotateX(Math.PI / 2);
        this.tailInstanced = new THREE.InstancedMesh(tGeo, tailMat, this.tailCount);
        this.tailInstanced.castShadow = true; this.tailInstanced.receiveShadow = true;
        this.mesh.add(this.tailInstanced);
        // Root bridge to blend tail emergence into the rump.
        const tailRootGeo = new THREE.CylinderGeometry(0.11, 0.13, 0.30, 12);
        tailRootGeo.translate(0, 0.15, 0);
        tailRootGeo.rotateX(Math.PI / 2);
        this.tailRoot = new THREE.Mesh(tailRootGeo, tailMat);
        this.tailRoot.castShadow = true;
        this.tailRoot.scale.set(1.0, 0.72, 1.18);
        this.mesh.add(this.tailRoot);
        this.dummy = new THREE.Object3D();

        // POSE TRACKING SKELETON
        this.poseNodes = {};
        this.trackingGroup = new THREE.Group();
        this.mesh.add(this.trackingGroup);

        const createTrackingNode = (id, parent, localPos) => {
          const mat = new THREE.MeshBasicMaterial({
            color: POSE_COLORS[id] || 0xffffff, depthTest: false, transparent: true, opacity: 0.9
          });
          const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.12, 12, 12), mat);
          sphere.renderOrder = 999;
          if (parent) {
            sphere.position.copy(localPos); parent.add(sphere);
            this.poseNodes[id] = sphere;
          } else {
            this.trackingGroup.add(sphere);
            this.poseNodes[id] = sphere;
          }
        };

        // Tracking nodes at anatomical landmarks
        createTrackingNode('snout', this.headGroup, new THREE.Vector3(0, -0.15, PROP.snoutLength * 1.04));
        createTrackingNode('lear', this.headGroup, new THREE.Vector3(0.55, 0.45, -0.15));
        createTrackingNode('rear', this.headGroup, new THREE.Vector3(-0.55, 0.45, -0.15));
        createTrackingNode('neck', this.rig, new THREE.Vector3(0, 0.6, PROP.bodyLength * 0.62));
        createTrackingNode('spine1', this.rig, new THREE.Vector3(0, 0.9, 0.2));
        createTrackingNode('spine2', this.rig, new THREE.Vector3(0, 0.8, -PROP.bodyLength * 0.41));
        createTrackingNode('tailbase', this.rig, new THREE.Vector3(0, 0.3, -PROP.bodyLength * 0.93));
        // Paws attached to limb chains
        createTrackingNode('lforepaw', this.armL._wrist, new THREE.Vector3(0, -0.06, 0.05));
        createTrackingNode('rforepaw', this.armR._wrist, new THREE.Vector3(0, -0.06, 0.05));
        createTrackingNode('lhindpaw', this.hindL._ankle, new THREE.Vector3(0, -0.19, 0.31));
        createTrackingNode('rhindpaw', this.hindR._ankle, new THREE.Vector3(0, -0.19, 0.31));

        this.mesh.updateMatrixWorld(true);
        this.mesh.traverse(child => {
          if (child.isMesh || child.isInstancedMesh) child.frustumCulled = false;
        });

        createTrackingNode('tailmid', null, new THREE.Vector3());
        createTrackingNode('tailend', null, new THREE.Vector3());

        // Skeleton edges
        const lineMat = new THREE.LineBasicMaterial({ color: 0x00ffcc, depthTest: false, transparent: true, opacity: 0.7, linewidth: 2 });
        this.skeletonLines = new THREE.LineSegments(new THREE.BufferGeometry(), lineMat);
        this.skeletonLines.renderOrder = 998;
        this.trackingGroup.add(this.skeletonLines);
        const linePositions = new Float32Array(POSE_CONNECTIONS.length * 6);
        this.skeletonLines.geometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
      }


      update(time, otherMice = [], hudRef = null, dt = 0.016) {
        dt = Math.min(dt, 0.05);
        let t = time * 2.0 * this.speedMult + this.timeOffset;

        // --- FORCE ACCUMULATION ---
        this.force.set(0, 0);
        let burst = Math.sin(t * 1.5 + this.burstPhase);
        burst = 0.7 + 0.3 * Math.max(0, burst);
        const driveStrength = burst * this.guiParams.wanderForce;

        // Thigmotaxis
        const px = this.mesh.position.x, pz = this.mesh.position.z;
        const wallDists = [
          { dist: ENCLOSURE_HALF_X - px, normalX: -1, normalZ: 0, tangentX: 0, tangentZ: 1 },
          { dist: ENCLOSURE_HALF_X + px, normalX: 1, normalZ: 0, tangentX: 0, tangentZ: -1 },
          { dist: ENCLOSURE_HALF_Z - pz, normalX: 0, normalZ: -1, tangentX: -1, tangentZ: 0 },
          { dist: ENCLOSURE_HALF_Z + pz, normalX: 0, normalZ: 1, tangentX: 1, tangentZ: 0 },
        ];
        wallDists.sort((a, b) => a.dist - b.dist);
        const nearest = wallDists[0];
        const wallDist = nearest.dist;
        const wallAttr = this.guiParams.wallAttraction;
        if (wallDist > 2.0 && wallDist < 12.0) {
          const aS = ((wallDist - 2.0) / 12.0) * wallAttr;
          this.force.x += nearest.normalX * aS * driveStrength;
          this.force.y += nearest.normalZ * aS * driveStrength;
        }
        for (const w of wallDists) {
          if (w.dist < 2.0) {
            const pen = (2.0 - w.dist) / 2.0;
            this.force.x -= w.normalX * pen * pen * 50.0;
            this.force.y -= w.normalZ * pen * pen * 50.0;
          }
        }
        const tX = nearest.tangentX * this.wallFollowDir;
        const tZ = nearest.tangentZ * this.wallFollowDir;
        const nwF = Math.max(0, 1.0 - wallDist / 5.0);
        this.force.x += tX * driveStrength * (0.5 + nwF * 1.5);
        this.force.y += tZ * driveStrength * (0.5 + nwF * 1.5);

        if (!guiParams.isPaused) {
          this.force.x += (Math.sin(t * 2.3) * 0.3 + (Math.random() - 0.5) * 0.2) * driveStrength * 0.3;
          this.force.y += (Math.cos(t * 1.7) * 0.3 + (Math.random() - 0.5) * 0.2) * driveStrength * 0.3;
        }

        // Anti-stuck
        if (!guiParams.isPaused) {
          const dxS = px - this.lastPos.x, dzS = pz - this.lastPos.y;
          this.stuckTimer += dt;
          if (this.stuckTimer > 1.0) {
            if (Math.sqrt(dxS * dxS + dzS * dzS) < 0.35) {
              const escape = new THREE.Vector2(
                nearest.tangentX * this.wallFollowDir + nearest.normalX * 0.7,
                nearest.tangentZ * this.wallFollowDir + nearest.normalZ * 0.7
              );
              if (escape.lengthSq() < 1e-6) escape.set(Math.cos(t), Math.sin(t));
              escape.normalize();
              const escapeForce = 30.0 + (wallDist < 1.5 ? 20.0 : 0.0);
              this.force.x += escape.x * escapeForce;
              this.force.y += escape.y * escapeForce;
              this.yawVel *= 0.5;
              this.wallFollowDir *= -1;
            }
            this.lastPos.set(px, pz); this.stuckTimer = 0;
          }
        }

        // Mouse-to-mouse collision
        const MOUSE_RADIUS = 4.0;
        let isColliding = false;
        for (const other of otherMice) {
          if (other === this) continue;
          const dx = this.mesh.position.x - other.mesh.position.x;
          const dz = this.mesh.position.z - other.mesh.position.z;
          const distSq = dx * dx + dz * dz;
          if (distSq < MOUSE_RADIUS * MOUSE_RADIUS && distSq > 0.001) {
            isColliding = true;
            const dist = Math.sqrt(distSq);
            const overlap = MOUSE_RADIUS - dist;
            this.force.x += (dx / dist) * overlap * 40.0;
            this.force.y += (dz / dist) * overlap * 40.0;
            if (overlap > 0) {
              const corr = overlap * 0.5;
              this.mesh.position.x += (dx / dist) * corr;
              this.mesh.position.z += (dz / dist) * corr;
              other.mesh.position.x -= (dx / dist) * corr;
              other.mesh.position.z -= (dz / dist) * corr;
            }
          }
        }

        const preSpeed = this.velocity.length();

        // Cruise assist: keep mice from decaying to full stop after startup.
        if (!guiParams.isPaused) {
          const cruiseTarget = Math.max(this.guiParams.maxSpeed * 0.30, 1.8);
          if (preSpeed < cruiseTarget) {
            const deficit = (cruiseTarget - preSpeed) / Math.max(cruiseTarget, 1e-3);
            const cruiseDir = this.heading.lengthSq() > 1e-6
              ? this.heading.clone().normalize()
              : new THREE.Vector2(Math.cos(t), Math.sin(t)).normalize();
            const cruiseBoost = (this.guiParams.wanderForce * 5.0 + 10.0) * deficit;
            this.force.x += cruiseDir.x * cruiseBoost;
            this.force.y += cruiseDir.y * cruiseBoost;
          }
        }

        // Drag (lighter at very low speed so movement does not stall).
        const dragC = this.guiParams.dragCoeff * (preSpeed < 1.0 ? 0.45 : 1.0);
        this.force.x -= this.velocity.x * dragC;
        this.force.y -= this.velocity.y * dragC;

        // Low-speed rescue: inject motion if the mouse lingers too long.
        if (!guiParams.isPaused) {
          if (preSpeed < 0.8) this.lowSpeedTimer += dt;
          else this.lowSpeedTimer = Math.max(0, this.lowSpeedTimer - dt * 0.5);
          if (this.lowSpeedTimer > 1.0) {
            const rescueDir = new THREE.Vector2(
              nearest.tangentX * this.wallFollowDir + nearest.normalX * 0.6,
              nearest.tangentZ * this.wallFollowDir + nearest.normalZ * 0.6
            );
            if (rescueDir.lengthSq() < 1e-6) {
              if (this.heading.lengthSq() > 1e-6) rescueDir.copy(this.heading);
              else rescueDir.set(Math.cos(t), Math.sin(t));
            }
            rescueDir.normalize();
            const kickMag = 32.0;
            this.force.x += rescueDir.x * kickMag;
            this.force.y += rescueDir.y * kickMag;
            this.lowSpeedTimer = 0;
          }
        }

        // Integration
        if (!guiParams.isPaused) {
          const ax = this.force.x / (this.mass * 1000);
          const az = this.force.y / (this.mass * 1000);
          this.velocity.x += ax * dt; this.velocity.y += az * dt;
          const uMS = this.guiParams.maxSpeed;
          const cS = this.velocity.length();
          if (cS > uMS) this.velocity.multiplyScalar(uMS / cS);
          this.mesh.position.x += this.velocity.x * dt;
          this.mesh.position.z += this.velocity.y * dt;
          this.locomotionTime += cS * dt;
        }

        // Hard boundary clamp with tangent turn selection (avoid wall-sticking).
        let hitWall = false;
        let hitXWall = false;
        let hitZWall = false;
        // Keep full body+head away from walls (not just the body center point).
        const HM = Math.max(3.8, 3.2 * this.guiParams.bodyLength + 0.9 * this.guiParams.snoutLength);
        if (this.mesh.position.x > ENCLOSURE_HALF_X - HM) { this.mesh.position.x = ENCLOSURE_HALF_X - HM; this.velocity.x = -Math.abs(this.velocity.x) * 0.25; hitWall = true; hitXWall = true; }
        if (this.mesh.position.x < -ENCLOSURE_HALF_X + HM) { this.mesh.position.x = -ENCLOSURE_HALF_X + HM; this.velocity.x = Math.abs(this.velocity.x) * 0.25; hitWall = true; hitXWall = true; }
        if (this.mesh.position.z > ENCLOSURE_HALF_Z - HM) { this.mesh.position.z = ENCLOSURE_HALF_Z - HM; this.velocity.y = -Math.abs(this.velocity.y) * 0.25; hitWall = true; hitZWall = true; }
        if (this.mesh.position.z < -ENCLOSURE_HALF_Z + HM) { this.mesh.position.z = -ENCLOSURE_HALF_Z + HM; this.velocity.y = Math.abs(this.velocity.y) * 0.25; hitWall = true; hitZWall = true; }
        if (hitWall) {
          const minTurnSpeed = Math.max(this.guiParams.maxSpeed * 0.45, 2.2);
          const clearPosX = ENCLOSURE_HALF_X - this.mesh.position.x;
          const clearNegX = ENCLOSURE_HALF_X + this.mesh.position.x;
          const clearPosZ = ENCLOSURE_HALF_Z - this.mesh.position.z;
          const clearNegZ = ENCLOSURE_HALF_Z + this.mesh.position.z;
          if (hitXWall && !hitZWall) {
            const turnSignZ = clearPosZ >= clearNegZ ? 1 : -1;
            this.velocity.y = turnSignZ * Math.max(Math.abs(this.velocity.y), minTurnSpeed);
            this.wallFollowDir = turnSignZ;
          } else if (hitZWall && !hitXWall) {
            const turnSignX = clearPosX >= clearNegX ? 1 : -1;
            this.velocity.x = turnSignX * Math.max(Math.abs(this.velocity.x), minTurnSpeed);
            this.wallFollowDir = turnSignX;
          } else {
            // Corner: choose axis with more free space.
            if (Math.max(clearPosX, clearNegX) >= Math.max(clearPosZ, clearNegZ)) {
              const turnSignX = clearPosX >= clearNegX ? 1 : -1;
              this.velocity.x = turnSignX * minTurnSpeed;
            } else {
              const turnSignZ = clearPosZ >= clearNegZ ? 1 : -1;
              this.velocity.y = turnSignZ * minTurnSpeed;
            }
            this.wallFollowDir *= -1;
          }
          // Heading will reorient through angular inertia below.
        }
        if (!guiParams.isPaused) {
          this.rearCooldown = Math.max(0, this.rearCooldown - dt);
          const impactNorm = Math.min(this.velocity.length() / Math.max(this.guiParams.maxSpeed, 1e-3), 1.0);
          if (hitWall && impactNorm > 0.14 && this.rearCooldown <= 0) {
            this.rearVel += 2.0 + impactNorm * 1.8;
            this.rearCooldown = 0.7;
          }
          // Damped spring so rearing rises quickly and settles smoothly.
          this.rearVel += (-18.0 * this.rearAmount - 7.5 * this.rearVel) * dt;
          this.rearAmount = THREE.MathUtils.clamp(this.rearAmount + this.rearVel * dt, 0, 1);
          if (this.rearAmount < 1e-3 && this.rearVel < 1e-3) {
            this.rearAmount = 0;
            this.rearVel = 0;
          }
        }

        // Heading
        const speed = this.velocity.length();
        let isMoving = speed > 0.3;
        if (!guiParams.isPaused) {
          let targetYaw = this.yawAngle;
          if (isMoving) {
            targetYaw = Math.atan2(this.velocity.x, this.velocity.y);
          } else if (this.force.lengthSq() > 1e-6) {
            targetYaw = Math.atan2(this.force.x, this.force.y);
          }
          let yawErr = targetYaw - this.yawAngle;
          if (yawErr > Math.PI) yawErr -= Math.PI * 2;
          if (yawErr < -Math.PI) yawErr += Math.PI * 2;
          const yawK = isColliding ? 18.0 : 12.0;
          const yawD = 7.0;
          this.yawVel += (yawK * yawErr - yawD * this.yawVel) * dt;
          const maxYawRate = isColliding ? 2.8 : 2.2;
          this.yawVel = THREE.MathUtils.clamp(this.yawVel, -maxYawRate, maxYawRate);
          this.yawAngle += this.yawVel * dt;
        }
        this.heading.set(Math.sin(this.yawAngle), Math.cos(this.yawAngle));
        this.mesh.rotation.y = this.yawAngle;

        if (hudRef) {
          hudRef.state.innerText = isMoving ? "SCURRYING // AVOIDANCE" : "ALERT // SNIFFING";
          hudRef.state.style.color = isMoving ? "#00f0ff" : "#ffcc00";
          hudRef.hr.innerText = isMoving ? "540 BPM" : "410 BPM";
          hudRef.resp.innerText = isMoving ? "210 BPM" : (160 + Math.floor(Math.random() * 10)) + " BPM";
          hudRef.coord.innerText = `${this.mesh.position.x.toFixed(2)}, ${this.mesh.position.z.toFixed(2)}`;
        }

        // Body + tail dynamics (gravity + inertia)
        const speedNorm = Math.min(speed / this.maxSpeed, 1.0);
        const invDt = 1.0 / Math.max(dt, 1e-4);
        const accelX = (this.velocity.x - this.prevVelocity.x) * invDt;
        const accelZ = (this.velocity.y - this.prevVelocity.y) * invDt;
        const forwardAccel = accelX * this.heading.x + accelZ * this.heading.y;
        const lateralAccel = accelX * (-this.heading.y) + accelZ * this.heading.x;
        const headingAngle = Math.atan2(this.heading.x, this.heading.y);
        let headingDelta = headingAngle - this.prevHeadingAngle;
        if (headingDelta > Math.PI) headingDelta -= Math.PI * 2;
        if (headingDelta < -Math.PI) headingDelta += Math.PI * 2;
        const turnRate = headingDelta * invDt;
        this.prevHeadingAngle = headingAngle;

        if (!guiParams.isPaused) {
          // Vertical body suspension with gravity.
          const targetBodyY = 1.26 + speedNorm * 0.10;
          const bodyK = 24.0, bodyD = 8.0, gravity = 3.4;
          this.bodyDyn.vy += (bodyK * (targetBodyY - this.bodyDyn.y) - bodyD * this.bodyDyn.vy - gravity) * dt;
          this.bodyDyn.y += this.bodyDyn.vy * dt;
          if (this.bodyDyn.y < 1.12) {
            this.bodyDyn.y = 1.12;
            this.bodyDyn.vy = Math.max(0, this.bodyDyn.vy) * 0.2;
          }

          // Pitch/roll inertia from accel and turning.
          const targetPitch = THREE.MathUtils.clamp(-forwardAccel * 0.015 + speedNorm * 0.02, -0.16, 0.16);
          const targetRoll = THREE.MathUtils.clamp(-lateralAccel * 0.02 - turnRate * 0.01, -0.20, 0.20);
          const angK = 18.0, angD = 6.5;
          this.bodyDyn.pitchV += (angK * (targetPitch - this.bodyDyn.pitch) - angD * this.bodyDyn.pitchV) * dt;
          this.bodyDyn.rollV += (angK * (targetRoll - this.bodyDyn.roll) - angD * this.bodyDyn.rollV) * dt;
          this.bodyDyn.pitch += this.bodyDyn.pitchV * dt;
          this.bodyDyn.roll += this.bodyDyn.rollV * dt;

          // Tail inertial follow-through.
          const targetTailSway = THREE.MathUtils.clamp(-turnRate * 0.06 - lateralAccel * 0.01, -0.9, 0.9);
          const targetTailLift = THREE.MathUtils.clamp(-0.05 - forwardAccel * 0.004 + speedNorm * 0.03, -0.18, 0.08);
          const tailK = 14.0, tailD = 4.8;
          this.tailDyn.swayV += (tailK * (targetTailSway - this.tailDyn.sway) - tailD * this.tailDyn.swayV) * dt;
          this.tailDyn.liftV += (tailK * (targetTailLift - this.tailDyn.lift) - tailD * this.tailDyn.liftV) * dt;
          this.tailDyn.sway += this.tailDyn.swayV * dt;
          this.tailDyn.lift += this.tailDyn.liftV * dt;
          if (speed < 0.45 && this.lowSpeedTimer > 0.6) {
            // Calm tiny oscillations while nearly stationary.
            const calm = Math.exp(-8.0 * dt);
            this.tailDyn.sway *= calm;
            this.tailDyn.lift *= calm;
            this.tailDyn.swayV *= calm;
            this.tailDyn.liftV *= calm;
          }
        }

        this.rig.position.y = this.bodyDyn.y;
        this.rig.rotation.x = this.bodyDyn.pitch;
        this.rig.rotation.z = this.bodyDyn.roll;

        // Contact shadow follows mouse on ground
        this.contactShadow.position.set(0, -this.rig.position.y + 0.02, 0);

        // ═══ GAIT ANIMATION (anatomically correct) ═══
        const legCycle = this.locomotionTime * 5.0;
        const gaitAmp = Math.min(speedNorm * 1.2, 1.0) * 0.6 * this.motion.gaitAmpMul;

        if (isMoving) {
          // Hindlimb: hip drives, knee follows with phase offset
          this.hindL.rotation.x = -0.08 + Math.sin(legCycle) * gaitAmp * 0.9;
          this.hindR.rotation.x = -0.08 + Math.sin(legCycle + Math.PI) * gaitAmp * 0.9;
          this.shankL.rotation.x = 0.24 + Math.max(0, Math.sin(legCycle + 0.5)) * gaitAmp * 0.42;
          this.shankR.rotation.x = 0.24 + Math.max(0, Math.sin(legCycle + Math.PI + 0.5)) * gaitAmp * 0.42;
          // Ankle follows shank, pushes off
          if (this.hindL._ankle) this.hindL._ankle.rotation.x = -0.10 + Math.sin(legCycle - 0.3) * gaitAmp * 0.22;
          if (this.hindR._ankle) this.hindR._ankle.rotation.x = -0.10 + Math.sin(legCycle + Math.PI - 0.3) * gaitAmp * 0.22;

          // Forelimb: shoulder drives, elbow/wrist follow
          this.armL.rotation.x = -0.18 + Math.sin(legCycle + Math.PI) * gaitAmp * 0.62;
          this.armR.rotation.x = -0.18 + Math.sin(legCycle) * gaitAmp * 0.62;
          // Elbow flex
          if (this.armL._forearm) this.armL._forearm.rotation.x = 0.14 + Math.max(0, Math.sin(legCycle + Math.PI + 0.4)) * gaitAmp * 0.3;
          if (this.armR._forearm) this.armR._forearm.rotation.x = 0.14 + Math.max(0, Math.sin(legCycle + 0.4)) * gaitAmp * 0.3;
          // Wrist flex
          if (this.armL._wrist) this.armL._wrist.rotation.x = -0.06 + Math.sin(legCycle + Math.PI + 0.6) * gaitAmp * 0.12;
          if (this.armR._wrist) this.armR._wrist.rotation.x = -0.06 + Math.sin(legCycle + 0.6) * gaitAmp * 0.12;
        } else {
          // Idle pose
          this.hindL.rotation.x = -0.08; this.hindR.rotation.x = -0.08;
          this.shankL.rotation.x = 0.24; this.shankR.rotation.x = 0.24;
          if (this.hindL._ankle) this.hindL._ankle.rotation.x = -0.10;
          if (this.hindR._ankle) this.hindR._ankle.rotation.x = -0.10;

          // Neutral planted stance with subtle weight-shift micro-motion
          const pawShift = Math.sin(time * 1.3 + this.timeOffset) * 0.008;
          this.armL.rotation.x = -0.18; this.armR.rotation.x = -0.18;
          this.armL.rotation.z = -0.04 + pawShift; this.armR.rotation.z = 0.04 - pawShift;
          if (this.armL._forearm) this.armL._forearm.rotation.x = 0.14;
          if (this.armR._forearm) this.armR._forearm.rotation.x = 0.14;
          if (this.armL._wrist) this.armL._wrist.rotation.x = -0.06;
          if (this.armR._wrist) this.armR._wrist.rotation.x = -0.06;
        }

        const rear = this.rearAmount;
        if (rear > 0) {
          // Rearing posture near walls: raise front body and forelimbs.
          this.rig.position.y += rear * 0.85;
          this.rig.rotation.x -= rear * 0.40;
          this.armL.rotation.x = THREE.MathUtils.lerp(this.armL.rotation.x, -1.18, rear);
          this.armR.rotation.x = THREE.MathUtils.lerp(this.armR.rotation.x, -1.18, rear);
          this.armL.rotation.z = THREE.MathUtils.lerp(this.armL.rotation.z, -0.16, rear);
          this.armR.rotation.z = THREE.MathUtils.lerp(this.armR.rotation.z, 0.16, rear);
          if (this.armL._forearm) this.armL._forearm.rotation.x = THREE.MathUtils.lerp(this.armL._forearm.rotation.x, 0.85, rear);
          if (this.armR._forearm) this.armR._forearm.rotation.x = THREE.MathUtils.lerp(this.armR._forearm.rotation.x, 0.85, rear);
          if (this.armL._wrist) this.armL._wrist.rotation.x = THREE.MathUtils.lerp(this.armL._wrist.rotation.x, 0.45, rear);
          if (this.armR._wrist) this.armR._wrist.rotation.x = THREE.MathUtils.lerp(this.armR._wrist.rotation.x, 0.45, rear);
          this.hindL.rotation.x = THREE.MathUtils.lerp(this.hindL.rotation.x, 0.35, rear);
          this.hindR.rotation.x = THREE.MathUtils.lerp(this.hindR.rotation.x, 0.35, rear);
          this.contactShadow.position.set(0, -this.rig.position.y + 0.02, 0);
        }

        // Head animation with irregular sniff pulses
        const calmIdle = !isMoving && speed < 0.45 && this.lowSpeedTimer > 0.6;
        // Irregular sniff: combine multiple frequencies for biological plausibility
        const sniffBase = Math.sin(time * 40.0 + this.timeOffset);
        const sniffMod = Math.sin(time * 27.3 + this.timeOffset * 1.7) * 0.4;
        const sniffBurst = Math.max(0, Math.sin(time * 3.2 + this.timeOffset)) * 0.6;
        const sniffPulse = (sniffBase + sniffMod) * (0.4 + sniffBurst) * this.motion.sniffAmpMul;
        if (!isMoving) {
          if (calmIdle) {
            this.headGroup.rotation.y *= 0.85;
            this.headGroup.rotation.x *= 0.85;
            this.snoutTip.position.y = -0.15 + sniffPulse * 0.006;
            this.padL.rotation.y = 0.1 + sniffPulse * 0.02;
            this.padR.rotation.y = -0.1 - sniffPulse * 0.02;
          } else {
            this.headGroup.rotation.y = Math.sin(time * 6.0) * 0.3 * this.motion.headIdleYawMul;
            this.headGroup.rotation.x = Math.sin(time * 9.0) * 0.15 * this.motion.headIdlePitchMul;
            this.snoutTip.position.y = -0.15 + sniffPulse * 0.02;
            // Nose scale pulse during sniffing (compression)
            const noseScalePulse = 1.0 + sniffPulse * 0.015;
            this.snoutTip.scale.z = 0.72 * this.guiParams.snoutLength * noseScalePulse;
            this.padL.rotation.y = sniffPulse * 0.1 + 0.1;
            this.padR.rotation.y = -sniffPulse * 0.1 - 0.1;
          }
        } else {
          const turnAmount = this.velocity.x * this.heading.y - this.velocity.y * this.heading.x;
          // Head stabilization: slight counter-rotation during locomotion
          const headStab = Math.sin(this.locomotionTime * 5.0) * 0.025;
          this.headGroup.rotation.set(Math.sin(time * 2) * 0.08 + headStab, turnAmount * 0.08, 0);
          this.snoutTip.position.y = -0.15;
          this.padL.rotation.y = -0.3; this.padR.rotation.y = 0.3;
        }
        if (rear > 0) this.headGroup.rotation.x += rear * 0.32;

        // ═══ EAR MICRO-TWITCHES ═══
        if (this.earL && this.earR && this.earMicro.baseRotL) {
          this.earMicro.twitchTimerL += dt;
          this.earMicro.twitchTimerR += dt;
          if (this.earMicro.twitchTimerL > this.earMicro.nextIntervalL) {
            this.earMicro.twitchAngleL = (Math.random() - 0.5) * 0.14;
            this.earMicro.twitchTimerL = 0;
            this.earMicro.nextIntervalL = 0.5 + Math.random() * 4.0;
          }
          if (this.earMicro.twitchTimerR > this.earMicro.nextIntervalR) {
            this.earMicro.twitchAngleR = (Math.random() - 0.5) * 0.14;
            this.earMicro.twitchTimerR = 0;
            this.earMicro.nextIntervalR = 0.5 + Math.random() * 4.0;
          }
          // Smooth exponential decay
          this.earMicro.twitchAngleL *= Math.exp(-4.0 * dt);
          this.earMicro.twitchAngleR *= Math.exp(-4.0 * dt);
          // Locomotion secondary bounce
          const earBounce = isMoving ? Math.sin(this.locomotionTime * 5.0) * 0.02 : 0;
          this.earL.rotation.z = this.earMicro.baseRotL.z + this.earMicro.twitchAngleL + earBounce;
          this.earR.rotation.z = this.earMicro.baseRotR.z + this.earMicro.twitchAngleR - earBounce;
          this.earL.rotation.x = this.earMicro.baseRotL.x + this.earMicro.twitchAngleL * 0.5;
          this.earR.rotation.x = this.earMicro.baseRotR.x + this.earMicro.twitchAngleR * 0.5;
        }

        // ═══ TAIL ═══
        let tailBase = new THREE.Vector3(0, -0.16, -PROP.bodyLength * 0.90);
        this.rig.updateMatrix();
        tailBase.applyMatrix4(this.rig.matrix);
        let tailCurve = [];
        const tailLenMul = this.guiParams.tailLength;
        const segLen = this.tailSegLen * tailLenMul;
        for (let i = 0; i <= this.tailCount; i++) {
          const p = i / this.tailCount;
          const lag = p * p;
          const transmit = Math.pow(p, 1.35);
          const midCurve = p * (1.0 - p);
          const bodyForceX = (this.bodyDyn.roll * 0.34 + lateralAccel * 0.010 - turnRate * 0.018) * transmit;
          const bodyForceY = (this.bodyDyn.pitch * 0.38 - forwardAccel * 0.008) * transmit;
          const waveX = this.tailDyn.sway * lag + bodyForceX + midCurve * 0.18 * Math.sign(this.tailDyn.sway || bodyForceX || 1);
          let waveY = -i * PROP.tailSag * p + this.tailDyn.lift * lag + bodyForceY + midCurve * 0.08;
          waveY = Math.max(waveY, -1.3);
          tailCurve.push(new THREE.Vector3(waveX, waveY, -i * segLen));
        }
        let offset = tailBase.clone().sub(tailCurve[0]);
        for (let i = 0; i <= this.tailCount; i++) {
          tailCurve[i].add(offset);
          const worldY = tailCurve[i].y + this.mesh.position.y;
          if (worldY < 0.05) tailCurve[i].y += (0.05 - worldY);
        }
        for (let i = 0; i < this.tailCount; i++) {
          let p = i / this.tailCount;
          let radius = 1.0 - p * PROP.tailTaper;
          const rootBlend = 1.0 - THREE.MathUtils.smoothstep(p, 0.0, 0.20);
          radius *= 1.0 + rootBlend * 0.45;
          // Annular ring segmentation — more pronounced
          radius *= 1.0 + Math.sin(i * 2.8) * 0.06;
          // Wrinkle-on-bend: compress segments on inner curve of bends
          if (i > 0 && i < this.tailCount) {
            const dx = tailCurve[i + 1].x - tailCurve[i].x;
            const prevDx = tailCurve[i].x - tailCurve[i - 1].x;
            const bendAmount = Math.abs(dx - prevDx);
            radius *= 1.0 + bendAmount * 0.8; // slight bulge at bend
          }
          this.dummy.position.copy(tailCurve[i]);
          this.dummy.lookAt(tailCurve[i + 1]);
          const thickMul = this.guiParams.tailThickness;
          this.dummy.scale.set(radius * thickMul, radius * thickMul, segLen * 1.3);
          this.dummy.updateMatrix();
          this.tailInstanced.setMatrixAt(i, this.dummy.matrix);
          let isTailVisible = this.tailInstanced.visible;
          if (i === Math.floor(this.tailCount * 0.4)) {
            this.poseNodes['tailmid'].position.copy(tailCurve[i + 1]);
            this.poseNodes['tailmid'].visible = guiParams.showTrackingKeypoints && isTailVisible;
          }
          if (i === this.tailCount - 1) {
            this.poseNodes['tailend'].position.copy(tailCurve[i + 1]);
            this.poseNodes['tailend'].visible = guiParams.showTrackingKeypoints && isTailVisible;
          }
        }
        this.tailInstanced.instanceMatrix.needsUpdate = true;
        // Keep a soft root collar aligned with the first tail segment.
        if (this.tailRoot && tailCurve.length > 4) {
          const thickMul = this.guiParams.tailThickness;
          const dir = tailCurve[3].clone().sub(tailCurve[0]).normalize();
          this.tailRoot.position.copy(tailCurve[0]).addScaledVector(dir, segLen * 0.25);
          this.tailRoot.lookAt(tailCurve[3]);
          const s = 1.0 + (thickMul - 1.0) * 0.7;
          this.tailRoot.scale.set(0.95 * s, 0.68 * s, 1.15 * s);
        }

        // Tracking visibility
        this.trackingGroup.visible = guiParams.showTrackingKeypoints;
        for (const key in this.poseNodes) this.poseNodes[key].visible = guiParams.showTrackingKeypoints;

        // Live adjustments — thorax/abdomen breathing differentiation
        const breathFreq = isMoving ? this.motion.breathMoveFreq : this.motion.breathIdleFreq;
        const breathAmp = isMoving ? this.motion.breathMoveAmp : this.motion.breathIdleAmp;
        const breathPhase = time * breathFreq;
        const thoraxBreath = Math.sin(breathPhase) * breathAmp;
        const abdomenBreath = Math.sin(breathPhase - 0.4) * breathAmp * 1.3; // abdomen lags & is larger
        this.bodyMesh.scale.x = this.guiParams.bodyLength + thoraxBreath;
        this.bodyMesh.scale.y = this.guiParams.chonkiness + abdomenBreath * 0.3;
        this.bodyMesh.scale.z = this.guiParams.chonkiness + thoraxBreath;
        this.head.scale.setScalar(this.guiParams.headSize);
        if (!isMoving || calmIdle) {
          this.snoutTip.scale.set(1.06, 0.76, this.guiParams.snoutLength * 0.72);
        }
        this.fleshMat.color.set(this.guiParams.skinColor);
        this.prevVelocity.copy(this.velocity);

        this.mesh.updateMatrixWorld(true);

        if (this.trackingGroup.visible) {
          const positions = this.skeletonLines.geometry.attributes.position.array;
          let idx = 0;
          const invMat = this.trackingGroup.matrixWorld.clone().invert();
          const ptA = new THREE.Vector3(), ptB = new THREE.Vector3();
          for (const [idA, idB] of POSE_CONNECTIONS) {
            const nA = this.poseNodes[idA], nB = this.poseNodes[idB];
            if (nA && nB) {
              nA.getWorldPosition(ptA); nB.getWorldPosition(ptB);
              ptA.applyMatrix4(invMat); ptB.applyMatrix4(invMat);
              positions[idx++] = ptA.x; positions[idx++] = ptA.y; positions[idx++] = ptA.z;
              positions[idx++] = ptB.x; positions[idx++] = ptB.y; positions[idx++] = ptB.z;
            }
          }
          this.skeletonLines.geometry.attributes.position.needsUpdate = true;
        }
      }
    }


    // ═══════════════════════════════════════════════════════════════
    // 11. SCENE ASSEMBLY
    // ═══════════════════════════════════════════════════════════════
    const floorGeo = new THREE.PlaneGeometry(200, 200);
    const floorMat = new THREE.MeshPhysicalMaterial({
      color: 0x111620, roughness: 0.15, metalness: 0.6,
      clearcoat: 1.0, clearcoatRoughness: 0.1,
      polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 1
    });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2; floor.receiveShadow = true;
    scene.add(floor);

    const enclosureMat = new THREE.MeshPhysicalMaterial({
      color: 0xb9d7ea, transparent: true, opacity: 0.13, roughness: 0.2, metalness: 0.0, transmission: 0.0, thickness: 0.0,
      side: THREE.BackSide, depthWrite: false
    });
    const enclosureBox = new THREE.Mesh(new THREE.BoxGeometry(ENCLOSURE_W, ENCLOSURE_H, ENCLOSURE_D), enclosureMat);
    enclosureBox.position.set(0, ENCLOSURE_H * 0.5, 0); enclosureBox.receiveShadow = true;
    enclosureBox.renderOrder = 10;
    scene.add(enclosureBox);

    const enclosureEdges = new THREE.LineSegments(
      new THREE.EdgesGeometry(new THREE.BoxGeometry(ENCLOSURE_W, ENCLOSURE_H, ENCLOSURE_D)),
      new THREE.LineBasicMaterial({ color: 0x58c8ff, transparent: true, opacity: 0.45 })
    );
    enclosureEdges.material.depthTest = false;
    enclosureEdges.renderOrder = 25;
    enclosureEdges.position.copy(enclosureBox.position); scene.add(enclosureEdges);

    const grid = new THREE.GridHelper(100, 50, 0x00f0ff, 0x112233);
    grid.position.y = 0.05;
    const gridMats = Array.isArray(grid.material) ? grid.material : [grid.material];
    for (const gm of gridMats) {
      gm.transparent = true;
      gm.opacity = 0.12;
      gm.depthWrite = false;
      gm.depthTest = false;
    }
    grid.renderOrder = 20;
    scene.add(grid);

    // ═══════════════════════════════════════════════════════════════
    // 12. LIGHTING (3-point photographic lab setup)
    // ═══════════════════════════════════════════════════════════════
    const ambientLight = new THREE.AmbientLight(0xf5f0eb, 0.5);
    scene.add(ambientLight);

    const hemiLight = new THREE.HemisphereLight(0xe8eef5, 0xf0e8d8, 0.6);
    hemiLight.position.set(0, 20, 0); scene.add(hemiLight);

    // Key light (overhead panel)
    const keyLight = new THREE.DirectionalLight(0xf0f0ff, 0.8);
    keyLight.position.set(0, 18, 0); keyLight.castShadow = true;
    keyLight.shadow.mapSize.width = 2048; keyLight.shadow.mapSize.height = 2048;
    keyLight.shadow.camera.near = 0.5; keyLight.shadow.camera.far = 30;
    keyLight.shadow.camera.left = -20; keyLight.shadow.camera.right = 20;
    keyLight.shadow.camera.top = 15; keyLight.shadow.camera.bottom = -15;
    keyLight.shadow.bias = -0.001; keyLight.shadow.normalBias = 0.02;
    scene.add(keyLight);

    // Fill light
    const fillLight = new THREE.DirectionalLight(0xf5f0e8, 0.4);
    fillLight.position.set(8, 16, 5); fillLight.castShadow = false;
    scene.add(fillLight);

    // Rim light
    const rimLight = new THREE.DirectionalLight(0xe8e8f0, 0.3);
    rimLight.position.set(-6, 12, -4); rimLight.castShadow = false;
    scene.add(rimLight);

    // ═══════════════════════════════════════════════════════════════
    // 13. GUI & LOGIC
    // ═══════════════════════════════════════════════════════════════
    const mice = [];
    const hudElements = {
      count: document.getElementById('hud-count'),
      state: document.getElementById('hud-state'),
      hr: document.getElementById('hud-hr'),
      resp: document.getElementById('hud-resp'),
      coord: document.getElementById('hud-coord')
    };

    // ═══ Initialize shader engine ═══
    const annolidShaders = new AnnolidShaders(THREE);
    const postFX = annolidShaders.createPostProcessing(renderer, {
      vigIntensity: 0.3, vigSoftness: 0.45, grainStrength: 0.02,
      saturation: 1.05, brightness: 1.0
    });

    const guiParams = {
      furColor: '#ffffff', skinColor: '#f0c8b8',
      chonkiness: 1.128, earSize: 0.82, furDensity: 1.0,
      showTrackingKeypoints: true, wireframeMode: false, isPaused: false,
      addSubject: () => spawnMouse(), clearSubjects: () => clearMice(),
      presets: 'BALB/c (White)',
      // Body part controls
      tailLength: 0.5, tailThickness: 1.0,
      headSize: 1.0, snoutLength: 1.0,
      bodyLength: 1.0, legLength: 1.18, legThickness: 1.0,
      // Physics
      maxSpeed: 9.0, dragCoeff: 1.5, wanderForce: 10.0, wallAttraction: 3.2,
      // Quality
      qualityMode: 'Realtime', furDetailLevel: 'Med',
      enableVignette: false, enableGrain: false, enableAO: true,
      // Lighting
      keyIntensity: 0.8, fillIntensity: 0.4, rimIntensity: 0.3,
      keyColorTemp: 6500, ambientIntensity: 0.5,
      // Proportions (exposed)
      propBodyLength: PROP.bodyLength, propBodyGirthX: PROP.bodyGirthX,
      propWaistTaper: PROP.waistTaper, propHaunchWidth: PROP.haunchWidth,
      propShoulderWidth: PROP.shoulderWidth,
      propNeckLength: PROP.neckLength, propNeckGirth: PROP.neckGirth,
      propSnoutLength: PROP.snoutLength, propSnoutWidth: PROP.snoutWidth,
      propCheekFullness: PROP.cheekFullness,
      propEarYaw: PROP.earYaw, propEarThickness: PROP.earThickness,
      propEyeSize: PROP.eyeSize, propEyeSpacing: PROP.eyeSpacing,
      propForeLimbLength: PROP.foreLimbLength, propHindLimbLength: PROP.hindLimbLength,
      propForePawSize: PROP.forePawSize, propHindPawSize: PROP.hindPawSize,
      propTailSag: PROP.tailSag,
      // Fur
      furGuardRatio: 0.5, furLength: 1.0, furClumpiness: 0.3,
      // Shader controls
      enableSSS: true, sssThickness: 0.45, sssWrap: 0.5, sssBacklight: 0.6,
      enableContactAO: true, aoRadius: 1.5, aoIntensity: 0.35,
      enableMicroDetail: true, microScale: 40.0, microStrength: 0.06,
      enablePostFX: false, postVignette: 0.3, postGrain: 0.02, postSaturation: 1.05,
    };

    function getStrainProfile(presetName) {
      if (presetName === 'C57BL/6 (Black)') {
        return {
          earOuterTransmission: 0.65, earInnerTransmission: 0.75,
          earInnerSatOffset: 0.10, earInnerLightOffset: 0.15, earOuterRoughness: 0.32,
          earOuterColor: '#c3a88f', earInnerColor: '#e1ccb6',
          earYaw: 0.96, earHeightOffset: 0.0, padDarken: 0.88, clawColor: 0xcccccc,
          pawColor: '#c28b86', pawPadColor: '#c98f89',
          noseColor: '#b97972', pawSpreadMul: 1.0, toeLenMul: 0.98,
          gaitAmpMul: 0.92, headIdleYawMul: 0.82, headIdlePitchMul: 0.88,
          sniffAmpMul: 0.75, breathIdleAmp: 0.010, breathMoveAmp: 0.012,
          breathIdleFreq: 10.0, breathMoveFreq: 18.0, tailWaveAmpMul: 0.85, tailWaveFreqMul: 0.90
        };
      }
      if (presetName === 'Nude/Hairless') {
        return {
          earOuterTransmission: 0.66, earInnerTransmission: 0.82,
          earInnerSatOffset: 0.14, earInnerLightOffset: 0.14, earOuterRoughness: 0.28,
          earOuterColor: '#efc2ba', earInnerColor: '#ffd9ce',
          earYaw: 0.42, earHeightOffset: 0.015, padDarken: 0.88, clawColor: 0xe1d7cb,
          pawColor: '#f0bbb2', pawPadColor: '#f3c4bb',
          noseColor: '#d29089', pawSpreadMul: 1.04, toeLenMul: 1.05,
          gaitAmpMul: 1.08, headIdleYawMul: 1.15, headIdlePitchMul: 1.12,
          sniffAmpMul: 1.25, breathIdleAmp: 0.018, breathMoveAmp: 0.024,
          breathIdleFreq: 13.0, breathMoveFreq: 24.0, tailWaveAmpMul: 1.18, tailWaveFreqMul: 1.12
        };
      }
      return { // BALB/c default
        earOuterTransmission: 0.58, earInnerTransmission: 0.76,
        earInnerSatOffset: 0.11, earInnerLightOffset: 0.11, earOuterRoughness: 0.33,
        earOuterColor: '#d6c0a8', earInnerColor: '#ebd8c5',
        earYaw: 0.40, earHeightOffset: 0.0, padDarken: 0.84, clawColor: 0xd7cdc2,
        pawColor: '#dfaea5', pawPadColor: '#e7bab0',
        noseColor: '#c9867f', pawSpreadMul: 1.0, toeLenMul: 1.0,
        gaitAmpMul: 1.0, headIdleYawMul: 1.0, headIdlePitchMul: 1.0,
        sniffAmpMul: 1.0, breathIdleAmp: 0.013, breathMoveAmp: 0.016,
        breathIdleFreq: 12.0, breathMoveFreq: 20.0, tailWaveAmpMul: 1.0, tailWaveFreqMul: 1.0
      };
    }

    function applyStrainPreset(name) {
      guiParams.presets = name;
      if (name === 'BALB/c (White)') { guiParams.furColor = '#ffffff'; guiParams.skinColor = '#f0c8b8'; guiParams.furDensity = 0.82; guiParams.earSize = 0.74; }
      if (name === 'C57BL/6 (Black)') { guiParams.furColor = '#111015'; guiParams.skinColor = '#3a3438'; guiParams.furDensity = 0.92; guiParams.earSize = 0.84; }
      if (name === 'CBA (Brown)') { guiParams.furColor = '#6a4b3a'; guiParams.skinColor = '#d0a090'; guiParams.furDensity = 0.76; guiParams.earSize = 0.76; }
      if (name === 'Nude/Hairless') { guiParams.furColor = '#ffd0c8'; guiParams.skinColor = '#ffc0b8'; guiParams.furDensity = 0.0; guiParams.earSize = 0.9; }
    }

    const gui = new GUI({ title: 'GENETICS LAB (GUI)' });
    const respawnNoticeState = new Map();

    function notifyRespawnRequired(key, value, message) {
      const token = `${key}:${JSON.stringify(value)}`;
      if (respawnNoticeState.get(key) === token) return;
      respawnNoticeState.set(key, token);
      alert(message);
    }

    gui.add(guiParams, 'presets', ['BALB/c (White)', 'C57BL/6 (Black)', 'CBA (Brown)', 'Nude/Hairless']).name('Strains').onChange(v => {
      applyStrainPreset(v);
      gui.controllersRecursive().forEach(c => c.updateDisplay());
    });

    // Neuroscience
    const neuroscienceFolder = gui.addFolder('Neuroscience & Tracking');
    neuroscienceFolder.add(guiParams, 'showTrackingKeypoints').name('Show Pose Skeleton').onChange(v => {
      mice.forEach(m => m.trackingGroup.visible = v);
    });
    neuroscienceFolder.add(guiParams, 'wireframeMode').name('Wireframe Bodies').onChange(v => {
      scene.traverse(child => {
        if (child.isMesh && child.material && child.material !== floorMat && child !== enclosureBox) {
          if (child.geometry && child.geometry.type !== 'ConeGeometry' && child.geometry.type !== 'CylinderGeometry') {
            child.material.wireframe = v;
          }
        }
      });
    });

    // Biological Traits
    const traitFolder = gui.addFolder('Biological Traits');
    traitFolder.addColor(guiParams, 'furColor').name('Fur Pigment');
    traitFolder.addColor(guiParams, 'skinColor').name('Skin Pigment');
    traitFolder.add(guiParams, 'chonkiness', 0.5, 2.0).name('Fatness / Mass');
    traitFolder.add(guiParams, 'earSize', 0.5, 2.0).name('Ear Magnitude');
    traitFolder.add(guiParams, 'furDensity', 0.0, 1.0).name('Fur Density').onFinishChange(v => {
      notifyRespawnRequired(
        'furDensity',
        Number(v).toFixed(3),
        "Fur density changes require respawning subjects to take effect."
      );
    });

    // Simulation Controls
    const controlFolder = gui.addFolder('Simulation Controls');
    controlFolder.add(guiParams, 'isPaused').name('Pause Simulation');
    controlFolder.add(guiParams, 'addSubject').name('(+) Spawn Subject');
    controlFolder.add(guiParams, 'clearSubjects').name('(!) Clear All');

    // Body Part Controls
    const bodyFolder = gui.addFolder('Body Part Controls');
    bodyFolder.add(guiParams, 'tailLength', 0.2, 2.5, 0.05).name('Tail Length');
    bodyFolder.add(guiParams, 'tailThickness', 0.3, 2.0, 0.05).name('Tail Thickness');
    bodyFolder.add(guiParams, 'headSize', 0.5, 2.0, 0.05).name('Head Size');
    bodyFolder.add(guiParams, 'snoutLength', 0.5, 2.0, 0.05).name('Snout Length');
    bodyFolder.add(guiParams, 'bodyLength', 0.5, 2.0, 0.05).name('Body Length');
    bodyFolder.add(guiParams, 'legLength', 0.5, 2.0, 0.05).name('Leg Length');
    bodyFolder.add(guiParams, 'legThickness', 0.5, 2.0, 0.05).name('Leg Thickness');

    // Proportions (detailed)
    const propFolder = gui.addFolder('Proportions');
    propFolder.add(guiParams, 'propBodyLength', 1.5, 4.0, 0.1).name('Body Length').onChange(v => { PROP.bodyLength = v; });
    propFolder.add(guiParams, 'propBodyGirthX', 1.0, 2.5, 0.05).name('Body Girth X').onChange(v => { PROP.bodyGirthX = v; });
    propFolder.add(guiParams, 'propWaistTaper', 0.3, 1.0, 0.05).name('Waist Taper').onChange(v => { PROP.waistTaper = v; });
    propFolder.add(guiParams, 'propHaunchWidth', 0.8, 2.0, 0.05).name('Haunch Width').onChange(v => { PROP.haunchWidth = v; });
    propFolder.add(guiParams, 'propShoulderWidth', 0.5, 1.5, 0.05).name('Shoulder Width').onChange(v => { PROP.shoulderWidth = v; });
    propFolder.add(guiParams, 'propNeckLength', 0.3, 1.5, 0.05).name('Neck Length').onChange(v => { PROP.neckLength = v; });
    propFolder.add(guiParams, 'propNeckGirth', 0.3, 1.0, 0.05).name('Neck Girth').onChange(v => { PROP.neckGirth = v; });
    propFolder.add(guiParams, 'propSnoutLength', 0.8, 2.0, 0.05).name('Snout Length').onChange(v => { PROP.snoutLength = v; });
    propFolder.add(guiParams, 'propSnoutWidth', 0.8, 1.8, 0.05).name('Snout Width').onChange(v => { PROP.snoutWidth = v; });
    propFolder.add(guiParams, 'propCheekFullness', 0.1, 0.8, 0.05).name('Cheek Fullness').onChange(v => { PROP.cheekFullness = v; });
    propFolder.add(guiParams, 'propEarYaw', 0.2, 1.2, 0.05).name('Ear Yaw').onChange(v => { PROP.earYaw = v; });
    propFolder.add(guiParams, 'propEyeSize', 0.08, 0.25, 0.01).name('Eye Size').onChange(v => { PROP.eyeSize = v; });
    propFolder.add(guiParams, 'propEyeSpacing', 0.3, 0.7, 0.02).name('Eye Spacing').onChange(v => { PROP.eyeSpacing = v; });
    propFolder.add(guiParams, 'propForeLimbLength', 0.5, 1.5, 0.05).name('Forelimb Length').onChange(v => { PROP.foreLimbLength = v; });
    propFolder.add(guiParams, 'propHindLimbLength', 0.5, 1.5, 0.05).name('Hindlimb Length').onChange(v => { PROP.hindLimbLength = v; });
    propFolder.add(guiParams, 'propForePawSize', 0.5, 2.0, 0.05).name('Forepaw Size').onChange(v => { PROP.forePawSize = v; });
    propFolder.add(guiParams, 'propHindPawSize', 0.5, 2.0, 0.05).name('Hindpaw Size').onChange(v => { PROP.hindPawSize = v; });
    propFolder.add(guiParams, 'propTailSag', 0.0, 0.1, 0.005).name('Tail Sag').onChange(v => { PROP.tailSag = v; });
    propFolder.close();

    // Fur controls
    const furFolder = gui.addFolder('Fur');
    furFolder.add(guiParams, 'furDetailLevel', ['High', 'Med', 'Low', 'Off']).name('Fur Detail').onFinishChange(v => {
      notifyRespawnRequired(
        'furDetailLevel',
        String(v || ''),
        "Fur detail changes require respawning subjects to take effect."
      );
    });
    furFolder.add(guiParams, 'furGuardRatio', 0.0, 1.0, 0.05).name('Guard Hair Ratio');
    furFolder.add(guiParams, 'furLength', 0.3, 2.0, 0.05).name('Fur Length');
    furFolder.add(guiParams, 'furClumpiness', 0.0, 1.0, 0.05).name('Clumpiness');
    furFolder.close();

    // Lighting
    const lightFolder = gui.addFolder('Lighting');
    lightFolder.add(guiParams, 'keyIntensity', 0.0, 2.0, 0.05).name('Key Intensity').onChange(v => { keyLight.intensity = v; });
    lightFolder.add(guiParams, 'fillIntensity', 0.0, 2.0, 0.05).name('Fill Intensity').onChange(v => { fillLight.intensity = v; });
    lightFolder.add(guiParams, 'rimIntensity', 0.0, 2.0, 0.05).name('Rim Intensity').onChange(v => { rimLight.intensity = v; });
    lightFolder.add(guiParams, 'ambientIntensity', 0.0, 2.0, 0.05).name('Ambient Intensity').onChange(v => { ambientLight.intensity = v; });
    lightFolder.close();

    // Quality
    const qualityFolder = gui.addFolder('Quality');
    qualityFolder.add(guiParams, 'qualityMode', ['Photo', 'Realtime', 'Low']).name('Quality Mode').onChange(v => {
      if (v === 'Photo') {
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMappingExposure = 1.5;
        keyLight.shadow.mapSize.width = 4096; keyLight.shadow.mapSize.height = 4096;
        keyLight.shadow.map?.dispose(); keyLight.shadow.map = null;
        guiParams.enablePostFX = true; postFX.enabled = true;
      } else if (v === 'Low') {
        renderer.setPixelRatio(1.0);
        renderer.toneMappingExposure = 1.3;
        keyLight.shadow.mapSize.width = 1024; keyLight.shadow.mapSize.height = 1024;
        keyLight.shadow.map?.dispose(); keyLight.shadow.map = null;
        guiParams.enablePostFX = false; postFX.enabled = false;
      } else {
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.toneMappingExposure = 1.4;
        keyLight.shadow.mapSize.width = 2048; keyLight.shadow.mapSize.height = 2048;
        keyLight.shadow.map?.dispose(); keyLight.shadow.map = null;
        guiParams.enablePostFX = false; postFX.enabled = false;
      }
      gui.controllersRecursive().forEach(c => c.updateDisplay());
    });
    qualityFolder.add(guiParams, 'enableAO').name('Contact Shadows').onChange(v => {
      mice.forEach(m => { if (m.contactShadow) m.contactShadow.visible = v; });
    });
    qualityFolder.close();

    // Shaders
    const shaderFolder = gui.addFolder('Shaders');
    shaderFolder.add(guiParams, 'enableSSS').name('Subsurface Scatter').onFinishChange(v => {
      notifyRespawnRequired(
        'enableSSS',
        Boolean(v),
        'Shader changes require respawning subjects.'
      );
    });
    shaderFolder.add(guiParams, 'sssThickness', 0.0, 1.0, 0.05).name('SSS Thickness');
    shaderFolder.add(guiParams, 'sssWrap', 0.0, 1.0, 0.05).name('SSS Wrap');
    shaderFolder.add(guiParams, 'sssBacklight', 0.0, 1.5, 0.05).name('SSS Backlight');
    shaderFolder.add(guiParams, 'enableContactAO').name('Contact AO').onFinishChange(v => {
      notifyRespawnRequired(
        'enableContactAO',
        Boolean(v),
        'Shader changes require respawning subjects.'
      );
    });
    shaderFolder.add(guiParams, 'aoRadius', 0.5, 5.0, 0.1).name('AO Radius');
    shaderFolder.add(guiParams, 'aoIntensity', 0.0, 1.0, 0.05).name('AO Intensity');
    shaderFolder.add(guiParams, 'enableMicroDetail').name('Micro Detail').onFinishChange(v => {
      notifyRespawnRequired(
        'enableMicroDetail',
        Boolean(v),
        'Shader changes require respawning subjects.'
      );
    });
    shaderFolder.add(guiParams, 'microScale', 5.0, 200.0, 5.0).name('Detail Scale');
    shaderFolder.add(guiParams, 'microStrength', 0.0, 0.3, 0.01).name('Detail Strength');
    shaderFolder.add(guiParams, 'enablePostFX').name('Post-Processing').onChange(v => {
      postFX.enabled = v;
    });
    shaderFolder.add(guiParams, 'postVignette', 0.0, 1.0, 0.05).name('Vignette').onChange(v => {
      postFX.uniforms.uVigIntensity.value = v;
    });
    shaderFolder.add(guiParams, 'postGrain', 0.0, 0.1, 0.005).name('Film Grain').onChange(v => {
      postFX.uniforms.uGrainStrength.value = v;
    });
    shaderFolder.add(guiParams, 'postSaturation', 0.5, 1.5, 0.05).name('Saturation').onChange(v => {
      postFX.uniforms.uSaturation.value = v;
    });
    shaderFolder.close();

    // Physics
    const physicsFolder = gui.addFolder('Physics Controls');
    physicsFolder.add(guiParams, 'maxSpeed', 1.0, 20.0, 0.5).name('Max Speed');
    physicsFolder.add(guiParams, 'dragCoeff', 0.5, 10.0, 0.5).name('Drag / Friction');
    physicsFolder.add(guiParams, 'wanderForce', 0.5, 10.0, 0.5).name('Wander Force');
    physicsFolder.add(guiParams, 'wallAttraction', 0.0, 5.0, 0.25).name('Wall Attraction');

    // ═══════════════════════════════════════════════════════════════
    // 14. SPAWN / CLEAR
    // ═══════════════════════════════════════════════════════════════
    function spawnMouse() {
      const m = new ExpertMouse(guiParams);
      const wall = Math.floor(Math.random() * 4);
      const wo = 4.6;
      let inX = 0, inZ = 0;
      switch (wall) {
        case 0: m.mesh.position.x = ENCLOSURE_HALF_X - wo; m.mesh.position.z = (Math.random() - 0.5) * ENCLOSURE_HALF_Z * 1.5; inX = -1; break;
        case 1: m.mesh.position.x = -ENCLOSURE_HALF_X + wo; m.mesh.position.z = (Math.random() - 0.5) * ENCLOSURE_HALF_Z * 1.5; inX = 1; break;
        case 2: m.mesh.position.x = (Math.random() - 0.5) * ENCLOSURE_HALF_X * 1.5; m.mesh.position.z = ENCLOSURE_HALF_Z - wo; inZ = -1; break;
        case 3: m.mesh.position.x = (Math.random() - 0.5) * ENCLOSURE_HALF_X * 1.5; m.mesh.position.z = -ENCLOSURE_HALF_Z + wo; inZ = 1; break;
      }
      const dir = new THREE.Vector2(inX, inZ);
      const tangentialKick = (Math.random() - 0.5) * 0.9;
      if (Math.abs(inX) > 0) dir.y += tangentialKick;
      else dir.x += tangentialKick;
      if (dir.lengthSq() < 1e-6) dir.set((Math.random() - 0.5), (Math.random() - 0.5));
      dir.normalize();
      const launchSpeed = guiParams.maxSpeed * (0.50 + Math.random() * 0.18);
      m.velocity.set(dir.x * launchSpeed, dir.y * launchSpeed);
      m.heading.copy(dir);
      m.prevVelocity.copy(m.velocity);
      if (m.tailDyn) {
        m.tailDyn.sway = (Math.random() - 0.5) * 0.25;
        m.tailDyn.lift = -0.04 + Math.random() * 0.03;
      }
      scene.add(m.mesh);
      mice.push(m);
      hudElements.count.innerText = mice.length;
    }

    function clearMice() {
      mice.forEach(m => scene.remove(m.mesh));
      mice.length = 0;
      hudElements.count.innerText = 0;
      hudElements.state.innerText = "NO SUBJECTS";
      hudElements.hr.innerText = "-- BPM";
      hudElements.resp.innerText = "-- BPM";
      hudElements.coord.innerText = "0.00, 0.00";
    }

    // Spawn initial subjects
    applyStrainPreset('C57BL/6 (Black)');
    spawnMouse();
    applyStrainPreset('BALB/c (White)');
    gui.controllersRecursive().forEach(c => c.updateDisplay());
    spawnMouse();

    // ═══════════════════════════════════════════════════════════════
    // 15. RENDER LOOP
    // ═══════════════════════════════════════════════════════════════
    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      postFX.resize();
    });
    window.dispatchEvent(new Event('resize'));

    const clock = new THREE.Clock();
    let accumulatedTime = 0;

    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      if (!guiParams.isPaused) accumulatedTime += dt;
      mice.forEach((m, i) => {
        m.update(accumulatedTime, mice, i === 0 ? hudElements : null, dt);
      });
      controls.update();
      // Render via post-processing pipeline (passes through if disabled)
      postFX.render(scene, camera, accumulatedTime);
    }
    animate();
  </script>
</body>

</html>
