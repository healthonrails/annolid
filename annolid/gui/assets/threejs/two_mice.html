<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Annolid: High-Fidelity Mouse Genetics Lab</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

    :root {
      color-scheme: dark;
    }

    html,
    body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #030405;
      font-family: 'Share Tech Mono', monospace;
      user-select: none;
    }

    #c {
      display: block;
      width: 100%;
      height: 100%;
    }

    .overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      background: radial-gradient(circle at 50% 50%, transparent 40%, rgba(0, 0, 0, 0.85) 120%);
      box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.8);
    }

    .hud {
      position: absolute;
      bottom: 40px;
      left: 40px;
      color: rgba(200, 230, 255, 0.9);
      font-size: 13px;
      border-left: 3px solid #00f0ff;
      padding: 15px 20px;
      background: linear-gradient(90deg, rgba(0, 15, 30, 0.85) 0%, rgba(0, 0, 0, 0) 100%);
      backdrop-filter: blur(5px);
      text-transform: uppercase;
      letter-spacing: 1px;
      pointer-events: none;
    }

    .hud h1 {
      margin: 0 0 10px 0;
      font-size: 16px;
      letter-spacing: 3px;
      color: #fff;
      text-shadow: 0 0 10px rgba(0, 240, 255, 0.5);
    }

    .data-row {
      display: flex;
      justify-content: space-between;
      width: 280px;
      margin-bottom: 4px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      padding-bottom: 2px;
    }

    .label {
      color: #6a95b8;
    }

    .val {
      color: #00f0ff;
      font-weight: bold;
    }

    .val.alert {
      color: #ff3366;
      text-shadow: 0 0 8px rgba(255, 51, 102, 0.6);
    }


    .lil-gui {
      --background-color: rgba(0, 15, 30, 0.9);
      --text-color: #00f0ff;
      --title-background-color: #004466;
      --widget-color: #005577;
      --hover-color: #007799;
      --focus-color: #0099bb;
      --font-family: 'Share Tech Mono', monospace;
      border: 1px solid #00f0ff;
      box-shadow: 0 0 20px rgba(0, 240, 255, 0.2);
      right: 20px !important;
      top: 20px !important;
    }
  </style>
</head>

<body>
  <canvas id="c"></canvas>
  <div class="overlay"></div>
  <div class="hud">
    <h1>PRIMARY SUBJECT TELEMETRY</h1>
    <div class="data-row"><span class="label">SUBJECT COUNT</span><span class="val" id="hud-count">0</span></div>
    <div class="data-row"><span class="label">STATE</span><span class="val" id="hud-state">--</span></div>
    <div class="data-row"><span class="label">HEART RATE</span><span class="val alert" id="hud-hr">-- BPM</span></div>
    <div class="data-row"><span class="label">RESPIRATION</span><span class="val" id="hud-resp">-- BPM</span></div>
    <div class="data-row"><span class="label">COORD XZ</span><span class="val" id="hud-coord">0.00, 0.00</span></div>
  </div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.151.3';
    import { OrbitControls } from 'https://esm.sh/three@0.151.3/examples/jsm/controls/OrbitControls.js';
    import { RoomEnvironment } from 'https://esm.sh/three@0.151.3/examples/jsm/environments/RoomEnvironment.js';
    import GUI from 'https://esm.sh/lil-gui@0.18.2';

    import { AnnolidShaders } from './annolid_shaders.js';

    // ═══════════════════════════════════════════════════════════════
    // 1. CORE RENDERER SETUP
    // ═══════════════════════════════════════════════════════════════
    const canvas = document.querySelector('#c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: "high-performance" });
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.4;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0a0c10, 0.012);

    const camera = new THREE.PerspectiveCamera(35, innerWidth / innerHeight, 0.03, 500);
    camera.position.set(0, 20, 50);

    const controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(0, 1.5, 0);
    controls.maxPolarAngle = Math.PI / 2 - 0.02;

    // IBL environment (True HDR Studio Lighting)
    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    pmremGenerator.compileEquirectangularShader();
    const roomEnvironment = new RoomEnvironment();
    scene.environment = pmremGenerator.fromScene(roomEnvironment).texture;
    roomEnvironment.dispose();

    // ═══════════════════════════════════════════════════════════════
    // 2. PROPORTIONS SYSTEM (ratio-driven placement)
    // ═══════════════════════════════════════════════════════════════
    function defaultProportions() {
      return {
        bodyLength: 2.9, bodyGirthX: 1.55, bodyGirthY: 1.5,
        ribcageDepth: 1.0, waistTaper: 0.65, haunchWidth: 0.95, shoulderWidth: 0.85,
        neckLength: 0.8, neckGirth: 0.55,
        headSize: 1.0, snoutLength: 1.4, snoutWidth: 1.15, cheekFullness: 0.4,
        earSize: 0.85, earSetBack: -0.35, earYaw: 0.75, earThickness: 0.06,
        eyeSize: 0.16, eyeSpacing: 0.50, eyeProtrusion: 1.15, eyeYaw: 0.5,
        foreLimbLength: 1.0, hindLimbLength: 0.78,
        forePawSize: 1.0, hindPawSize: 0.88,
        tailLength: 1.0, tailThickness: 1.0, tailTaper: 0.88, tailSag: 0.02,
      };
    }
    const PROP = defaultProportions();

    // ═══════════════════════════════════════════════════════════════
    // 3. PROCEDURAL CANVAS TEXTURES (micro-normal + roughness)
    // ═══════════════════════════════════════════════════════════════
    function createPadNormalMap(size = 128) {
      const c = document.createElement('canvas'); c.width = c.height = size;
      const ctx = c.getContext('2d');
      ctx.fillStyle = '#8080ff';
      ctx.fillRect(0, 0, size, size);
      // Micro bumps
      for (let i = 0; i < 800; i++) {
        const x = Math.random() * size, y = Math.random() * size;
        const r = 1 + Math.random() * 2;
        const v = 120 + Math.floor(Math.random() * 16);
        ctx.fillStyle = `rgb(${v},${v},255)`;
        ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
      }
      const tex = new THREE.CanvasTexture(c);
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      return tex;
    }
    function createTailRingRoughnessMap(size = 256) {
      const c = document.createElement('canvas'); c.width = size; c.height = size;
      const ctx = c.getContext('2d');
      for (let y = 0; y < size; y++) {
        const band = Math.sin(y * 0.35) * 0.5 + 0.5;
        const v = Math.floor(140 + band * 60);
        ctx.fillStyle = `rgb(${v},${v},${v})`;
        ctx.fillRect(0, y, size, 1);
      }
      const tex = new THREE.CanvasTexture(c);
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      return tex;
    }
    const padNormalMap = createPadNormalMap();
    const tailRoughnessMap = createTailRingRoughnessMap();

    // ═══════════════════════════════════════════════════════════════
    // 4. PBR MATERIALS
    // ═══════════════════════════════════════════════════════════════
    const fleshMatBase = new THREE.MeshPhysicalMaterial({
      roughness: 0.55, transmission: 0.15, thickness: 1.5,
      attenuationDistance: 1.0, clearcoat: 0.1, clearcoatRoughness: 0.2,
      sheen: 1.0, sheenColor: new THREE.Color(0xffeebb),
    });
    const clawMat = new THREE.MeshPhysicalMaterial({ color: 0xd7cdc2, roughness: 0.2, metalness: 0.1, clearcoat: 1.0, clearcoatRoughness: 0.1 });
    // Two-layer eye
    const eyeMat = new THREE.MeshPhysicalMaterial({
      color: 0x020202, roughness: 0.0, metalness: 0.05,
      clearcoat: 1.0, clearcoatRoughness: 0.02, envMapIntensity: 4.0,
      sheen: 0.5, sheenColor: new THREE.Color(0x333344),
    });
    const corneaMat = new THREE.MeshPhysicalMaterial({
      color: 0x000000, transparent: true, opacity: 0.12,
      roughness: 0.0, metalness: 0.0, ior: 1.38,
      clearcoat: 1.0, clearcoatRoughness: 0.0, envMapIntensity: 5.0,
    });

    // ═══════════════════════════════════════════════════════════════
    // 5. DEFORMATION FUNCTIONS
    // ═══════════════════════════════════════════════════════════════
    function deform(geometry, deformFn) {
      const pos = geometry.attributes.position;
      const v = new THREE.Vector3();
      for (let i = 0; i < pos.count; i++) {
        v.fromBufferAttribute(pos, i);
        deformFn(v);
        pos.setXYZ(i, v.x, v.y, v.z);
      }
      geometry.computeVertexNormals();
      return geometry;
    }

    const deformBody = (v) => {
      const zNorm = (v.z + 1) / 2;
      // Pear/teardrop: wide haunches → narrower shoulders
      const haunchW = 1.0 + (1.0 - zNorm) * 0.2;
      const shoulderT = 1.0 - zNorm * 0.35;
      const lateral = shoulderT * haunchW;
      v.x *= lateral * PROP.bodyGirthX;
      v.y *= shoulderT * PROP.bodyGirthY;
      v.z *= PROP.bodyLength;
      // Spinal curve
      const spineY = Math.sin(Math.pow(zNorm, 0.7) * Math.PI) * 0.9;
      v.y += spineY;
      // Belly bulge
      if (v.y < 0.2 && v.y > -0.5) {
        const bulge = (1.0 - Math.abs(zNorm - 0.4) * 1.5) * 0.12;
        v.x *= 1.0 + Math.max(0, bulge);
      }
      if (v.y < 0) v.y *= 0.5;
      // Rump rounding
      if (zNorm < 0.25) {
        v.y += (0.25 - zNorm) * 0.35;
        v.x *= 1.0 + (0.25 - zNorm) * 0.2;
      }
      // Shoulder mass / scapula region
      if (zNorm > 0.65 && zNorm < 0.85 && Math.abs(v.x) > 0.3) {
        const scapBulge = (1.0 - Math.abs(zNorm - 0.75) * 10.0);
        if (scapBulge > 0) {
          v.x *= 1.0 + scapBulge * 0.08;
          if (v.y > 0) v.y += scapBulge * 0.06;
        }
      }
      // Waist taper
      if (zNorm > 0.4 && zNorm < 0.65) {
        const taper = 1.0 - (1.0 - Math.abs(zNorm - 0.52) * 5.0) * (1.0 - PROP.waistTaper) * 0.15;
        v.x *= Math.max(0.85, taper);
      }
      // Haunch bulge at hind leg attachment
      if (zNorm > 0.15 && zNorm < 0.4 && Math.abs(v.x) > 0.3) {
        const hB = (1.0 - Math.abs(zNorm - 0.27) * 5.0);
        if (hB > 0) { v.x *= 1.0 + hB * 0.12; if (v.y < 0) v.y *= 1.0 + hB * 0.08; }
      }
      // Neck transition: slight narrowing at front
      if (zNorm > 0.85) {
        const neckT = (zNorm - 0.85) / 0.15;
        v.x *= 1.0 - neckT * 0.2;
        v.y *= 1.0 - neckT * 0.15;
      }
    };

    const deformHead = (v) => {
      const zNorm = (v.z + 1) / 2;
      const snoutTaper = Math.pow(1.0 - zNorm * 0.6, 1.0);
      v.x *= snoutTaper * PROP.snoutWidth;
      v.y *= snoutTaper * 0.98;
      v.z *= PROP.snoutLength;
      v.y -= zNorm * 0.12;
      // Cheeks
      if (zNorm < 0.5) {
        const cF = (0.5 - zNorm) * PROP.cheekFullness;
        v.x *= 1.0 + cF;
        if (v.y < 0) v.x *= 1.0 + cF * 0.4;
      }
      // Snout narrowing
      if (zNorm > 0.6) {
        const p = (zNorm - 0.6) / 0.4;
        v.x *= 1.0 - p * 0.35;
        v.y *= 1.0 - p * 0.15;
        v.y -= p * 0.04;
      }
      // Cranial dome
      if (zNorm > 0.1 && zNorm < 0.55 && v.y > 0) {
        const dF = 1.0 - Math.abs(zNorm - 0.3) * 2.5;
        v.y += Math.max(0, dF) * 0.2;
      }
      // Orbital ridges
      if (zNorm > 0.3 && zNorm < 0.5 && Math.abs(v.x) > 0.3) v.y += 0.04;
    };

    const deformThigh = (v) => {
      v.x *= 0.6; v.y *= 1.2; v.z *= 1.2; v.z -= v.y * 0.3;
    };

    const deformEar = (v) => {
      const y01 = (v.y + 1.0) * 0.5;
      const radial = Math.sqrt(v.x * v.x + v.y * v.y);
      v.x *= 1.3; v.y *= 1.25; v.z *= PROP.earThickness;
      const concave = Math.pow(radial, 1.4) * 0.7;
      v.z -= concave;
      const rimDist = Math.abs(radial - 0.85);
      if (rimDist < 0.15) { const rS = 1.0 - rimDist / 0.15; v.z += rS * rS * 0.12; }
      if (y01 < 0.3) {
        const taper = Math.pow(y01 / 0.3, 0.7);
        v.x *= taper; v.z += (0.3 - y01) * 0.5; v.z *= 1.0 + (0.3 - y01) * 2.0;
      }
      if (y01 > 0.75) {
        const tR = 1.0 - (y01 - 0.75) * 2.0;
        v.x *= Math.max(0.15, tR); v.y *= Math.max(0.6, tR);
      }
      v.z -= (1.0 - y01) * 0.08;
    };

    // Upper arm / forearm deform
    const deformUpperArm = (v) => {
      // Slight taper from shoulder to elbow
      const t = (v.y + 1) / 2;
      v.x *= 0.7 - t * 0.15;
      v.z *= 0.7 - t * 0.15;
      v.y *= 0.45;
    };

    const bodyGeo = deform(new THREE.SphereGeometry(1, 64, 64), deformBody);
    const headGeo = deform(new THREE.SphereGeometry(1, 48, 48), deformHead);
    const thighGeo = deform(new THREE.SphereGeometry(1, 32, 32), deformThigh);
    const earGeo = deform(new THREE.SphereGeometry(1, 32, 32), deformEar);


    // ═══════════════════════════════════════════════════════════════
    // 6. PAW BUILDER (anatomically correct forepaw vs hindpaw)
    // ═══════════════════════════════════════════════════════════════
    function createPaw(mat, isFore = false, strain = {}) {
      const paw = new THREE.Group();
      const padMat = mat.clone();
      padMat.color.multiplyScalar(strain.padDarken ?? 0.84);
      padMat.transmission = 0.18; padMat.thickness = 0.35;
      padMat.roughness = 0.52; padMat.normalMap = padNormalMap;
      padMat.normalScale = new THREE.Vector2(0.3, 0.3);

      const pawScale = isFore ? (PROP.forePawSize) : (PROP.hindPawSize);

      if (isFore) {
        // Palm pad
        const palm = new THREE.Mesh(new THREE.SphereGeometry(0.08, 16, 16), padMat);
        palm.scale.set(1.1 * pawScale, 0.4, 0.9 * pawScale);
        palm.position.set(0, -0.04, 0.05);
        palm.castShadow = true; paw.add(palm);
        // 3 interdigital pads
        for (let p = 0; p < 3; p++) {
          const iPad = new THREE.Mesh(new THREE.SphereGeometry(0.045, 12, 12), padMat);
          iPad.scale.set(1 * pawScale, 0.5, 1 * pawScale);
          iPad.position.set((p - 1) * 0.05 * pawScale, -0.04, 0.0);
          iPad.castShadow = true; paw.add(iPad);
        }
      } else {
        // Hind sole - longer
        const sole = new THREE.Mesh(new THREE.SphereGeometry(0.16, 20, 20), padMat);
        sole.scale.set(1.1 * pawScale, 0.4, 1.5 * pawScale);
        sole.position.set(0, -0.04, 0.03);
        sole.castShadow = true; paw.add(sole);
        // Heel pad (hind only)
        const heelPad = new THREE.Mesh(new THREE.SphereGeometry(0.08, 12, 12), padMat);
        heelPad.scale.set(1.0, 0.5, 1.2);
        heelPad.position.set(0, -0.03, -0.12 * pawScale);
        heelPad.castShadow = true; paw.add(heelPad);
      }

      const pawSpreadMul = strain.pawSpreadMul ?? 1.0;
      const toeCount = isFore ? 4 : 5;
      const baseSpread = isFore ? 0.12 : 0.10;
      const spread = baseSpread * pawSpreadMul * pawScale;

      const clawLocalMat = new THREE.MeshPhysicalMaterial({ color: strain.clawColor ?? 0xd7cdc2, roughness: 0.3, clearcoat: 0.8 });

      for (let i = 0; i < toeCount; i++) {
        const t = (i - (toeCount - 1) * 0.5) * spread;
        const arc = (Math.abs(i - (toeCount - 1) * 0.5) / (toeCount * 0.5 + 0.01));
        const toe = new THREE.Group();
        let lenMul = 1.0;
        if (isFore && (i === 0 || i === 3)) lenMul = 0.8;
        if (!isFore && (i === 0 || i === 4)) lenMul = 0.75;
        const toeLen = (isFore ? 0.22 : 0.25) * (strain.toeLenMul ?? 1.0) * lenMul * pawScale;
        const p1 = new THREE.Mesh(new THREE.CapsuleGeometry(isFore ? 0.025 : 0.034, toeLen, 10, 10), mat);
        p1.rotation.x = Math.PI / 2;
        p1.castShadow = true; toe.add(p1);
        if (isFore) {
          const knuckle = new THREE.Mesh(new THREE.SphereGeometry(0.032, 10, 10), mat);
          knuckle.position.set(0, 0.012, -toeLen * 0.35);
          knuckle.castShadow = true; toe.add(knuckle);
          p1.rotation.x = Math.PI / 2 - 0.15;
        }
        let zPos = isFore ? (0.16 - arc * 0.04) : (0.24 - arc * 0.03);
        zPos *= pawScale;
        toe.position.set(t, -0.035 + arc * 0.012, zPos);
        // Slight toe splay/curvature
        toe.rotation.y = t * 0.3;
        toe.rotation.x = -arc * 0.1;
        paw.add(toe);
        const toePad = new THREE.Mesh(new THREE.SphereGeometry(isFore ? 0.035 : 0.045, 10, 10), padMat);
        toePad.scale.set(1.15, 0.48, 1.0);
        toePad.position.set(t, -0.12 + arc * 0.008, zPos + (isFore ? 0.09 : 0.08) * lenMul);
        toePad.castShadow = true; paw.add(toePad);
        const clawLength = isFore ? 0.05 : 0.07;
        const clawGeo = new THREE.ConeGeometry(isFore ? 0.012 : 0.016, clawLength, 8);
        clawGeo.translate(0, -clawLength / 2, 0);
        const claw = new THREE.Mesh(clawGeo, clawLocalMat);
        claw.rotation.x = Math.PI / 2 + (isFore ? -0.2 : 0);
        claw.position.set(t, -0.06 + arc * 0.004, zPos + (isFore ? 0.13 : 0.17) * lenMul * pawScale);
        claw.castShadow = true; paw.add(claw);
      }
      return paw;
    }

    // ═══════════════════════════════════════════════════════════════
    // 7. LIMB CHAIN BUILDERS
    // ═══════════════════════════════════════════════════════════════
    function createForelimbChain(fleshMat, strain, density, furColor, side) {
      const sign = side === 'L' ? 1 : -1;
      const chain = new THREE.Group();
      const fl = PROP.foreLimbLength;
      // Scapula/shoulder anchor — place at shoulder width, slightly below spine
      chain.position.set(sign * 0.66 * PROP.shoulderWidth / 0.85, -0.08, PROP.bodyLength * 0.64);

      // Upper arm (humerus) — substantial visible segment
      const upperArm = new THREE.Group();
      const uaLen = 0.5 * fl;
      const upperArmMesh = new THREE.Mesh(
        new THREE.CapsuleGeometry(0.16, uaLen, 10, 10), fleshMat
      );
      upperArmMesh.position.y = -uaLen * 0.5;
      upperArmMesh.castShadow = true;
      upperArm.add(upperArmMesh);
      // Shoulder joint sphere (visible scapula bump)
      const shoulderJoint = new THREE.Mesh(new THREE.SphereGeometry(0.18, 12, 12), fleshMat);
      shoulderJoint.scale.set(1.1, 0.9, 1.0);
      shoulderJoint.castShadow = true;
      upperArm.add(shoulderJoint);
      chain.add(upperArm);

      // Forearm (radius/ulna) — attached at elbow
      const forearm = new THREE.Group();
      const faLen = 0.45 * fl;
      forearm.position.set(0, -uaLen - 0.015, 0.055);
      // Soft-tissue bridge to avoid segmented look between upper arm and forearm.
      const elbowBridge = new THREE.Mesh(new THREE.CapsuleGeometry(0.125, 0.09, 10, 10), fleshMat);
      elbowBridge.position.set(0, -uaLen * 0.92, 0.03);
      elbowBridge.rotation.x = 0.15;
      elbowBridge.castShadow = true;
      upperArm.add(elbowBridge);
      // Elbow joint
      const elbowJoint = new THREE.Mesh(new THREE.SphereGeometry(0.12, 10, 10), fleshMat);
      elbowJoint.scale.set(1.08, 0.95, 1.0);
      elbowJoint.castShadow = true;
      forearm.add(elbowJoint);
      const forearmMesh = new THREE.Mesh(
        new THREE.CapsuleGeometry(0.11, faLen, 8, 8), fleshMat
      );
      forearmMesh.position.y = -faLen * 0.5;
      forearmMesh.castShadow = true;
      forearm.add(forearmMesh);
      upperArm.add(forearm);

      // Wrist joint
      const wrist = new THREE.Group();
      wrist.position.set(0, -faLen - 0.02, 0.05);
      const wristJoint = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), fleshMat);
      wristJoint.scale.set(1.1, 0.95, 1.05);
      wristJoint.castShadow = true;
      wrist.add(wristJoint);
      const wristCuff = new THREE.Mesh(new THREE.CapsuleGeometry(0.09, 0.08, 8, 8), fleshMat);
      wristCuff.position.set(0, -0.03, 0.02);
      wristCuff.rotation.x = 0.18;
      wristCuff.castShadow = true;
      wrist.add(wristCuff);
      forearm.add(wrist);

      // Paw — sits at bottom of wrist
      const paw = createPaw(fleshMat, true, strain);
      paw.position.set(0, -0.12, 0.05);
      paw.scale.set(1.2, 1.2, 1.2);
      wrist.add(paw);

      // Short fur on upper arm + forearm
      const furCount = Math.floor(2000 * density);
      if (furCount > 0) {
        const fGeo = new THREE.ConeGeometry(0.006, 0.08, 3);
        fGeo.translate(0, 0.04, 0);
        const fMat = new THREE.MeshPhysicalMaterial({ color: new THREE.Color(furColor), roughness: 0.7, transparent: true, opacity: 0.8 });
        const fInst = new THREE.InstancedMesh(fGeo, fMat, furCount);
        const d = new THREE.Object3D();
        for (let i = 0; i < furCount; i++) {
          const h = (Math.random() - 0.5) * uaLen * 0.9;
          const ang = Math.random() * Math.PI * 2;
          const r = 0.12 + Math.random() * 0.05;
          d.position.set(Math.cos(ang) * r, h, Math.sin(ang) * r);
          const nrm = new THREE.Vector3(Math.cos(ang), 0.3, Math.sin(ang)).normalize();
          d.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), nrm);
          const s = 0.7 + Math.random() * 0.6;
          d.scale.set(s, s, s); d.updateMatrix();
          fInst.setMatrixAt(i, d.matrix);
        }
        upperArmMesh.add(fInst);
      }

      chain._upperArm = upperArm;
      chain._forearm = forearm;
      chain._wrist = wrist;
      chain._paw = paw;
      return chain;
    }

    function createHindlimbChain(fleshMat, strain, density, furColor, side) {
      const sign = side === 'L' ? 1 : -1;
      const chain = new THREE.Group();
      const hl = PROP.hindLimbLength;
      // Hip anchor — at widest haunch point
      chain.position.set(sign * 0.50 * PROP.haunchWidth / 1.2, 0.14, -PROP.bodyLength * 0.40);

      // Hip joint (visible mass)
      const hipJoint = new THREE.Mesh(new THREE.SphereGeometry(0.15, 12, 12), fleshMat);
      hipJoint.scale.set(0.86, 0.72, 0.88);
      hipJoint.castShadow = true;
      chain.add(hipJoint);
      // Soft blend into lower back to avoid a hard hip seam.
      const hipBlend = new THREE.Mesh(new THREE.CapsuleGeometry(0.12, 0.24, 10, 10), fleshMat);
      hipBlend.position.set(0, 0.10, -0.06);
      hipBlend.rotation.x = 0.45;
      hipBlend.scale.set(1.05, 0.85, 1.2);
      hipBlend.castShadow = true;
      chain.add(hipBlend);
      // Extra local fur on hip blend to hide seam against back.
      const hipFurCount = Math.floor(3800 * density);
      if (hipFurCount > 0) {
        const hfGeo = new THREE.ConeGeometry(0.006, 0.09, 3);
        hfGeo.translate(0, 0.045, 0);
        const hfMat = new THREE.MeshPhysicalMaterial({
          color: new THREE.Color(furColor), roughness: 0.78, transparent: true, opacity: 0.84
        });
        const hfInst = new THREE.InstancedMesh(hfGeo, hfMat, hipFurCount);
        const hDummy = new THREE.Object3D();
        const hNrm = new THREE.Vector3();
        for (let i = 0; i < hipFurCount; i++) {
          const theta = Math.random() * Math.PI * 2;
          const y = (Math.random() - 0.5) * 1.6;
          hNrm.set(Math.cos(theta) * 0.95, y * 0.45, Math.sin(theta) * 1.1).normalize();
          hDummy.position.set(hNrm.x * 0.16, hNrm.y * 0.18, hNrm.z * 0.17);
          hDummy.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), hNrm);
          const s = 0.72 + Math.random() * 0.55;
          hDummy.scale.set(s, s, s);
          hDummy.updateMatrix();
          hfInst.setMatrixAt(i, hDummy.matrix);
        }
        hipBlend.add(hfInst);
      }

      // Thigh (femur) — enlarged deformed sphere
      const thigh = new THREE.Mesh(thighGeo, fleshMat);
      thigh.position.set(0, -0.06, 0.02);
      thigh.scale.set(0.94, 0.86 * hl, 0.98);
      thigh.castShadow = true;
      chain.add(thigh);
      thigh.add(generateFurLayer(deformThigh, Math.floor(8200 * density), furColor, 0.15, false));

      // Shank (tibia/fibula) — substantial capsule
      const shank = new THREE.Group();
      shank.position.set(0.02 * sign, -0.75 * hl, 0.18);
      thigh.add(shank);

      // Knee joint (visible bump)
      const kneeJoint = new THREE.Mesh(new THREE.SphereGeometry(0.12, 10, 10), fleshMat);
      kneeJoint.position.set(0, 0.05, 0);
      kneeJoint.castShadow = true;
      shank.add(kneeJoint);

      const shankLen = 0.55 * hl;
      const shankMesh = new THREE.Mesh(new THREE.CapsuleGeometry(0.10, shankLen, 8, 8), fleshMat);
      shankMesh.rotation.x = -0.05;
      shankMesh.position.set(0, -shankLen * 0.5, 0.05);
      shankMesh.castShadow = true;
      shank.add(shankMesh);

      // Ankle/heel (digitigrade visible heel rise)
      const ankle = new THREE.Group();
      ankle.position.set(0, -shankLen - 0.05, 0.12);
      shank.add(ankle);

      const ankleJoint = new THREE.Mesh(new THREE.SphereGeometry(0.10, 10, 10), fleshMat);
      ankleJoint.castShadow = true;
      ankle.add(ankleJoint);

      // Heel bone (calcaneus) - visible heel rise
      const heel = new THREE.Mesh(new THREE.SphereGeometry(0.12, 14, 14), fleshMat);
      heel.scale.set(0.9, 1.1, 1.3);
      heel.position.set(0, 0.02, -0.08);
      heel.castShadow = true;
      ankle.add(heel);

      // Metatarsals (connects heel to toes) — angled forward
      const metaLen = 0.25 * PROP.hindPawSize;
      const metaMesh = new THREE.Mesh(new THREE.CapsuleGeometry(0.07, metaLen, 6, 6), fleshMat);
      metaMesh.rotation.x = Math.PI / 2 - 0.35;
      metaMesh.position.set(0, -0.10, 0.12);
      metaMesh.castShadow = true;
      ankle.add(metaMesh);

      // Hindpaw — planted on ground
      const paw = createPaw(fleshMat, false, strain);
      paw.position.set(0, -0.16, 0.24);
      paw.scale.set(1.15, 1.15, 1.15);
      ankle.add(paw);

      chain._thigh = thigh;
      chain._shank = shank;
      chain._ankle = ankle;
      chain._paw = paw;
      return chain;
    }

    // ═══════════════════════════════════════════════════════════════
    // 8. WHISKERS + FUR (preserved from original with detail-level support)
    // ═══════════════════════════════════════════════════════════════
    function createVolumetricWhiskers(colorHex, isLeft) {
      const group = new THREE.Group();
      const mat = new THREE.MeshBasicMaterial({ color: colorHex, transparent: true, opacity: 0.5 });
      const sign = isLeft ? 1 : -1;
      for (let i = 0; i < 18; i++) {
        const curve = new THREE.QuadraticBezierCurve3(
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(sign * 0.6, (Math.random() - 0.5) * 0.3, 0.3),
          new THREE.Vector3(sign * (1.2 + Math.random() * 0.6), (Math.random() - 0.5) * 0.8, 0.4 + Math.random() * 0.6)
        );
        group.add(new THREE.Mesh(new THREE.TubeGeometry(curve, 6, 0.005, 4, false), mat));
      }
      return group;
    }

    function generateFurLayer(deformFn, count, colorHex, length, isHead, isUndercoat = false) {
      if (count <= 0) return new THREE.Group();
      const radius = isUndercoat ? 0.025 : 0.016;
      const geo = new THREE.ConeGeometry(radius, length, 4);
      geo.translate(0, length / 2, 0); geo.rotateX(-Math.PI / 2);
      const mat = new THREE.MeshPhysicalMaterial({
        color: colorHex, roughness: isUndercoat ? 0.92 : 0.75,
        clearcoat: isUndercoat ? 0.0 : 0.12,
        sheen: isUndercoat ? 0.7 : 1.2, sheenColor: new THREE.Color(0xffffff),
        sheenRoughness: isUndercoat ? 0.7 : 0.35,
      });
      const inst = new THREE.InstancedMesh(geo, mat, count);
      inst.receiveShadow = true;
      inst.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(count * 3), 3);
      const baseColor = new THREE.Color(colorHex);
      const strandColor = new THREE.Color();
      const dummy = new THREE.Object3D();
      const pos = new THREE.Vector3(), normal = new THREE.Vector3();
      for (let i = 0; i < count; i++) {
        const u = Math.random(), vv = Math.random();
        const theta = u * 2 * Math.PI, phi = Math.acos(2 * vv - 1);
        pos.set(Math.sin(phi) * Math.cos(theta), Math.sin(phi) * Math.sin(theta), Math.cos(phi));
        normal.copy(pos).normalize();
        const preZ = pos.z;
        deformFn(pos);
        pos.addScaledVector(normal, isUndercoat ? 0.005 : 0.012);
        let flowDir;
        if (isHead && preZ > 0.3) flowDir = new THREE.Vector3(normal.x * 0.15, -0.2, -1).normalize();
        else if (isHead) flowDir = new THREE.Vector3(normal.x * 0.3, normal.y * 0.2, -1).normalize();
        else flowDir = new THREE.Vector3(normal.x * 0.5, normal.y * 0.3 - 0.15, -1).normalize();
        if (isUndercoat) { flowDir.lerp(new THREE.Vector3(0, 0, -1), 0.3); flowDir.normalize(); }
        dummy.position.copy(pos);
        dummy.lookAt(pos.clone().add(flowDir));
        let scale = 0.5 + Math.random() * 0.7;
        if (isHead && preZ > 0.4) scale *= 0.3;
        if (isHead && preZ > 0.2 && preZ <= 0.4) scale *= 0.6;
        if (!isHead && preZ < -0.6) scale *= 1.25;
        if (isUndercoat) scale = 0.6 + Math.random() * 0.3;
        const jitter = isUndercoat ? 0.15 : 0.08;
        dummy.rotation.x += (Math.random() - 0.5) * jitter;
        dummy.rotation.y += (Math.random() - 0.5) * jitter;
        dummy.scale.set(scale, scale, scale); dummy.updateMatrix();
        inst.setMatrixAt(i, dummy.matrix);
        strandColor.copy(baseColor);
        const hsl = {}; strandColor.getHSL(hsl);
        const lumV = isUndercoat ? 0.06 : 0.08;
        strandColor.setHSL(hsl.h + (Math.random() - 0.5) * 0.02,
          Math.max(0, Math.min(1, hsl.s + (Math.random() - 0.5) * 0.05)),
          Math.max(0, Math.min(1, hsl.l + (Math.random() - 0.5) * lumV)));
        inst.instanceColor.setXYZ(i, strandColor.r, strandColor.g, strandColor.b);
      }
      return inst;
    }

    // Fur detail-level multipliers
    const FUR_DETAIL = { High: 1.0, Med: 0.5, Low: 0.2, Off: 0.0 };

    function generateMultiLayerFur(deformFn, density, furColor, isHead) {
      const group = new THREE.Group();
      if (density <= 0) return group;
      const vellusCount = Math.floor((isHead ? 8000 : 15000) * density);
      const underCount = Math.floor((isHead ? 18000 : 35000) * density);
      const guardCount = Math.floor((isHead ? 20000 : 40000) * density);
      group.add(generateFurLayer(deformFn, vellusCount, furColor, isHead ? 0.03 : 0.05, isHead, true));
      group.add(generateFurLayer(deformFn, underCount, furColor, isHead ? 0.07 : 0.12, isHead, true));
      group.add(generateFurLayer(deformFn, guardCount, furColor, isHead ? 0.14 : 0.24, isHead, false));
      return group;
    }


    // ═══════════════════════════════════════════════════════════════
    // 9. ENCLOSURE + CONTACT SHADOW + POSE CONSTANTS
    // ═══════════════════════════════════════════════════════════════
    const ENCLOSURE_W = 36, ENCLOSURE_H = 9, ENCLOSURE_D = 26, ENCLOSURE_PAD = 1.6;
    const ENCLOSURE_HALF_X = ENCLOSURE_W * 0.5 - ENCLOSURE_PAD;
    const ENCLOSURE_HALF_Z = ENCLOSURE_D * 0.5 - ENCLOSURE_PAD;

    // Contact shadow (soft AO disc under each mouse)
    function createContactShadow() {
      const c = document.createElement('canvas'); c.width = c.height = 64;
      const ctx = c.getContext('2d');
      const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
      grad.addColorStop(0, 'rgba(0,0,0,0.35)');
      grad.addColorStop(0.5, 'rgba(0,0,0,0.15)');
      grad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = grad; ctx.fillRect(0, 0, 64, 64);
      const tex = new THREE.CanvasTexture(c);
      const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, depthWrite: false, depthTest: false });
      const geo = new THREE.PlaneGeometry(5, 4);
      const mesh = new THREE.Mesh(geo, mat);
      mesh.rotation.x = -Math.PI / 2;
      mesh.position.y = 0.02;
      mesh.renderOrder = 5;
      return mesh;
    }

    const POSE_CONNECTIONS = [
      ['snout', 'lear'], ['snout', 'rear'], ['lear', 'neck'], ['rear', 'neck'],
      ['neck', 'spine1'], ['spine1', 'spine2'], ['spine2', 'tailbase'],
      ['neck', 'lforepaw'], ['neck', 'rforepaw'],
      ['spine2', 'lhindpaw'], ['spine2', 'rhindpaw'],
      ['tailbase', 'tailmid'], ['tailmid', 'tailend']
    ];
    const POSE_COLORS = {
      snout: 0xff0055, lear: 0xff5500, rear: 0xff5500, neck: 0x00ffaa,
      spine1: 0x00aaff, spine2: 0x0055ff, tailbase: 0xaa00ff,
      lforepaw: 0xaaff00, rforepaw: 0xaaff00, lhindpaw: 0x00ff00, rhindpaw: 0x00ff00,
      tailmid: 0xff00ff, tailend: 0xff00aa
    };

    // ═══════════════════════════════════════════════════════════════
    // 10. EXPERT MOUSE CLASS (with new anatomy)
    // ═══════════════════════════════════════════════════════════════
    class ExpertMouse {
      constructor(params) {
        this.mesh = new THREE.Group();
        this.timeOffset = Math.random() * 1000;
        this.locomotionTime = 0;
        this.guiParams = params;

        // Physics state
        this.velocity = new THREE.Vector2(0, 0);
        this.force = new THREE.Vector2(0, 0);
        this.heading = new THREE.Vector2(0, 1);
        this.mass = 0.025 + Math.random() * 0.010;
        this.maxSpeed = 8.0 + Math.random() * 3.0;
        this.drag = 2.5;
        this.wanderAngle = Math.random() * Math.PI * 2;
        this.wanderRate = 0.8 + Math.random() * 0.6;
        this.wanderStrength = 2.5 + Math.random() * 1.5;
        this.burstPhase = Math.random() * Math.PI * 2;
        this.speedMult = 0.8 + Math.random() * 0.5;
        this.dir = Math.random() > 0.5 ? 1 : -1;
        this.wallFollowDir = Math.random() > 0.5 ? 1 : -1;
        this.lastPos = new THREE.Vector2(0, 0);
        this.stuckTimer = 0;
        this.lowSpeedTimer = 0;
        this.tailSegLen = 0.22;
        this.rearAmount = 0;
        this.rearVel = 0;
        this.rearCooldown = 0;
        this.prevVelocity = new THREE.Vector2(0, 0);
        this.prevHeadingAngle = Math.atan2(this.heading.x, this.heading.y);
        this.yawAngle = this.prevHeadingAngle;
        this.yawVel = 0;
        this.bodyDyn = { y: 1.3, vy: 0, pitch: 0, pitchV: 0, roll: 0, rollV: 0 };
        this.tailDyn = { sway: 0, swayV: 0, lift: 0, liftV: 0 };

        const furColor = params.furColor;
        const skinColor = params.skinColor;
        const density = FUR_DETAIL[params.furDetailLevel || 'Med'] * (params.furDensity || 0.85);
        const chonk = params.chonkiness;
        const eSize = params.earSize;
        const strain = getStrainProfile(params.presets);

        // Per-instance subtle asymmetry
        this.asymmetry = {
          earTiltL: (Math.random() - 0.5) * 0.06,
          earTiltR: (Math.random() - 0.5) * 0.06,
          earHeightDiff: (Math.random() - 0.5) * 0.03,
          noseYaw: (Math.random() - 0.5) * 0.03,
          haunchDiff: (Math.random() - 0.5) * 0.02,
          eyeOffsetL: (Math.random() - 0.5) * 0.01,
          eyeOffsetR: (Math.random() - 0.5) * 0.01,
        };

        this.motion = {
          gaitAmpMul: strain.gaitAmpMul ?? 1.0,
          headIdleYawMul: strain.headIdleYawMul ?? 1.0,
          headIdlePitchMul: strain.headIdlePitchMul ?? 1.0,
          sniffAmpMul: strain.sniffAmpMul ?? 1.0,
          breathIdleAmp: strain.breathIdleAmp ?? 0.013,
          breathMoveAmp: strain.breathMoveAmp ?? 0.016,
          breathIdleFreq: strain.breathIdleFreq ?? 12.0,
          breathMoveFreq: strain.breathMoveFreq ?? 20.0,
          tailWaveAmpMul: strain.tailWaveAmpMul ?? 1.0,
          tailWaveFreqMul: strain.tailWaveFreqMul ?? 1.0
        };

        // Flesh material
        this.fleshMat = fleshMatBase.clone();
        this.fleshMat.color.set(skinColor);
        const skinHSL = {}; this.fleshMat.color.getHSL(skinHSL);
        this.fleshMat.attenuationColor.setHSL(skinHSL.h, skinHSL.s, skinHSL.l * 0.5);

        // ═══ APPLY GLSL SHADERS ═══
        if (params.enableSSS !== false) {
          annolidShaders.applySSSShader(this.fleshMat, {
            scatterColor: [this.fleshMat.color.r * 0.9, this.fleshMat.color.g * 0.9, this.fleshMat.color.b * 0.9],
            thickness: params.sssThickness ?? 0.45,
            distortion: 0.2,
            wrap: params.sssWrap ?? 0.5,
            backlight: params.sssBacklight ?? 0.6
          });
        }
        if (params.enableContactAO !== false) {
          annolidShaders.applyContactAO(this.fleshMat, {
            groundY: 0.0,
            radius: params.aoRadius ?? 1.5,
            intensity: params.aoIntensity ?? 0.35,
            color: [0.02, 0.01, 0.0]
          });
        }
        if (params.enableMicroDetail !== false) {
          annolidShaders.applyMicroDetail(this.fleshMat, {
            scale: params.microScale ?? 40.0,
            strength: params.microStrength ?? 0.06
          });
        }

        // --- RIG HIERARCHY ---
        this.rig = new THREE.Group();
        this.mesh.add(this.rig);

        // BODY
        this.bodyMesh = new THREE.Mesh(bodyGeo, this.fleshMat);
        this.bodyMesh.scale.set(1, chonk, chonk);
        this.bodyMesh.castShadow = true;
        this.rig.add(this.bodyMesh);
        this.bodyMesh.add(generateMultiLayerFur(deformBody, density, furColor, false));

        // NECK
        const neckGeo = new THREE.CapsuleGeometry(PROP.neckGirth, PROP.neckLength, 12, 12);
        const neckMesh = new THREE.Mesh(neckGeo, this.fleshMat);
        neckMesh.position.set(0, 0.15, PROP.bodyLength * 0.76);
        neckMesh.rotation.x = Math.PI / 2 + 0.15;
        neckMesh.scale.set(1.0, 1.0, 0.85);
        neckMesh.castShadow = true;
        this.rig.add(neckMesh);
        // Neck fur
        const neckFurCount = Math.floor(4000 * density);
        if (neckFurCount > 0) {
          const nfGeo = new THREE.ConeGeometry(0.008, 0.12, 3);
          nfGeo.translate(0, 0.06, 0);
          const nfMat = new THREE.MeshPhysicalMaterial({ color: new THREE.Color(furColor), roughness: 0.7, transparent: true, opacity: 0.85 });
          const nfInst = new THREE.InstancedMesh(nfGeo, nfMat, neckFurCount);
          const nkDummy = new THREE.Object3D(), nkNrm = new THREE.Vector3();
          for (let i = 0; i < neckFurCount; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = (Math.random() - 0.5) * Math.PI * 0.8;
            nkNrm.set(Math.cos(theta) * Math.cos(phi) * 0.55, Math.sin(phi) * 0.4, Math.sin(theta) * Math.cos(phi) * 0.55);
            nkDummy.position.copy(nkNrm); nkDummy.position.y += (Math.random() - 0.5) * 0.6;
            nkNrm.normalize();
            nkDummy.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), nkNrm);
            const s = 0.8 + Math.random() * 0.4;
            nkDummy.scale.set(s, s, s); nkDummy.updateMatrix();
            nfInst.setMatrixAt(i, nkDummy.matrix);
          }
          neckMesh.add(nfInst);
        }

        // BELLY BRIDGE
        const bellyGeo = new THREE.CapsuleGeometry(0.4, 1.2, 8, 8);
        const bellyMesh = new THREE.Mesh(bellyGeo, this.fleshMat);
        bellyMesh.position.set(0, -0.47, PROP.bodyLength * 0.58);
        bellyMesh.rotation.x = Math.PI / 2;
        bellyMesh.scale.set(0.86, 0.70, 0.48);
        this.rig.add(bellyMesh);

        // HEAD
        this.headGroup = new THREE.Group();
        this.headGroup.position.set(0, 0.35 * chonk, PROP.bodyLength * 0.93);
        this.rig.add(this.headGroup);

        this.head = new THREE.Mesh(headGeo, this.fleshMat);
        this.head.castShadow = true;
        this.headGroup.add(this.head);
        this.head.add(generateMultiLayerFur(deformHead, density, furColor, true));

        // SNOUT
        const noseMat = this.fleshMat.clone();
        noseMat.color.set(strain.noseColor ?? skinColor);
        noseMat.roughness = 0.15; noseMat.transmission = 0.2; noseMat.thickness = 0.3;
        noseMat.clearcoat = 0.8; noseMat.clearcoatRoughness = 0.1;
        this.snoutTip = new THREE.Mesh(new THREE.SphereGeometry(0.13, 20, 20), noseMat);
        this.snoutTip.scale.set(1.1, 0.8, 1.0);
        this.snoutTip.position.set(this.asymmetry.noseYaw, -0.18, PROP.snoutLength * 1.07);
        this.head.add(this.snoutTip);

        // Nostrils
        const nostrilMat = new THREE.MeshBasicMaterial({ color: 0x111111 });
        const nL = new THREE.Mesh(new THREE.SphereGeometry(0.025, 8, 8), nostrilMat);
        nL.position.set(0.045, -0.01, 0.11); this.snoutTip.add(nL);
        const nR = new THREE.Mesh(new THREE.SphereGeometry(0.025, 8, 8), nostrilMat);
        nR.position.set(-0.045, -0.01, 0.11); this.snoutTip.add(nR);

        // MOUTH + INCISORS
        const mouthMat = new THREE.MeshBasicMaterial({ color: 0x0d0d0d });
        this.mouth = new THREE.Mesh(new THREE.CapsuleGeometry(0.045, 0.09, 10, 10), mouthMat);
        this.mouth.rotation.z = Math.PI / 2;
        this.mouth.position.set(0, -0.27, PROP.snoutLength * 1.02);
        this.head.add(this.mouth);

        const toothMat = new THREE.MeshPhysicalMaterial({
          color: 0xf5e9cf, roughness: 0.35, metalness: 0.0, clearcoat: 0.35, clearcoatRoughness: 0.2
        });
        const addIncisor = (xSign) => {
          const tooth = new THREE.Mesh(new THREE.BoxGeometry(0.028, 0.07, 0.022), toothMat);
          tooth.position.set(0.02 * xSign, -0.235, PROP.snoutLength * 1.06);
          tooth.rotation.x = -0.22;
          tooth.castShadow = true;
          this.head.add(tooth);
        };
        addIncisor(-1);
        addIncisor(1);

        // WHISKERS
        const wColor = skinHSL.l > 0.5 ? 0xaaaaaa : 0x444444;
        this.padL = new THREE.Group(); this.padL.position.set(0.1, -0.05, 1.1); this.head.add(this.padL);
        this.padR = new THREE.Group(); this.padR.position.set(-0.1, -0.05, 1.1); this.head.add(this.padR);
        this.padL.add(createVolumetricWhiskers(wColor, true));
        this.padR.add(createVolumetricWhiskers(wColor, false));

        // EARS (with asymmetry)
        const earOuterMat = this.fleshMat.clone();
        earOuterMat.transmission = strain.earOuterTransmission ?? 0.6;
        earOuterMat.thickness = 0.15;
        earOuterMat.roughness = strain.earOuterRoughness ?? 0.4;
        earOuterMat.side = THREE.DoubleSide;
        const earInnerMat = this.fleshMat.clone();
        earInnerMat.color.offsetHSL(0.0, strain.earInnerSatOffset ?? 0.12, strain.earInnerLightOffset ?? 0.12);
        earInnerMat.transmission = strain.earInnerTransmission ?? 0.78;
        earInnerMat.thickness = 0.08; earInnerMat.roughness = 0.3; earInnerMat.side = THREE.DoubleSide;

        const earL = new THREE.Mesh(earGeo, earOuterMat);
        earL.position.set(0.62, 0.42 + (strain.earHeightOffset ?? 0.0) + this.asymmetry.earHeightDiff, PROP.earSetBack);
        earL.rotation.set(-0.3 + this.asymmetry.earTiltL, -(strain.earYaw ?? PROP.earYaw), 0.25);
        earL.scale.set(eSize, eSize, eSize);
        earL.castShadow = true; this.head.add(earL);
        const earLI = new THREE.Mesh(earGeo, earInnerMat);
        earLI.scale.set(0.82, 0.85, 0.5); earLI.position.set(0, 0, -0.05); earL.add(earLI);

        const earR = new THREE.Mesh(earGeo, earOuterMat);
        earR.position.set(-0.62, 0.42 + (strain.earHeightOffset ?? 0.0) - this.asymmetry.earHeightDiff, PROP.earSetBack);
        earR.rotation.set(-0.3 + this.asymmetry.earTiltR, (strain.earYaw ?? PROP.earYaw), -0.25);
        earR.scale.set(eSize, eSize, eSize);
        earR.castShadow = true; this.head.add(earR);
        const earRI = new THREE.Mesh(earGeo, earInnerMat);
        earRI.scale.set(0.82, 0.85, 0.5); earRI.position.set(0, 0, -0.05); earR.add(earRI);

        // EYES (lateral placement with asymmetry, two-layer)
        const eyeL = new THREE.Mesh(new THREE.SphereGeometry(PROP.eyeSize, 20, 20), eyeMat);
        eyeL.scale.set(1.0, 0.95, PROP.eyeProtrusion);
        eyeL.position.set(PROP.eyeSpacing + this.asymmetry.eyeOffsetL, 0.15, PROP.eyeYaw);
        eyeL.castShadow = true; this.head.add(eyeL);
        const cL = new THREE.Mesh(new THREE.SphereGeometry(PROP.eyeSize + 0.005, 20, 20), corneaMat);
        cL.scale.set(1.0, 0.95, PROP.eyeProtrusion + 0.05);
        cL.position.copy(eyeL.position); this.head.add(cL);
        // Tear line highlight
        const tearL = new THREE.Mesh(new THREE.TorusGeometry(PROP.eyeSize * 0.85, 0.008, 6, 16, Math.PI * 0.6),
          new THREE.MeshBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.3 }));
        tearL.position.copy(eyeL.position); tearL.position.y -= 0.02;
        tearL.rotation.y = Math.PI / 2; this.head.add(tearL);

        const eyeR = new THREE.Mesh(new THREE.SphereGeometry(PROP.eyeSize, 20, 20), eyeMat);
        eyeR.scale.set(1.0, 0.95, PROP.eyeProtrusion);
        eyeR.position.set(-PROP.eyeSpacing + this.asymmetry.eyeOffsetR, 0.15, PROP.eyeYaw);
        eyeR.castShadow = true; this.head.add(eyeR);
        const cR = new THREE.Mesh(new THREE.SphereGeometry(PROP.eyeSize + 0.005, 20, 20), corneaMat);
        cR.scale.set(1.0, 0.95, PROP.eyeProtrusion + 0.05);
        cR.position.copy(eyeR.position); this.head.add(cR);
        const tearR = new THREE.Mesh(new THREE.TorusGeometry(PROP.eyeSize * 0.85, 0.008, 6, 16, Math.PI * 0.6),
          new THREE.MeshBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.3 }));
        tearR.position.copy(eyeR.position); tearR.position.y -= 0.02;
        tearR.rotation.y = -Math.PI / 2; this.head.add(tearR);

        // ═══ LIMBS (anatomically correct chains) ═══
        // Hindlimbs
        this.hindL = createHindlimbChain(this.fleshMat, strain, density, furColor, 'L');
        this.rig.add(this.hindL);
        this.hindR = createHindlimbChain(this.fleshMat, strain, density, furColor, 'R');
        this.rig.add(this.hindR);

        // Forelimbs
        this.armL = createForelimbChain(this.fleshMat, strain, density, furColor, 'L');
        this.rig.add(this.armL);
        this.armR = createForelimbChain(this.fleshMat, strain, density, furColor, 'R');
        this.rig.add(this.armR);

        // References for animation
        this.thighL = this.hindL._thigh;
        this.thighR = this.hindR._thigh;
        this.shankL = this.hindL._shank;
        this.shankR = this.hindR._shank;

        // CONTACT SHADOW
        this.contactShadow = createContactShadow();
        this.mesh.add(this.contactShadow);

        // TAIL
        this.tailCount = 45;
        const tailMat = this.fleshMat.clone();
        tailMat.roughness = 0.6; tailMat.transmission = 0.25;
        tailMat.thickness = 0.4; tailMat.clearcoat = 0.15;
        tailMat.roughnessMap = tailRoughnessMap;
        const tGeo = new THREE.CylinderGeometry(0.08, 0.08, 1, 12);
        tGeo.translate(0, 0.5, 0); tGeo.rotateX(Math.PI / 2);
        this.tailInstanced = new THREE.InstancedMesh(tGeo, tailMat, this.tailCount);
        this.tailInstanced.castShadow = true; this.tailInstanced.receiveShadow = true;
        this.mesh.add(this.tailInstanced);
        this.dummy = new THREE.Object3D();

        // POSE TRACKING SKELETON
        this.poseNodes = {};
        this.trackingGroup = new THREE.Group();
        this.mesh.add(this.trackingGroup);

        const createTrackingNode = (id, parent, localPos) => {
          const mat = new THREE.MeshBasicMaterial({
            color: POSE_COLORS[id] || 0xffffff, depthTest: false, transparent: true, opacity: 0.9
          });
          const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.12, 12, 12), mat);
          sphere.renderOrder = 999;
          if (parent) {
            sphere.position.copy(localPos); parent.add(sphere);
            this.poseNodes[id] = sphere;
          } else {
            this.trackingGroup.add(sphere);
            this.poseNodes[id] = sphere;
          }
        };

        // Tracking nodes at anatomical landmarks
        createTrackingNode('snout', this.headGroup, new THREE.Vector3(0, -0.15, PROP.snoutLength * 1.04));
        createTrackingNode('lear', this.headGroup, new THREE.Vector3(0.55, 0.45, -0.15));
        createTrackingNode('rear', this.headGroup, new THREE.Vector3(-0.55, 0.45, -0.15));
        createTrackingNode('neck', this.rig, new THREE.Vector3(0, 0.6, PROP.bodyLength * 0.62));
        createTrackingNode('spine1', this.rig, new THREE.Vector3(0, 0.9, 0.2));
        createTrackingNode('spine2', this.rig, new THREE.Vector3(0, 0.8, -PROP.bodyLength * 0.41));
        createTrackingNode('tailbase', this.rig, new THREE.Vector3(0, 0.3, -PROP.bodyLength * 0.93));
        // Paws attached to limb chains
        createTrackingNode('lforepaw', this.armL._wrist, new THREE.Vector3(0, -0.06, 0.05));
        createTrackingNode('rforepaw', this.armR._wrist, new THREE.Vector3(0, -0.06, 0.05));
        createTrackingNode('lhindpaw', this.hindL._ankle, new THREE.Vector3(0, -0.14, 0.20));
        createTrackingNode('rhindpaw', this.hindR._ankle, new THREE.Vector3(0, -0.14, 0.20));

        this.mesh.updateMatrixWorld(true);
        this.mesh.traverse(child => {
          if (child.isMesh || child.isInstancedMesh) child.frustumCulled = false;
        });

        createTrackingNode('tailmid', null, new THREE.Vector3());
        createTrackingNode('tailend', null, new THREE.Vector3());

        // Skeleton edges
        const lineMat = new THREE.LineBasicMaterial({ color: 0x00ffcc, depthTest: false, transparent: true, opacity: 0.7, linewidth: 2 });
        this.skeletonLines = new THREE.LineSegments(new THREE.BufferGeometry(), lineMat);
        this.skeletonLines.renderOrder = 998;
        this.trackingGroup.add(this.skeletonLines);
        const linePositions = new Float32Array(POSE_CONNECTIONS.length * 6);
        this.skeletonLines.geometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
      }


      update(time, otherMice = [], hudRef = null, dt = 0.016) {
        dt = Math.min(dt, 0.05);
        let t = time * 2.0 * this.speedMult + this.timeOffset;

        // --- FORCE ACCUMULATION ---
        this.force.set(0, 0);
        let burst = Math.sin(t * 1.5 + this.burstPhase);
        burst = 0.7 + 0.3 * Math.max(0, burst);
        const driveStrength = burst * this.guiParams.wanderForce;

        // Thigmotaxis
        const px = this.mesh.position.x, pz = this.mesh.position.z;
        const wallDists = [
          { dist: ENCLOSURE_HALF_X - px, normalX: -1, normalZ: 0, tangentX: 0, tangentZ: 1 },
          { dist: ENCLOSURE_HALF_X + px, normalX: 1, normalZ: 0, tangentX: 0, tangentZ: -1 },
          { dist: ENCLOSURE_HALF_Z - pz, normalX: 0, normalZ: -1, tangentX: -1, tangentZ: 0 },
          { dist: ENCLOSURE_HALF_Z + pz, normalX: 0, normalZ: 1, tangentX: 1, tangentZ: 0 },
        ];
        wallDists.sort((a, b) => a.dist - b.dist);
        const nearest = wallDists[0];
        const wallDist = nearest.dist;
        const wallAttr = this.guiParams.wallAttraction;
        if (wallDist > 2.0 && wallDist < 12.0) {
          const aS = ((wallDist - 2.0) / 12.0) * wallAttr;
          this.force.x += nearest.normalX * aS * driveStrength;
          this.force.y += nearest.normalZ * aS * driveStrength;
        }
        for (const w of wallDists) {
          if (w.dist < 2.0) {
            const pen = (2.0 - w.dist) / 2.0;
            this.force.x -= w.normalX * pen * pen * 50.0;
            this.force.y -= w.normalZ * pen * pen * 50.0;
          }
        }
        const tX = nearest.tangentX * this.wallFollowDir;
        const tZ = nearest.tangentZ * this.wallFollowDir;
        const nwF = Math.max(0, 1.0 - wallDist / 5.0);
        this.force.x += tX * driveStrength * (0.5 + nwF * 1.5);
        this.force.y += tZ * driveStrength * (0.5 + nwF * 1.5);

        if (!guiParams.isPaused) {
          this.force.x += (Math.sin(t * 2.3) * 0.3 + (Math.random() - 0.5) * 0.2) * driveStrength * 0.3;
          this.force.y += (Math.cos(t * 1.7) * 0.3 + (Math.random() - 0.5) * 0.2) * driveStrength * 0.3;
        }

        // Anti-stuck
        if (!guiParams.isPaused) {
          const dxS = px - this.lastPos.x, dzS = pz - this.lastPos.y;
          this.stuckTimer += dt;
          if (this.stuckTimer > 1.0) {
            if (Math.sqrt(dxS * dxS + dzS * dzS) < 0.35) {
              const escape = new THREE.Vector2(
                nearest.tangentX * this.wallFollowDir + nearest.normalX * 0.7,
                nearest.tangentZ * this.wallFollowDir + nearest.normalZ * 0.7
              );
              if (escape.lengthSq() < 1e-6) escape.set(Math.cos(t), Math.sin(t));
              escape.normalize();
              const escapeForce = 30.0 + (wallDist < 1.5 ? 20.0 : 0.0);
              this.force.x += escape.x * escapeForce;
              this.force.y += escape.y * escapeForce;
              this.yawVel *= 0.5;
              this.wallFollowDir *= -1;
            }
            this.lastPos.set(px, pz); this.stuckTimer = 0;
          }
        }

        // Mouse-to-mouse collision
        const MOUSE_RADIUS = 4.0;
        let isColliding = false;
        for (const other of otherMice) {
          if (other === this) continue;
          const dx = this.mesh.position.x - other.mesh.position.x;
          const dz = this.mesh.position.z - other.mesh.position.z;
          const distSq = dx * dx + dz * dz;
          if (distSq < MOUSE_RADIUS * MOUSE_RADIUS && distSq > 0.001) {
            isColliding = true;
            const dist = Math.sqrt(distSq);
            const overlap = MOUSE_RADIUS - dist;
            this.force.x += (dx / dist) * overlap * 40.0;
            this.force.y += (dz / dist) * overlap * 40.0;
            if (overlap > 0) {
              const corr = overlap * 0.5;
              this.mesh.position.x += (dx / dist) * corr;
              this.mesh.position.z += (dz / dist) * corr;
              other.mesh.position.x -= (dx / dist) * corr;
              other.mesh.position.z -= (dz / dist) * corr;
            }
          }
        }

        const preSpeed = this.velocity.length();

        // Cruise assist: keep mice from decaying to full stop after startup.
        if (!guiParams.isPaused) {
          const cruiseTarget = Math.max(this.guiParams.maxSpeed * 0.30, 1.8);
          if (preSpeed < cruiseTarget) {
            const deficit = (cruiseTarget - preSpeed) / Math.max(cruiseTarget, 1e-3);
            const cruiseDir = this.heading.lengthSq() > 1e-6
              ? this.heading.clone().normalize()
              : new THREE.Vector2(Math.cos(t), Math.sin(t)).normalize();
            const cruiseBoost = (this.guiParams.wanderForce * 5.0 + 10.0) * deficit;
            this.force.x += cruiseDir.x * cruiseBoost;
            this.force.y += cruiseDir.y * cruiseBoost;
          }
        }

        // Drag (lighter at very low speed so movement does not stall).
        const dragC = this.guiParams.dragCoeff * (preSpeed < 1.0 ? 0.45 : 1.0);
        this.force.x -= this.velocity.x * dragC;
        this.force.y -= this.velocity.y * dragC;

        // Low-speed rescue: inject motion if the mouse lingers too long.
        if (!guiParams.isPaused) {
          if (preSpeed < 0.8) this.lowSpeedTimer += dt;
          else this.lowSpeedTimer = Math.max(0, this.lowSpeedTimer - dt * 0.5);
          if (this.lowSpeedTimer > 1.0) {
            const rescueDir = new THREE.Vector2(
              nearest.tangentX * this.wallFollowDir + nearest.normalX * 0.6,
              nearest.tangentZ * this.wallFollowDir + nearest.normalZ * 0.6
            );
            if (rescueDir.lengthSq() < 1e-6) {
              if (this.heading.lengthSq() > 1e-6) rescueDir.copy(this.heading);
              else rescueDir.set(Math.cos(t), Math.sin(t));
            }
            rescueDir.normalize();
            const kickMag = 32.0;
            this.force.x += rescueDir.x * kickMag;
            this.force.y += rescueDir.y * kickMag;
            this.lowSpeedTimer = 0;
          }
        }

        // Integration
        if (!guiParams.isPaused) {
          const ax = this.force.x / (this.mass * 1000);
          const az = this.force.y / (this.mass * 1000);
          this.velocity.x += ax * dt; this.velocity.y += az * dt;
          const uMS = this.guiParams.maxSpeed;
          const cS = this.velocity.length();
          if (cS > uMS) this.velocity.multiplyScalar(uMS / cS);
          this.mesh.position.x += this.velocity.x * dt;
          this.mesh.position.z += this.velocity.y * dt;
          this.locomotionTime += cS * dt;
        }

        // Hard boundary clamp with tangent turn selection (avoid wall-sticking).
        let hitWall = false;
        let hitXWall = false;
        let hitZWall = false;
        // Keep full body+head away from walls (not just the body center point).
        const HM = Math.max(3.8, 3.2 * this.guiParams.bodyLength + 0.9 * this.guiParams.snoutLength);
        if (this.mesh.position.x > ENCLOSURE_HALF_X - HM) { this.mesh.position.x = ENCLOSURE_HALF_X - HM; this.velocity.x = -Math.abs(this.velocity.x) * 0.25; hitWall = true; hitXWall = true; }
        if (this.mesh.position.x < -ENCLOSURE_HALF_X + HM) { this.mesh.position.x = -ENCLOSURE_HALF_X + HM; this.velocity.x = Math.abs(this.velocity.x) * 0.25; hitWall = true; hitXWall = true; }
        if (this.mesh.position.z > ENCLOSURE_HALF_Z - HM) { this.mesh.position.z = ENCLOSURE_HALF_Z - HM; this.velocity.y = -Math.abs(this.velocity.y) * 0.25; hitWall = true; hitZWall = true; }
        if (this.mesh.position.z < -ENCLOSURE_HALF_Z + HM) { this.mesh.position.z = -ENCLOSURE_HALF_Z + HM; this.velocity.y = Math.abs(this.velocity.y) * 0.25; hitWall = true; hitZWall = true; }
        if (hitWall) {
          const minTurnSpeed = Math.max(this.guiParams.maxSpeed * 0.45, 2.2);
          const clearPosX = ENCLOSURE_HALF_X - this.mesh.position.x;
          const clearNegX = ENCLOSURE_HALF_X + this.mesh.position.x;
          const clearPosZ = ENCLOSURE_HALF_Z - this.mesh.position.z;
          const clearNegZ = ENCLOSURE_HALF_Z + this.mesh.position.z;
          if (hitXWall && !hitZWall) {
            const turnSignZ = clearPosZ >= clearNegZ ? 1 : -1;
            this.velocity.y = turnSignZ * Math.max(Math.abs(this.velocity.y), minTurnSpeed);
            this.wallFollowDir = turnSignZ;
          } else if (hitZWall && !hitXWall) {
            const turnSignX = clearPosX >= clearNegX ? 1 : -1;
            this.velocity.x = turnSignX * Math.max(Math.abs(this.velocity.x), minTurnSpeed);
            this.wallFollowDir = turnSignX;
          } else {
            // Corner: choose axis with more free space.
            if (Math.max(clearPosX, clearNegX) >= Math.max(clearPosZ, clearNegZ)) {
              const turnSignX = clearPosX >= clearNegX ? 1 : -1;
              this.velocity.x = turnSignX * minTurnSpeed;
            } else {
              const turnSignZ = clearPosZ >= clearNegZ ? 1 : -1;
              this.velocity.y = turnSignZ * minTurnSpeed;
            }
            this.wallFollowDir *= -1;
          }
          // Heading will reorient through angular inertia below.
        }
        if (!guiParams.isPaused) {
          this.rearCooldown = Math.max(0, this.rearCooldown - dt);
          const impactNorm = Math.min(this.velocity.length() / Math.max(this.guiParams.maxSpeed, 1e-3), 1.0);
          if (hitWall && impactNorm > 0.14 && this.rearCooldown <= 0) {
            this.rearVel += 2.0 + impactNorm * 1.8;
            this.rearCooldown = 0.7;
          }
          // Damped spring so rearing rises quickly and settles smoothly.
          this.rearVel += (-18.0 * this.rearAmount - 7.5 * this.rearVel) * dt;
          this.rearAmount = THREE.MathUtils.clamp(this.rearAmount + this.rearVel * dt, 0, 1);
          if (this.rearAmount < 1e-3 && this.rearVel < 1e-3) {
            this.rearAmount = 0;
            this.rearVel = 0;
          }
        }

        // Heading
        const speed = this.velocity.length();
        let isMoving = speed > 0.3;
        if (!guiParams.isPaused) {
          let targetYaw = this.yawAngle;
          if (isMoving) {
            targetYaw = Math.atan2(this.velocity.x, this.velocity.y);
          } else if (this.force.lengthSq() > 1e-6) {
            targetYaw = Math.atan2(this.force.x, this.force.y);
          }
          let yawErr = targetYaw - this.yawAngle;
          if (yawErr > Math.PI) yawErr -= Math.PI * 2;
          if (yawErr < -Math.PI) yawErr += Math.PI * 2;
          const yawK = isColliding ? 18.0 : 12.0;
          const yawD = 7.0;
          this.yawVel += (yawK * yawErr - yawD * this.yawVel) * dt;
          const maxYawRate = isColliding ? 2.8 : 2.2;
          this.yawVel = THREE.MathUtils.clamp(this.yawVel, -maxYawRate, maxYawRate);
          this.yawAngle += this.yawVel * dt;
        }
        this.heading.set(Math.sin(this.yawAngle), Math.cos(this.yawAngle));
        this.mesh.rotation.y = this.yawAngle;

        if (hudRef) {
          hudRef.state.innerText = isMoving ? "SCURRYING // AVOIDANCE" : "ALERT // SNIFFING";
          hudRef.state.style.color = isMoving ? "#00f0ff" : "#ffcc00";
          hudRef.hr.innerText = isMoving ? "540 BPM" : "410 BPM";
          hudRef.resp.innerText = isMoving ? "210 BPM" : (160 + Math.floor(Math.random() * 10)) + " BPM";
          hudRef.coord.innerText = `${this.mesh.position.x.toFixed(2)}, ${this.mesh.position.z.toFixed(2)}`;
        }

        // Body + tail dynamics (gravity + inertia)
        const speedNorm = Math.min(speed / this.maxSpeed, 1.0);
        const invDt = 1.0 / Math.max(dt, 1e-4);
        const accelX = (this.velocity.x - this.prevVelocity.x) * invDt;
        const accelZ = (this.velocity.y - this.prevVelocity.y) * invDt;
        const forwardAccel = accelX * this.heading.x + accelZ * this.heading.y;
        const lateralAccel = accelX * (-this.heading.y) + accelZ * this.heading.x;
        const headingAngle = Math.atan2(this.heading.x, this.heading.y);
        let headingDelta = headingAngle - this.prevHeadingAngle;
        if (headingDelta > Math.PI) headingDelta -= Math.PI * 2;
        if (headingDelta < -Math.PI) headingDelta += Math.PI * 2;
        const turnRate = headingDelta * invDt;
        this.prevHeadingAngle = headingAngle;

        if (!guiParams.isPaused) {
          // Vertical body suspension with gravity.
          const targetBodyY = 1.26 + speedNorm * 0.10;
          const bodyK = 24.0, bodyD = 8.0, gravity = 3.4;
          this.bodyDyn.vy += (bodyK * (targetBodyY - this.bodyDyn.y) - bodyD * this.bodyDyn.vy - gravity) * dt;
          this.bodyDyn.y += this.bodyDyn.vy * dt;
          if (this.bodyDyn.y < 1.12) {
            this.bodyDyn.y = 1.12;
            this.bodyDyn.vy = Math.max(0, this.bodyDyn.vy) * 0.2;
          }

          // Pitch/roll inertia from accel and turning.
          const targetPitch = THREE.MathUtils.clamp(-forwardAccel * 0.015 + speedNorm * 0.02, -0.16, 0.16);
          const targetRoll = THREE.MathUtils.clamp(-lateralAccel * 0.02 - turnRate * 0.01, -0.20, 0.20);
          const angK = 18.0, angD = 6.5;
          this.bodyDyn.pitchV += (angK * (targetPitch - this.bodyDyn.pitch) - angD * this.bodyDyn.pitchV) * dt;
          this.bodyDyn.rollV += (angK * (targetRoll - this.bodyDyn.roll) - angD * this.bodyDyn.rollV) * dt;
          this.bodyDyn.pitch += this.bodyDyn.pitchV * dt;
          this.bodyDyn.roll += this.bodyDyn.rollV * dt;

          // Tail inertial follow-through.
          const targetTailSway = THREE.MathUtils.clamp(-turnRate * 0.06 - lateralAccel * 0.01, -0.9, 0.9);
          const targetTailLift = THREE.MathUtils.clamp(-0.05 - forwardAccel * 0.004 + speedNorm * 0.03, -0.18, 0.08);
          const tailK = 14.0, tailD = 4.8;
          this.tailDyn.swayV += (tailK * (targetTailSway - this.tailDyn.sway) - tailD * this.tailDyn.swayV) * dt;
          this.tailDyn.liftV += (tailK * (targetTailLift - this.tailDyn.lift) - tailD * this.tailDyn.liftV) * dt;
          this.tailDyn.sway += this.tailDyn.swayV * dt;
          this.tailDyn.lift += this.tailDyn.liftV * dt;
          if (speed < 0.45 && this.lowSpeedTimer > 0.6) {
            // Calm tiny oscillations while nearly stationary.
            const calm = Math.exp(-8.0 * dt);
            this.tailDyn.sway *= calm;
            this.tailDyn.lift *= calm;
            this.tailDyn.swayV *= calm;
            this.tailDyn.liftV *= calm;
          }
        }

        this.rig.position.y = this.bodyDyn.y;
        this.rig.rotation.x = this.bodyDyn.pitch;
        this.rig.rotation.z = this.bodyDyn.roll;

        // Contact shadow follows mouse on ground
        this.contactShadow.position.set(0, -this.rig.position.y + 0.02, 0);

        // ═══ GAIT ANIMATION (anatomically correct) ═══
        const legCycle = this.locomotionTime * 5.0;
        const gaitAmp = Math.min(speedNorm * 1.2, 1.0) * 0.6 * this.motion.gaitAmpMul;

        if (isMoving) {
          // Hindlimb: hip drives, knee follows with phase offset
          this.hindL.rotation.x = Math.sin(legCycle) * gaitAmp;
          this.hindR.rotation.x = Math.sin(legCycle + Math.PI) * gaitAmp;
          this.shankL.rotation.x = Math.max(0, Math.sin(legCycle + 0.5)) * gaitAmp * 0.5;
          this.shankR.rotation.x = Math.max(0, Math.sin(legCycle + Math.PI + 0.5)) * gaitAmp * 0.5;
          // Ankle follows shank, pushes off
          if (this.hindL._ankle) this.hindL._ankle.rotation.x = Math.sin(legCycle - 0.3) * gaitAmp * 0.3;
          if (this.hindR._ankle) this.hindR._ankle.rotation.x = Math.sin(legCycle + Math.PI - 0.3) * gaitAmp * 0.3;

          // Forelimb: shoulder drives, elbow/wrist follow
          this.armL.rotation.x = Math.sin(legCycle + Math.PI) * gaitAmp * 0.7;
          this.armR.rotation.x = Math.sin(legCycle) * gaitAmp * 0.7;
          // Elbow flex
          if (this.armL._forearm) this.armL._forearm.rotation.x = Math.max(0, Math.sin(legCycle + Math.PI + 0.4)) * gaitAmp * 0.4;
          if (this.armR._forearm) this.armR._forearm.rotation.x = Math.max(0, Math.sin(legCycle + 0.4)) * gaitAmp * 0.4;
          // Wrist flex
          if (this.armL._wrist) this.armL._wrist.rotation.x = Math.sin(legCycle + Math.PI + 0.6) * gaitAmp * 0.15;
          if (this.armR._wrist) this.armR._wrist.rotation.x = Math.sin(legCycle + 0.6) * gaitAmp * 0.15;
        } else {
          // Idle pose
          this.hindL.rotation.x = 0; this.hindR.rotation.x = 0;
          this.shankL.rotation.x = 0; this.shankR.rotation.x = 0;
          if (this.hindL._ankle) this.hindL._ankle.rotation.x = 0;
          if (this.hindR._ankle) this.hindR._ankle.rotation.x = 0;

          // Neutral planted stance: keep forepaws on the floor at idle.
          this.armL.rotation.x = -0.12; this.armR.rotation.x = -0.12;
          this.armL.rotation.z = -0.03; this.armR.rotation.z = 0.03;
          if (this.armL._forearm) this.armL._forearm.rotation.x = 0.18;
          if (this.armR._forearm) this.armR._forearm.rotation.x = 0.18;
          if (this.armL._wrist) this.armL._wrist.rotation.x = 0.04;
          if (this.armR._wrist) this.armR._wrist.rotation.x = 0.04;
        }

        const rear = this.rearAmount;
        if (rear > 0) {
          // Rearing posture near walls: raise front body and forelimbs.
          this.rig.position.y += rear * 0.85;
          this.rig.rotation.x -= rear * 0.40;
          this.armL.rotation.x = THREE.MathUtils.lerp(this.armL.rotation.x, -1.18, rear);
          this.armR.rotation.x = THREE.MathUtils.lerp(this.armR.rotation.x, -1.18, rear);
          this.armL.rotation.z = THREE.MathUtils.lerp(this.armL.rotation.z, -0.16, rear);
          this.armR.rotation.z = THREE.MathUtils.lerp(this.armR.rotation.z, 0.16, rear);
          if (this.armL._forearm) this.armL._forearm.rotation.x = THREE.MathUtils.lerp(this.armL._forearm.rotation.x, 0.85, rear);
          if (this.armR._forearm) this.armR._forearm.rotation.x = THREE.MathUtils.lerp(this.armR._forearm.rotation.x, 0.85, rear);
          if (this.armL._wrist) this.armL._wrist.rotation.x = THREE.MathUtils.lerp(this.armL._wrist.rotation.x, 0.45, rear);
          if (this.armR._wrist) this.armR._wrist.rotation.x = THREE.MathUtils.lerp(this.armR._wrist.rotation.x, 0.45, rear);
          this.hindL.rotation.x = THREE.MathUtils.lerp(this.hindL.rotation.x, 0.35, rear);
          this.hindR.rotation.x = THREE.MathUtils.lerp(this.hindR.rotation.x, 0.35, rear);
          this.contactShadow.position.set(0, -this.rig.position.y + 0.02, 0);
        }

        // Head animation
        const calmIdle = !isMoving && speed < 0.45 && this.lowSpeedTimer > 0.6;
        if (!isMoving) {
          if (calmIdle) {
            this.headGroup.rotation.y *= 0.85;
            this.headGroup.rotation.x *= 0.85;
            this.snoutTip.position.y = -0.15;
            this.padL.rotation.y = 0.1;
            this.padR.rotation.y = -0.1;
          } else {
            this.headGroup.rotation.y = Math.sin(time * 6.0) * 0.3 * this.motion.headIdleYawMul;
            this.headGroup.rotation.x = Math.sin(time * 9.0) * 0.15 * this.motion.headIdlePitchMul;
            this.snoutTip.position.y = -0.15 + Math.sin(time * 40.0) * 0.02 * this.motion.sniffAmpMul;
            this.padL.rotation.y = Math.sin(time * 40.0) * 0.1 * this.motion.sniffAmpMul + 0.1;
            this.padR.rotation.y = -Math.sin(time * 40.0) * 0.1 * this.motion.sniffAmpMul - 0.1;
          }
        } else {
          const turnAmount = this.velocity.x * this.heading.y - this.velocity.y * this.heading.x;
          this.headGroup.rotation.set(Math.sin(time * 2) * 0.08, turnAmount * 0.08, 0);
          this.snoutTip.position.y = -0.15;
          this.padL.rotation.y = -0.3; this.padR.rotation.y = 0.3;
        }
        if (rear > 0) this.headGroup.rotation.x += rear * 0.32;

        // ═══ TAIL ═══
        let tailBase = new THREE.Vector3(0, -0.2, -PROP.bodyLength * 0.93);
        this.rig.updateMatrix();
        tailBase.applyMatrix4(this.rig.matrix);
        let tailCurve = [];
        const tailLenMul = this.guiParams.tailLength;
        const segLen = this.tailSegLen * tailLenMul;
        for (let i = 0; i <= this.tailCount; i++) {
          const p = i / this.tailCount;
          const lag = p * p;
          const transmit = Math.pow(p, 1.35);
          const midCurve = p * (1.0 - p);
          const bodyForceX = (this.bodyDyn.roll * 0.34 + lateralAccel * 0.010 - turnRate * 0.018) * transmit;
          const bodyForceY = (this.bodyDyn.pitch * 0.38 - forwardAccel * 0.008) * transmit;
          const waveX = this.tailDyn.sway * lag + bodyForceX + midCurve * 0.18 * Math.sign(this.tailDyn.sway || bodyForceX || 1);
          let waveY = -i * PROP.tailSag * p + this.tailDyn.lift * lag + bodyForceY + midCurve * 0.08;
          waveY = Math.max(waveY, -1.3);
          tailCurve.push(new THREE.Vector3(waveX, waveY, -i * segLen));
        }
        let offset = tailBase.clone().sub(tailCurve[0]);
        for (let i = 0; i <= this.tailCount; i++) {
          tailCurve[i].add(offset);
          const worldY = tailCurve[i].y + this.mesh.position.y;
          if (worldY < 0.05) tailCurve[i].y += (0.05 - worldY);
        }
        for (let i = 0; i < this.tailCount; i++) {
          let p = i / this.tailCount;
          let radius = 1.0 - p * PROP.tailTaper;
          radius *= 1.0 + Math.sin(i * 2.8) * 0.04;
          this.dummy.position.copy(tailCurve[i]);
          this.dummy.lookAt(tailCurve[i + 1]);
          const thickMul = this.guiParams.tailThickness;
          this.dummy.scale.set(radius * thickMul, radius * thickMul, segLen * 1.3);
          this.dummy.updateMatrix();
          this.tailInstanced.setMatrixAt(i, this.dummy.matrix);
          let isTailVisible = this.tailInstanced.visible;
          if (i === Math.floor(this.tailCount * 0.4)) {
            this.poseNodes['tailmid'].position.copy(tailCurve[i + 1]);
            this.poseNodes['tailmid'].visible = guiParams.showTrackingKeypoints && isTailVisible;
          }
          if (i === this.tailCount - 1) {
            this.poseNodes['tailend'].position.copy(tailCurve[i + 1]);
            this.poseNodes['tailend'].visible = guiParams.showTrackingKeypoints && isTailVisible;
          }
        }
        this.tailInstanced.instanceMatrix.needsUpdate = true;

        // Tracking visibility
        this.trackingGroup.visible = guiParams.showTrackingKeypoints;
        for (const key in this.poseNodes) this.poseNodes[key].visible = guiParams.showTrackingKeypoints;

        // Live adjustments
        const breathFreq = isMoving ? this.motion.breathMoveFreq : this.motion.breathIdleFreq;
        const breathAmp = isMoving ? this.motion.breathMoveAmp : this.motion.breathIdleAmp;
        let breath = Math.sin(time * breathFreq) * breathAmp;
        this.bodyMesh.scale.x = this.guiParams.bodyLength + breath;
        this.bodyMesh.scale.y = this.guiParams.chonkiness;
        this.bodyMesh.scale.z = this.guiParams.chonkiness + breath;
        this.head.scale.setScalar(this.guiParams.headSize);
        this.snoutTip.scale.set(1.1, 0.8, this.guiParams.snoutLength);
        this.fleshMat.color.set(this.guiParams.skinColor);
        this.prevVelocity.copy(this.velocity);

        this.mesh.updateMatrixWorld(true);

        if (this.trackingGroup.visible) {
          const positions = this.skeletonLines.geometry.attributes.position.array;
          let idx = 0;
          const invMat = this.trackingGroup.matrixWorld.clone().invert();
          const ptA = new THREE.Vector3(), ptB = new THREE.Vector3();
          for (const [idA, idB] of POSE_CONNECTIONS) {
            const nA = this.poseNodes[idA], nB = this.poseNodes[idB];
            if (nA && nB) {
              nA.getWorldPosition(ptA); nB.getWorldPosition(ptB);
              ptA.applyMatrix4(invMat); ptB.applyMatrix4(invMat);
              positions[idx++] = ptA.x; positions[idx++] = ptA.y; positions[idx++] = ptA.z;
              positions[idx++] = ptB.x; positions[idx++] = ptB.y; positions[idx++] = ptB.z;
            }
          }
          this.skeletonLines.geometry.attributes.position.needsUpdate = true;
        }
      }
    }


    // ═══════════════════════════════════════════════════════════════
    // 11. SCENE ASSEMBLY
    // ═══════════════════════════════════════════════════════════════
    const floorGeo = new THREE.PlaneGeometry(200, 200);
    const floorMat = new THREE.MeshPhysicalMaterial({
      color: 0x111620, roughness: 0.15, metalness: 0.6,
      clearcoat: 1.0, clearcoatRoughness: 0.1,
      polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 1
    });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2; floor.receiveShadow = true;
    scene.add(floor);

    const enclosureMat = new THREE.MeshPhysicalMaterial({
      color: 0xb9d7ea, transparent: true, opacity: 0.13, roughness: 0.2, metalness: 0.0, transmission: 0.0, thickness: 0.0,
      side: THREE.BackSide, depthWrite: false
    });
    const enclosureBox = new THREE.Mesh(new THREE.BoxGeometry(ENCLOSURE_W, ENCLOSURE_H, ENCLOSURE_D), enclosureMat);
    enclosureBox.position.set(0, ENCLOSURE_H * 0.5, 0); enclosureBox.receiveShadow = true;
    enclosureBox.renderOrder = 10;
    scene.add(enclosureBox);

    const enclosureEdges = new THREE.LineSegments(
      new THREE.EdgesGeometry(new THREE.BoxGeometry(ENCLOSURE_W, ENCLOSURE_H, ENCLOSURE_D)),
      new THREE.LineBasicMaterial({ color: 0x58c8ff, transparent: true, opacity: 0.45 })
    );
    enclosureEdges.material.depthTest = false;
    enclosureEdges.renderOrder = 25;
    enclosureEdges.position.copy(enclosureBox.position); scene.add(enclosureEdges);

    const grid = new THREE.GridHelper(100, 50, 0x00f0ff, 0x112233);
    grid.position.y = 0.05;
    const gridMats = Array.isArray(grid.material) ? grid.material : [grid.material];
    for (const gm of gridMats) {
      gm.transparent = true;
      gm.opacity = 0.12;
      gm.depthWrite = false;
      gm.depthTest = false;
    }
    grid.renderOrder = 20;
    scene.add(grid);

    // ═══════════════════════════════════════════════════════════════
    // 12. LIGHTING (3-point photographic lab setup)
    // ═══════════════════════════════════════════════════════════════
    const ambientLight = new THREE.AmbientLight(0xf5f0eb, 0.5);
    scene.add(ambientLight);

    const hemiLight = new THREE.HemisphereLight(0xe8eef5, 0xf0e8d8, 0.6);
    hemiLight.position.set(0, 20, 0); scene.add(hemiLight);

    // Key light (overhead panel)
    const keyLight = new THREE.DirectionalLight(0xf0f0ff, 0.8);
    keyLight.position.set(0, 18, 0); keyLight.castShadow = true;
    keyLight.shadow.mapSize.width = 2048; keyLight.shadow.mapSize.height = 2048;
    keyLight.shadow.camera.near = 0.5; keyLight.shadow.camera.far = 30;
    keyLight.shadow.camera.left = -20; keyLight.shadow.camera.right = 20;
    keyLight.shadow.camera.top = 15; keyLight.shadow.camera.bottom = -15;
    keyLight.shadow.bias = -0.001; keyLight.shadow.normalBias = 0.02;
    scene.add(keyLight);

    // Fill light
    const fillLight = new THREE.DirectionalLight(0xf5f0e8, 0.4);
    fillLight.position.set(8, 16, 5); fillLight.castShadow = false;
    scene.add(fillLight);

    // Rim light
    const rimLight = new THREE.DirectionalLight(0xe8e8f0, 0.3);
    rimLight.position.set(-6, 12, -4); rimLight.castShadow = false;
    scene.add(rimLight);

    // ═══════════════════════════════════════════════════════════════
    // 13. GUI & LOGIC
    // ═══════════════════════════════════════════════════════════════
    const mice = [];
    const hudElements = {
      count: document.getElementById('hud-count'),
      state: document.getElementById('hud-state'),
      hr: document.getElementById('hud-hr'),
      resp: document.getElementById('hud-resp'),
      coord: document.getElementById('hud-coord')
    };

    // ═══ Initialize shader engine ═══
    const annolidShaders = new AnnolidShaders(THREE);
    const postFX = annolidShaders.createPostProcessing(renderer, {
      vigIntensity: 0.3, vigSoftness: 0.45, grainStrength: 0.02,
      saturation: 1.05, brightness: 1.0
    });

    const guiParams = {
      furColor: '#ffffff', skinColor: '#d8d8d3',
      chonkiness: 1.128, earSize: 0.78, furDensity: 0.85,
      showTrackingKeypoints: true, wireframeMode: false, isPaused: false,
      addSubject: () => spawnMouse(), clearSubjects: () => clearMice(),
      presets: 'BALB/c (White)',
      // Body part controls
      tailLength: 0.5, tailThickness: 1.0,
      headSize: 1.0, snoutLength: 1.0,
      bodyLength: 1.0, legLength: 1.18, legThickness: 1.0,
      // Physics
      maxSpeed: 9.0, dragCoeff: 1.5, wanderForce: 10.0, wallAttraction: 3.2,
      // Quality
      qualityMode: 'Realtime', furDetailLevel: 'Med',
      enableVignette: false, enableGrain: false, enableAO: true,
      // Lighting
      keyIntensity: 0.8, fillIntensity: 0.4, rimIntensity: 0.3,
      keyColorTemp: 6500, ambientIntensity: 0.5,
      // Proportions (exposed)
      propBodyLength: PROP.bodyLength, propBodyGirthX: PROP.bodyGirthX,
      propWaistTaper: PROP.waistTaper, propHaunchWidth: PROP.haunchWidth,
      propShoulderWidth: PROP.shoulderWidth,
      propNeckLength: PROP.neckLength, propNeckGirth: PROP.neckGirth,
      propSnoutLength: PROP.snoutLength, propSnoutWidth: PROP.snoutWidth,
      propCheekFullness: PROP.cheekFullness,
      propEarYaw: PROP.earYaw, propEarThickness: PROP.earThickness,
      propEyeSize: PROP.eyeSize, propEyeSpacing: PROP.eyeSpacing,
      propForeLimbLength: PROP.foreLimbLength, propHindLimbLength: PROP.hindLimbLength,
      propForePawSize: PROP.forePawSize, propHindPawSize: PROP.hindPawSize,
      propTailSag: PROP.tailSag,
      // Fur
      furGuardRatio: 0.5, furLength: 1.0, furClumpiness: 0.3,
      // Shader controls
      enableSSS: true, sssThickness: 0.45, sssWrap: 0.5, sssBacklight: 0.6,
      enableContactAO: true, aoRadius: 1.5, aoIntensity: 0.35,
      enableMicroDetail: true, microScale: 40.0, microStrength: 0.06,
      enablePostFX: false, postVignette: 0.3, postGrain: 0.02, postSaturation: 1.05,
    };

    function getStrainProfile(presetName) {
      if (presetName === 'C57BL/6 (Black)') {
        return {
          earOuterTransmission: 0.65, earInnerTransmission: 0.75,
          earInnerSatOffset: 0.10, earInnerLightOffset: 0.15, earOuterRoughness: 0.32,
          earYaw: 0.96, earHeightOffset: 0.0, padDarken: 0.88, clawColor: 0xcccccc,
          noseColor: '#b48a8a', pawSpreadMul: 1.0, toeLenMul: 0.98,
          gaitAmpMul: 0.92, headIdleYawMul: 0.82, headIdlePitchMul: 0.88,
          sniffAmpMul: 0.75, breathIdleAmp: 0.010, breathMoveAmp: 0.012,
          breathIdleFreq: 10.0, breathMoveFreq: 18.0, tailWaveAmpMul: 0.85, tailWaveFreqMul: 0.90
        };
      }
      if (presetName === 'Nude/Hairless') {
        return {
          earOuterTransmission: 0.66, earInnerTransmission: 0.82,
          earInnerSatOffset: 0.14, earInnerLightOffset: 0.14, earOuterRoughness: 0.28,
          earYaw: 0.42, earHeightOffset: 0.015, padDarken: 0.88, clawColor: 0xe1d7cb,
          noseColor: '#ff9ea8', pawSpreadMul: 1.04, toeLenMul: 1.05,
          gaitAmpMul: 1.08, headIdleYawMul: 1.15, headIdlePitchMul: 1.12,
          sniffAmpMul: 1.25, breathIdleAmp: 0.018, breathMoveAmp: 0.024,
          breathIdleFreq: 13.0, breathMoveFreq: 24.0, tailWaveAmpMul: 1.18, tailWaveFreqMul: 1.12
        };
      }
      return { // BALB/c default
        earOuterTransmission: 0.58, earInnerTransmission: 0.76,
        earInnerSatOffset: 0.11, earInnerLightOffset: 0.11, earOuterRoughness: 0.33,
        earYaw: 0.40, earHeightOffset: 0.0, padDarken: 0.84, clawColor: 0xd7cdc2,
        noseColor: '#f2adb0', pawSpreadMul: 1.0, toeLenMul: 1.0,
        gaitAmpMul: 1.0, headIdleYawMul: 1.0, headIdlePitchMul: 1.0,
        sniffAmpMul: 1.0, breathIdleAmp: 0.013, breathMoveAmp: 0.016,
        breathIdleFreq: 12.0, breathMoveFreq: 20.0, tailWaveAmpMul: 1.0, tailWaveFreqMul: 1.0
      };
    }

    function applyStrainPreset(name) {
      guiParams.presets = name;
      if (name === 'BALB/c (White)') { guiParams.furColor = '#ffffff'; guiParams.skinColor = '#d8d8d3'; guiParams.furDensity = 0.62; guiParams.earSize = 0.78; }
      if (name === 'C57BL/6 (Black)') { guiParams.furColor = '#111015'; guiParams.skinColor = '#3a3438'; guiParams.furDensity = 0.72; guiParams.earSize = 0.9; }
      if (name === 'CBA (Brown)') { guiParams.furColor = '#6a4b3a'; guiParams.skinColor = '#d0a090'; guiParams.furDensity = 0.55; guiParams.earSize = 0.8; }
      if (name === 'Nude/Hairless') { guiParams.furColor = '#ffd0c8'; guiParams.skinColor = '#ffc0b8'; guiParams.furDensity = 0.0; guiParams.earSize = 0.95; }
    }

    const gui = new GUI({ title: 'GENETICS LAB (GUI)' });
    const respawnNoticeState = new Map();

    function notifyRespawnRequired(key, value, message) {
      const token = `${key}:${JSON.stringify(value)}`;
      if (respawnNoticeState.get(key) === token) return;
      respawnNoticeState.set(key, token);
      alert(message);
    }

    gui.add(guiParams, 'presets', ['BALB/c (White)', 'C57BL/6 (Black)', 'CBA (Brown)', 'Nude/Hairless']).name('Strains').onChange(v => {
      applyStrainPreset(v);
      gui.controllersRecursive().forEach(c => c.updateDisplay());
    });

    // Neuroscience
    const neuroscienceFolder = gui.addFolder('Neuroscience & Tracking');
    neuroscienceFolder.add(guiParams, 'showTrackingKeypoints').name('Show Pose Skeleton').onChange(v => {
      mice.forEach(m => m.trackingGroup.visible = v);
    });
    neuroscienceFolder.add(guiParams, 'wireframeMode').name('Wireframe Bodies').onChange(v => {
      scene.traverse(child => {
        if (child.isMesh && child.material && child.material !== floorMat && child !== enclosureBox) {
          if (child.geometry && child.geometry.type !== 'ConeGeometry' && child.geometry.type !== 'CylinderGeometry') {
            child.material.wireframe = v;
          }
        }
      });
    });

    // Biological Traits
    const traitFolder = gui.addFolder('Biological Traits');
    traitFolder.addColor(guiParams, 'furColor').name('Fur Pigment');
    traitFolder.addColor(guiParams, 'skinColor').name('Skin Pigment');
    traitFolder.add(guiParams, 'chonkiness', 0.5, 2.0).name('Fatness / Mass');
    traitFolder.add(guiParams, 'earSize', 0.5, 2.0).name('Ear Magnitude');
    traitFolder.add(guiParams, 'furDensity', 0.0, 1.0).name('Fur Density').onFinishChange(v => {
      notifyRespawnRequired(
        'furDensity',
        Number(v).toFixed(3),
        "Fur density changes require respawning subjects to take effect."
      );
    });

    // Simulation Controls
    const controlFolder = gui.addFolder('Simulation Controls');
    controlFolder.add(guiParams, 'isPaused').name('Pause Simulation');
    controlFolder.add(guiParams, 'addSubject').name('(+) Spawn Subject');
    controlFolder.add(guiParams, 'clearSubjects').name('(!) Clear All');

    // Body Part Controls
    const bodyFolder = gui.addFolder('Body Part Controls');
    bodyFolder.add(guiParams, 'tailLength', 0.2, 2.5, 0.05).name('Tail Length');
    bodyFolder.add(guiParams, 'tailThickness', 0.3, 2.0, 0.05).name('Tail Thickness');
    bodyFolder.add(guiParams, 'headSize', 0.5, 2.0, 0.05).name('Head Size');
    bodyFolder.add(guiParams, 'snoutLength', 0.5, 2.0, 0.05).name('Snout Length');
    bodyFolder.add(guiParams, 'bodyLength', 0.5, 2.0, 0.05).name('Body Length');
    bodyFolder.add(guiParams, 'legLength', 0.5, 2.0, 0.05).name('Leg Length');
    bodyFolder.add(guiParams, 'legThickness', 0.5, 2.0, 0.05).name('Leg Thickness');

    // Proportions (detailed)
    const propFolder = gui.addFolder('Proportions');
    propFolder.add(guiParams, 'propBodyLength', 1.5, 4.0, 0.1).name('Body Length').onChange(v => { PROP.bodyLength = v; });
    propFolder.add(guiParams, 'propBodyGirthX', 1.0, 2.5, 0.05).name('Body Girth X').onChange(v => { PROP.bodyGirthX = v; });
    propFolder.add(guiParams, 'propWaistTaper', 0.3, 1.0, 0.05).name('Waist Taper').onChange(v => { PROP.waistTaper = v; });
    propFolder.add(guiParams, 'propHaunchWidth', 0.8, 2.0, 0.05).name('Haunch Width').onChange(v => { PROP.haunchWidth = v; });
    propFolder.add(guiParams, 'propShoulderWidth', 0.5, 1.5, 0.05).name('Shoulder Width').onChange(v => { PROP.shoulderWidth = v; });
    propFolder.add(guiParams, 'propNeckLength', 0.3, 1.5, 0.05).name('Neck Length').onChange(v => { PROP.neckLength = v; });
    propFolder.add(guiParams, 'propNeckGirth', 0.3, 1.0, 0.05).name('Neck Girth').onChange(v => { PROP.neckGirth = v; });
    propFolder.add(guiParams, 'propSnoutLength', 0.8, 2.0, 0.05).name('Snout Length').onChange(v => { PROP.snoutLength = v; });
    propFolder.add(guiParams, 'propSnoutWidth', 0.8, 1.8, 0.05).name('Snout Width').onChange(v => { PROP.snoutWidth = v; });
    propFolder.add(guiParams, 'propCheekFullness', 0.1, 0.8, 0.05).name('Cheek Fullness').onChange(v => { PROP.cheekFullness = v; });
    propFolder.add(guiParams, 'propEarYaw', 0.2, 1.2, 0.05).name('Ear Yaw').onChange(v => { PROP.earYaw = v; });
    propFolder.add(guiParams, 'propEyeSize', 0.08, 0.25, 0.01).name('Eye Size').onChange(v => { PROP.eyeSize = v; });
    propFolder.add(guiParams, 'propEyeSpacing', 0.3, 0.7, 0.02).name('Eye Spacing').onChange(v => { PROP.eyeSpacing = v; });
    propFolder.add(guiParams, 'propForeLimbLength', 0.5, 1.5, 0.05).name('Forelimb Length').onChange(v => { PROP.foreLimbLength = v; });
    propFolder.add(guiParams, 'propHindLimbLength', 0.5, 1.5, 0.05).name('Hindlimb Length').onChange(v => { PROP.hindLimbLength = v; });
    propFolder.add(guiParams, 'propForePawSize', 0.5, 2.0, 0.05).name('Forepaw Size').onChange(v => { PROP.forePawSize = v; });
    propFolder.add(guiParams, 'propHindPawSize', 0.5, 2.0, 0.05).name('Hindpaw Size').onChange(v => { PROP.hindPawSize = v; });
    propFolder.add(guiParams, 'propTailSag', 0.0, 0.1, 0.005).name('Tail Sag').onChange(v => { PROP.tailSag = v; });
    propFolder.close();

    // Fur controls
    const furFolder = gui.addFolder('Fur');
    furFolder.add(guiParams, 'furDetailLevel', ['High', 'Med', 'Low', 'Off']).name('Fur Detail').onFinishChange(v => {
      notifyRespawnRequired(
        'furDetailLevel',
        String(v || ''),
        "Fur detail changes require respawning subjects to take effect."
      );
    });
    furFolder.add(guiParams, 'furGuardRatio', 0.0, 1.0, 0.05).name('Guard Hair Ratio');
    furFolder.add(guiParams, 'furLength', 0.3, 2.0, 0.05).name('Fur Length');
    furFolder.add(guiParams, 'furClumpiness', 0.0, 1.0, 0.05).name('Clumpiness');
    furFolder.close();

    // Lighting
    const lightFolder = gui.addFolder('Lighting');
    lightFolder.add(guiParams, 'keyIntensity', 0.0, 2.0, 0.05).name('Key Intensity').onChange(v => { keyLight.intensity = v; });
    lightFolder.add(guiParams, 'fillIntensity', 0.0, 2.0, 0.05).name('Fill Intensity').onChange(v => { fillLight.intensity = v; });
    lightFolder.add(guiParams, 'rimIntensity', 0.0, 2.0, 0.05).name('Rim Intensity').onChange(v => { rimLight.intensity = v; });
    lightFolder.add(guiParams, 'ambientIntensity', 0.0, 2.0, 0.05).name('Ambient Intensity').onChange(v => { ambientLight.intensity = v; });
    lightFolder.close();

    // Quality
    const qualityFolder = gui.addFolder('Quality');
    qualityFolder.add(guiParams, 'qualityMode', ['Photo', 'Realtime']).name('Quality Mode').onChange(v => {
      if (v === 'Photo') {
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMappingExposure = 1.5;
        keyLight.shadow.mapSize.width = 4096; keyLight.shadow.mapSize.height = 4096;
        keyLight.shadow.map?.dispose(); keyLight.shadow.map = null;
        guiParams.enablePostFX = true; postFX.enabled = true;
      } else {
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.toneMappingExposure = 1.4;
        keyLight.shadow.mapSize.width = 2048; keyLight.shadow.mapSize.height = 2048;
        keyLight.shadow.map?.dispose(); keyLight.shadow.map = null;
        guiParams.enablePostFX = false; postFX.enabled = false;
      }
      gui.controllersRecursive().forEach(c => c.updateDisplay());
    });
    qualityFolder.add(guiParams, 'enableAO').name('Contact Shadows').onChange(v => {
      mice.forEach(m => { if (m.contactShadow) m.contactShadow.visible = v; });
    });
    qualityFolder.close();

    // Shaders
    const shaderFolder = gui.addFolder('Shaders');
    shaderFolder.add(guiParams, 'enableSSS').name('Subsurface Scatter').onFinishChange(v => {
      notifyRespawnRequired(
        'enableSSS',
        Boolean(v),
        'Shader changes require respawning subjects.'
      );
    });
    shaderFolder.add(guiParams, 'sssThickness', 0.0, 1.0, 0.05).name('SSS Thickness');
    shaderFolder.add(guiParams, 'sssWrap', 0.0, 1.0, 0.05).name('SSS Wrap');
    shaderFolder.add(guiParams, 'sssBacklight', 0.0, 1.5, 0.05).name('SSS Backlight');
    shaderFolder.add(guiParams, 'enableContactAO').name('Contact AO').onFinishChange(v => {
      notifyRespawnRequired(
        'enableContactAO',
        Boolean(v),
        'Shader changes require respawning subjects.'
      );
    });
    shaderFolder.add(guiParams, 'aoRadius', 0.5, 5.0, 0.1).name('AO Radius');
    shaderFolder.add(guiParams, 'aoIntensity', 0.0, 1.0, 0.05).name('AO Intensity');
    shaderFolder.add(guiParams, 'enableMicroDetail').name('Micro Detail').onFinishChange(v => {
      notifyRespawnRequired(
        'enableMicroDetail',
        Boolean(v),
        'Shader changes require respawning subjects.'
      );
    });
    shaderFolder.add(guiParams, 'microScale', 5.0, 200.0, 5.0).name('Detail Scale');
    shaderFolder.add(guiParams, 'microStrength', 0.0, 0.3, 0.01).name('Detail Strength');
    shaderFolder.add(guiParams, 'enablePostFX').name('Post-Processing').onChange(v => {
      postFX.enabled = v;
    });
    shaderFolder.add(guiParams, 'postVignette', 0.0, 1.0, 0.05).name('Vignette').onChange(v => {
      postFX.uniforms.uVigIntensity.value = v;
    });
    shaderFolder.add(guiParams, 'postGrain', 0.0, 0.1, 0.005).name('Film Grain').onChange(v => {
      postFX.uniforms.uGrainStrength.value = v;
    });
    shaderFolder.add(guiParams, 'postSaturation', 0.5, 1.5, 0.05).name('Saturation').onChange(v => {
      postFX.uniforms.uSaturation.value = v;
    });
    shaderFolder.close();

    // Physics
    const physicsFolder = gui.addFolder('Physics Controls');
    physicsFolder.add(guiParams, 'maxSpeed', 1.0, 20.0, 0.5).name('Max Speed');
    physicsFolder.add(guiParams, 'dragCoeff', 0.5, 10.0, 0.5).name('Drag / Friction');
    physicsFolder.add(guiParams, 'wanderForce', 0.5, 10.0, 0.5).name('Wander Force');
    physicsFolder.add(guiParams, 'wallAttraction', 0.0, 5.0, 0.25).name('Wall Attraction');

    // ═══════════════════════════════════════════════════════════════
    // 14. SPAWN / CLEAR
    // ═══════════════════════════════════════════════════════════════
    function spawnMouse() {
      const m = new ExpertMouse(guiParams);
      const wall = Math.floor(Math.random() * 4);
      const wo = 4.6;
      let inX = 0, inZ = 0;
      switch (wall) {
        case 0: m.mesh.position.x = ENCLOSURE_HALF_X - wo; m.mesh.position.z = (Math.random() - 0.5) * ENCLOSURE_HALF_Z * 1.5; inX = -1; break;
        case 1: m.mesh.position.x = -ENCLOSURE_HALF_X + wo; m.mesh.position.z = (Math.random() - 0.5) * ENCLOSURE_HALF_Z * 1.5; inX = 1; break;
        case 2: m.mesh.position.x = (Math.random() - 0.5) * ENCLOSURE_HALF_X * 1.5; m.mesh.position.z = ENCLOSURE_HALF_Z - wo; inZ = -1; break;
        case 3: m.mesh.position.x = (Math.random() - 0.5) * ENCLOSURE_HALF_X * 1.5; m.mesh.position.z = -ENCLOSURE_HALF_Z + wo; inZ = 1; break;
      }
      const dir = new THREE.Vector2(inX, inZ);
      const tangentialKick = (Math.random() - 0.5) * 0.9;
      if (Math.abs(inX) > 0) dir.y += tangentialKick;
      else dir.x += tangentialKick;
      if (dir.lengthSq() < 1e-6) dir.set((Math.random() - 0.5), (Math.random() - 0.5));
      dir.normalize();
      const launchSpeed = guiParams.maxSpeed * (0.50 + Math.random() * 0.18);
      m.velocity.set(dir.x * launchSpeed, dir.y * launchSpeed);
      m.heading.copy(dir);
      m.prevVelocity.copy(m.velocity);
      if (m.tailDyn) {
        m.tailDyn.sway = (Math.random() - 0.5) * 0.25;
        m.tailDyn.lift = -0.04 + Math.random() * 0.03;
      }
      scene.add(m.mesh);
      mice.push(m);
      hudElements.count.innerText = mice.length;
    }

    function clearMice() {
      mice.forEach(m => scene.remove(m.mesh));
      mice.length = 0;
      hudElements.count.innerText = 0;
      hudElements.state.innerText = "NO SUBJECTS";
      hudElements.hr.innerText = "-- BPM";
      hudElements.resp.innerText = "-- BPM";
      hudElements.coord.innerText = "0.00, 0.00";
    }

    // Spawn initial subjects
    applyStrainPreset('C57BL/6 (Black)');
    spawnMouse();
    applyStrainPreset('BALB/c (White)');
    gui.controllersRecursive().forEach(c => c.updateDisplay());
    spawnMouse();

    // ═══════════════════════════════════════════════════════════════
    // 15. RENDER LOOP
    // ═══════════════════════════════════════════════════════════════
    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      postFX.resize();
    });
    window.dispatchEvent(new Event('resize'));

    const clock = new THREE.Clock();
    let accumulatedTime = 0;

    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      if (!guiParams.isPaused) accumulatedTime += dt;
      mice.forEach((m, i) => {
        m.update(accumulatedTime, mice, i === 0 ? hudElements : null, dt);
      });
      controls.update();
      // Render via post-processing pipeline (passes through if disabled)
      postFX.render(scene, camera, accumulatedTime);
    }
    animate();
  </script>
</body>

</html>
