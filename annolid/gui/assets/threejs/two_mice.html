<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Annolid: High-Fidelity Mouse Study</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

    :root {
      color-scheme: dark;
    }

    html,
    body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #030405;
      font-family: 'Share Tech Mono', monospace;
      user-select: none;
    }

    #c {
      display: block;
      width: 100%;
      height: 100%;
    }

    .overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      background: radial-gradient(circle at 50% 50%, transparent 40%, rgba(0, 0, 0, 0.85) 120%);
      box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.8);
    }

    .hud {
      position: absolute;
      bottom: 40px;
      left: 40px;
      color: rgba(200, 230, 255, 0.9);
      font-size: 13px;
      border-left: 3px solid #00f0ff;
      padding-left: 20px;
      background: linear-gradient(90deg, rgba(0, 15, 30, 0.85) 0%, rgba(0, 0, 0, 0) 100%);
      padding: 15px 20px;
      backdrop-filter: blur(5px);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .hud h1 {
      margin: 0 0 10px 0;
      font-size: 16px;
      letter-spacing: 3px;
      color: #fff;
      text-shadow: 0 0 10px rgba(0, 240, 255, 0.5);
    }

    .data-row {
      display: flex;
      justify-content: space-between;
      width: 280px;
      margin-bottom: 4px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      padding-bottom: 2px;
    }

    .label {
      color: #6a95b8;
    }

    .val {
      color: #00f0ff;
      font-weight: bold;
    }

    .val.alert {
      color: #ff3366;
      text-shadow: 0 0 8px rgba(255, 51, 102, 0.6);
    }

    .scanner {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 2px;
      background: rgba(0, 240, 255, 0.1);
      animation: scan 4s linear infinite;
    }

    @keyframes scan {
      0% {
        top: 0%;
      }

      100% {
        top: 100%;
      }
    }
  </style>
</head>

<body>
  <canvas id="c"></canvas>
  <div class="overlay"></div>
  <div class="scanner"></div>
  <div class="hud">
    <h1>BIOMETRIC TELEMETRY</h1>
    <div class="data-row"><span class="label">SUBJECT</span><span class="val">Mus musculus (BALB/c)</span></div>
    <div class="data-row"><span class="label">MODEL</span><span class="val">VOLUMETRIC / INSTANCED</span></div>
    <div class="data-row"><span class="label">STATE</span><span class="val" id="hud-state">INITIALIZING...</span></div>
    <div class="data-row"><span class="label">HEART RATE</span><span class="val alert" id="hud-hr">-- BPM</span></div>
    <div class="data-row"><span class="label">RESPIRATION</span><span class="val" id="hud-resp">-- BPM</span></div>
    <div class="data-row"><span class="label">COORD XZ</span><span class="val" id="hud-coord">0.00, 0.00</span></div>
  </div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.151.3';
    import { OrbitControls } from 'https://esm.sh/three@0.151.3/examples/jsm/controls/OrbitControls.js';

    // --- 1. CORE SETUP ---
    const canvas = document.querySelector('#c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: "high-performance" });
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0a0c10, 0.012);

    const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 500);
    camera.position.set(0, 12, 38);

    const controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(0, 1.5, 0);
    controls.maxPolarAngle = Math.PI / 2 - 0.02;

    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    pmremGenerator.compileEquirectangularShader();
    const envScene = new THREE.Scene();
    envScene.background = new THREE.Color(0x000000);
    const box1 = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), new THREE.MeshBasicMaterial({ color: 0xffffff }));
    box1.position.set(15, 20, 15); box1.lookAt(0, 0, 0); envScene.add(box1);
    const box2 = new THREE.Mesh(new THREE.PlaneGeometry(30, 15), new THREE.MeshBasicMaterial({ color: 0xddeeff }));
    box2.position.set(-20, 10, -15); box2.lookAt(0, 0, 0); envScene.add(box2);
    scene.environment = pmremGenerator.fromScene(envScene).texture;

    // --- 2. MATERIALS ---
    const fleshMatWhite = new THREE.MeshPhysicalMaterial({
      color: 0xffd0c8, roughness: 0.4, transmission: 0.6,
      thickness: 0.8, attenuationColor: 0xff3322, attenuationDistance: 2.0, clearcoat: 0.1
    });

    const fleshMatDark = new THREE.MeshPhysicalMaterial({
      color: 0x2a2020, roughness: 0.5, transmission: 0.3,
      thickness: 0.8, attenuationColor: 0x441111, attenuationDistance: 2.0, clearcoat: 0.1
    });

    const eyeMat = new THREE.MeshPhysicalMaterial({
      color: 0x010101, roughness: 0.0, metalness: 0.1,
      clearcoat: 1.0, clearcoatRoughness: 0.0, envMapIntensity: 3.0
    });

    // --- 3. ORGANIC GEOMETRY & MATH ---
    function deform(geometry, deformFn) {
      const pos = geometry.attributes.position;
      const v = new THREE.Vector3();
      for (let i = 0; i < pos.count; i++) {
        v.fromBufferAttribute(pos, i);
        deformFn(v);
        pos.setXYZ(i, v.x, v.y, v.z);
      }
      geometry.computeVertexNormals();
      return geometry;
    }

    const deformBody = (v) => {
      const zNorm = (v.z + 1) / 2;
      const taper = 1.0 - zNorm * 0.45;
      v.x *= taper * 1.6; v.y *= taper * 1.5; v.z *= 3.0;
      v.y += Math.sin(zNorm * Math.PI) * 0.5;
    };

    const deformHead = (v) => {
      const zNorm = (v.z + 1) / 2;
      const taper = Math.pow(1.0 - zNorm * 0.75, 1.2);
      v.x *= taper * 0.95; v.y *= taper * 0.9; v.z *= 1.5;
      v.y -= zNorm * 0.18; // Droop
      if (zNorm < 0.5) v.x += (0.5 - zNorm) * 0.25; // Cheeks
      if (zNorm > 0.4 && zNorm < 0.7 && v.y > 0) v.y += 0.08; // Brow
    };

    const deformThigh = (v) => { v.x *= 0.6; v.y *= 1.2; v.z *= 1.2; v.z -= v.y * 0.3; };
    const deformEar = (v) => { v.z *= 0.1; v.x *= 0.8; v.y *= 0.8; v.z -= (v.x * v.x + v.y * v.y) * 0.6; };

    const bodyGeo = deform(new THREE.SphereGeometry(1, 64, 64), deformBody);
    const headGeo = deform(new THREE.SphereGeometry(1, 48, 48), deformHead);
    const thighGeo = deform(new THREE.SphereGeometry(1, 32, 32), deformThigh);
    const earGeo = deform(new THREE.SphereGeometry(1, 32, 32), deformEar);

    function createPaw(mat) {
      const paw = new THREE.Group();
      const pad = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 16), mat);
      pad.scale.set(1.2, 0.4, 1.2); pad.castShadow = true; paw.add(pad);
      for (let i = 0; i < 4; i++) {
        const toe = new THREE.Mesh(new THREE.CapsuleGeometry(0.04, 0.25, 8, 8), mat);
        toe.rotation.x = Math.PI / 2; toe.position.set((i - 1.5) * 0.12, -0.05, 0.25);
        toe.castShadow = true; paw.add(toe);
      }
      return paw;
    }

    function createVolumetricWhiskers(mat, isLeft) {
      const group = new THREE.Group();
      const sign = isLeft ? 1 : -1;
      for (let i = 0; i < 18; i++) {
        const curve = new THREE.QuadraticBezierCurve3(
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(sign * 0.6, (Math.random() - 0.5) * 0.3, 0.3),
          new THREE.Vector3(sign * (1.2 + Math.random() * 0.6), (Math.random() - 0.5) * 0.8, 0.4 + Math.random() * 0.6)
        );
        const geo = new THREE.TubeGeometry(curve, 6, 0.005, 4, false);
        const mesh = new THREE.Mesh(geo, mat);
        group.add(mesh);
      }
      return group;
    }

    // --- 4. PROCEDURAL FUR GENERATOR ---
    // Mathematically grows thousands of instanced hairs from a base geometry function
    function generateFurLayer(deformFn, count, colorHex, length, isHead) {
      const geo = new THREE.ConeGeometry(0.015, length, 3);
      geo.translate(0, length / 2, 0);
      geo.rotateX(-Math.PI / 2); // Point along +Z

      const mat = new THREE.MeshPhysicalMaterial({
        color: colorHex, roughness: 0.9, clearcoat: 0.05,
        sheen: 1.0, sheenColor: 0xffffff
      });

      const inst = new THREE.InstancedMesh(geo, mat, count);
      inst.receiveShadow = true; // Shadows cast ON fur, but hairs don't cast (performance)

      const dummy = new THREE.Object3D();
      const pos = new THREE.Vector3();
      const normal = new THREE.Vector3();

      for (let i = 0; i < count; i++) {
        // Distribute uniformly on sphere
        const u = Math.random(), v = Math.random();
        const theta = u * 2.0 * Math.PI;
        const phi = Math.acos(2.0 * v - 1.0);
        pos.set(Math.sin(phi) * Math.cos(theta), Math.sin(phi) * Math.sin(theta), Math.cos(phi));

        normal.copy(pos).normalize();
        const preDeformZ = pos.z;

        deformFn(pos);
        pos.addScaledVector(normal, 0.01); // Sit slightly above skin

        // Flow direction (sweeping backward)
        let flowDir = new THREE.Vector3(normal.x * 0.4, normal.y * 0.4, -1).normalize();

        // Custom flow for head/snout
        if (isHead && preDeformZ > 0) {
          flowDir.set(normal.x * 0.1, normal.y * 0.1, -1).normalize(); // Snout fur lays super flat
        }

        dummy.position.copy(pos);
        dummy.lookAt(pos.clone().add(flowDir));

        let scale = 0.5 + Math.random() * 0.7;
        if (isHead && preDeformZ > 0.4) scale *= 0.35; // Micro fur on nose
        if (!isHead && preDeformZ < -0.6) scale *= 1.3; // Fluffy rump

        dummy.scale.set(scale, scale, scale);
        dummy.updateMatrix();
        inst.setMatrixAt(i, dummy.matrix);
      }
      return inst;
    }

    // --- 5. EXPERT MOUSE CLASS ---
    class ExpertMouse {
      constructor(isDark = false) {
        this.mesh = new THREE.Group();
        this.timeOffset = Math.random() * 100;
        this.locomotionTime = 0;

        this.fleshMat = isDark ? fleshMatDark.clone() : fleshMatWhite.clone();
        const furColor = isDark ? 0x111111 : 0xfffbf6;
        const wColor = isDark ? 0x666666 : 0xeeeeee;

        // BODY (Skin + FurCoat)
        this.body = new THREE.Mesh(bodyGeo, this.fleshMat);
        this.body.position.y = 1.3;
        this.body.castShadow = true;
        this.mesh.add(this.body);

        const bodyFur = generateFurLayer(deformBody, 45000, furColor, 0.18, false);
        this.body.add(bodyFur);

        // HEAD
        this.headGroup = new THREE.Group();
        this.headGroup.position.set(0, 0.35, 2.7);
        this.body.add(this.headGroup);

        this.head = new THREE.Mesh(headGeo, this.fleshMat);
        this.head.castShadow = true;
        this.headGroup.add(this.head);

        const headFur = generateFurLayer(deformHead, 25000, furColor, 0.12, true);
        this.head.add(headFur);

        // SNOUT & WHISKERS
        this.snoutTip = new THREE.Mesh(new THREE.SphereGeometry(0.12, 16, 16), fleshMatWhite); // Nose always pinkish
        this.snoutTip.position.set(0, -0.15, 1.45);
        this.head.add(this.snoutTip);

        const whiskerMat = new THREE.MeshBasicMaterial({ color: wColor, transparent: true, opacity: 0.5 });
        this.padL = new THREE.Group(); this.padL.position.set(0.1, -0.05, 1.1); this.head.add(this.padL);
        this.padR = new THREE.Group(); this.padR.position.set(-0.1, -0.05, 1.1); this.head.add(this.padR);

        this.padL.add(createVolumetricWhiskers(whiskerMat, true));
        this.padR.add(createVolumetricWhiskers(whiskerMat, false));

        // EARS & EYES
        const earL = new THREE.Mesh(earGeo, this.fleshMat);
        earL.position.set(0.55, 0.45, -0.15); earL.rotation.set(0.1, -0.5, 0.3);
        earL.castShadow = true; this.head.add(earL);

        const earR = new THREE.Mesh(earGeo, this.fleshMat);
        earR.position.set(-0.55, 0.45, -0.15); earR.rotation.set(0.1, 0.5, -0.3);
        earR.castShadow = true; this.head.add(earR);

        const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.16, 16, 16), eyeMat);
        eyeL.position.set(0.48, 0.1, 0.3); this.head.add(eyeL);
        const eyeR = new THREE.Mesh(new THREE.SphereGeometry(0.16, 16, 16), eyeMat);
        eyeR.position.set(-0.48, 0.1, 0.3); this.head.add(eyeR);

        // LIMBS
        this.thighL = new THREE.Mesh(thighGeo, this.fleshMat);
        this.thighL.position.set(0.7, -0.1, -1.6); this.body.add(this.thighL);
        this.thighL.add(generateFurLayer(deformThigh, 8000, furColor, 0.15, false));

        this.thighR = new THREE.Mesh(thighGeo, this.fleshMat);
        this.thighR.position.set(-0.7, -0.1, -1.6); this.body.add(this.thighR);
        this.thighR.add(generateFurLayer(deformThigh, 8000, furColor, 0.15, false));

        const pawBL = createPaw(this.fleshMat); pawBL.position.set(0.1, -1.0, 0.4); this.thighL.add(pawBL);
        const pawBR = createPaw(this.fleshMat); pawBR.position.set(-0.1, -1.0, 0.4); this.thighR.add(pawBR);

        this.armL = new THREE.Group(); this.armL.position.set(0.55, -0.4, 1.6); this.body.add(this.armL);
        const armMeshL = new THREE.Mesh(new THREE.CapsuleGeometry(0.12, 0.6, 8, 8), this.fleshMat);
        armMeshL.position.y = -0.3; this.armL.add(armMeshL);
        const pawFL = createPaw(this.fleshMat); pawFL.position.set(0, -0.75, 0.15); this.armL.add(pawFL);

        this.armR = new THREE.Group(); this.armR.position.set(-0.55, -0.4, 1.6); this.body.add(this.armR);
        const armMeshR = new THREE.Mesh(new THREE.CapsuleGeometry(0.12, 0.6, 8, 8), this.fleshMat);
        armMeshR.position.y = -0.3; this.armR.add(armMeshR);
        const pawFR = createPaw(this.fleshMat); pawFR.position.set(0, -0.75, 0.15); this.armR.add(pawFR);

        // TAIL (InstancedMesh Segment IK)
        this.tailCount = 45;
        const tGeo = new THREE.CylinderGeometry(0.08, 0.08, 1, 12);
        tGeo.translate(0, 0.5, 0); tGeo.rotateX(Math.PI / 2);
        this.tailInstanced = new THREE.InstancedMesh(tGeo, this.fleshMat, this.tailCount);
        this.tailInstanced.castShadow = true;
        this.tailInstanced.receiveShadow = true;
        this.mesh.add(this.tailInstanced);

        this.dummy = new THREE.Object3D();
      }

      update(time, hudRef = null) {
        let t = time * 2.0 + this.timeOffset;

        // Behavioral AI
        let burst = Math.max(0, Math.sin(t * 0.8) + 0.3);
        burst = Math.pow(burst, 2.0);
        let speed = burst * 6.0;
        this.locomotionTime += speed * 0.016;

        let isMoving = speed > 0.5;

        // Pathing (Circle Track)
        let trackRadius = 15;
        let angle = -this.locomotionTime * 0.3 + this.timeOffset;
        this.mesh.position.x = Math.cos(angle) * trackRadius;
        this.mesh.position.z = Math.sin(angle) * trackRadius;
        this.mesh.rotation.y = -angle - Math.PI / 2;

        if (hudRef) {
          hudRef.state.innerText = isMoving ? "SCURRYING // AVOIDANCE" : "ALERT // SNIFFING";
          hudRef.state.style.color = isMoving ? "#00f0ff" : "#ffcc00";
          hudRef.hr.innerText = isMoving ? "540 BPM" : "410 BPM";
          hudRef.resp.innerText = isMoving ? "210 BPM" : (160 + Math.floor(Math.random() * 10)) + " BPM";
          hudRef.coord.innerText = `${this.mesh.position.x.toFixed(2)}, ${this.mesh.position.z.toFixed(2)}`;
        }

        this.body.position.y = 1.3 + (isMoving ? Math.abs(Math.sin(this.locomotionTime * 5.0)) * 0.15 : 0);

        let legCycle = this.locomotionTime * 5.0;
        this.thighL.rotation.x = isMoving ? Math.sin(legCycle) * 0.6 : 0;
        this.thighR.rotation.x = isMoving ? Math.sin(legCycle + Math.PI) * 0.6 : 0;
        this.armL.rotation.x = isMoving ? Math.sin(legCycle + Math.PI) * 0.6 : 0;
        this.armR.rotation.x = isMoving ? Math.sin(legCycle) * 0.6 : 0;

        // Dynamic Whiskers & Head
        if (!isMoving) {
          this.headGroup.rotation.y = Math.sin(time * 6.0) * 0.3;
          this.headGroup.rotation.x = Math.sin(time * 9.0) * 0.15;
          // Rapid sniffing
          this.snoutTip.position.y = -0.15 + Math.sin(time * 40.0) * 0.02;
          this.padL.rotation.y = Math.sin(time * 40.0) * 0.1 + 0.1; // forward
          this.padR.rotation.y = -Math.sin(time * 40.0) * 0.1 - 0.1;
        } else {
          this.headGroup.rotation.set(Math.sin(time * 2) * 0.1, 0, 0);
          this.snoutTip.position.y = -0.15;
          // Swept back during running
          this.padL.rotation.y = -0.3;
          this.padR.rotation.y = 0.3;
        }

        let breath = Math.sin(time * (isMoving ? 20.0 : 12.0)) * 0.015;
        this.body.scale.set(1.0 + breath, 1.0 + breath, 1.0);

        // Tail IK Wave
        let tailBase = new THREE.Vector3(0, -0.2, -2.7);
        tailBase.applyMatrix4(this.body.matrix);
        let prevPt = tailBase.clone();

        for (let i = 0; i < this.tailCount; i++) {
          let p = i / this.tailCount;
          let radius = 1.0 - p * 0.85;
          let segLen = 0.22;

          let waveX = Math.sin(time * 3.5 - i * 0.18) * (i * 0.06);
          let waveY = Math.cos(time * 2.5 - i * 0.15) * (i * 0.02) - i * 0.04;

          if (!isMoving) waveX += Math.sin(i * 0.1) * 0.6;

          let pt = new THREE.Vector3(waveX, waveY + 0.9, -2.7 - i * segLen);

          this.dummy.position.copy(prevPt);
          this.dummy.lookAt(pt);
          this.dummy.scale.set(radius, radius, segLen);
          this.dummy.updateMatrix();
          this.tailInstanced.setMatrixAt(i, this.dummy.matrix);
          prevPt.copy(pt);
        }
        this.tailInstanced.instanceMatrix.needsUpdate = true;
      }
    }

    // --- 6. SCENE ASSEMBLY ---
    const floorGeo = new THREE.PlaneGeometry(200, 200);
    const floorMat = new THREE.MeshStandardMaterial({ color: 0x111213, roughness: 0.1, metalness: 0.5 });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    const grid = new THREE.GridHelper(100, 50, 0x00f0ff, 0x112233);
    grid.position.y = 0.01;
    grid.material.transparent = true; grid.material.opacity = 0.2;
    scene.add(grid);

    const ambLight = new THREE.AmbientLight(0xffffff, 0.3);
    scene.add(ambLight);

    const keyLight = new THREE.DirectionalLight(0xffeedd, 2.5);
    keyLight.position.set(15, 25, 15);
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.width = 2048; keyLight.shadow.mapSize.height = 2048;
    keyLight.shadow.camera.near = 1; keyLight.shadow.camera.far = 100;
    keyLight.shadow.camera.left = -30; keyLight.shadow.camera.right = 30;
    keyLight.shadow.camera.top = 30; keyLight.shadow.camera.bottom = -30;
    keyLight.shadow.bias = -0.0005;
    scene.add(keyLight);

    const rimLight = new THREE.SpotLight(0xaaccff, 5.0, 100, 0.5, 0.5, 1.5);
    rimLight.position.set(-20, 15, -25); rimLight.lookAt(0, 0, 0);
    scene.add(rimLight);

    const bounceLight = new THREE.PointLight(0xffeedd, 0.8, 50);
    bounceLight.position.set(0, 2, 0);
    scene.add(bounceLight);

    // --- 7. INSTANTIATION & RENDER LOOP ---
    const mice = [];

    // White Mouse (BALB/c)
    const mouse1 = new ExpertMouse(false);
    scene.add(mouse1.mesh);
    mice.push(mouse1);

    // Dark Mouse (C57BL/6)
    const mouse2 = new ExpertMouse(true);
    mouse2.timeOffset = 45.2;
    scene.add(mouse2.mesh);
    mice.push(mouse2);

    const hudElements = {
      state: document.getElementById('hud-state'),
      hr: document.getElementById('hud-hr'),
      resp: document.getElementById('hud-resp'),
      coord: document.getElementById('hud-coord')
    };

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    window.dispatchEvent(new Event('resize'));

    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const time = clock.getElapsedTime();

      mice.forEach((m, i) => m.update(time, i === 0 ? hudElements : null));

      controls.update();
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>

</html>
