<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Annolid: High-Fidelity Mouse Genetics Lab</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

    :root {
      color-scheme: dark;
    }

    html,
    body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #030405;
      font-family: 'Share Tech Mono', monospace;
      user-select: none;
    }

    #c {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* Cinematic Overlay */
    .overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      background: radial-gradient(circle at 50% 50%, transparent 40%, rgba(0, 0, 0, 0.85) 120%);
      box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.8);
    }

    /* Telemetry HUD */
    .hud {
      position: absolute;
      bottom: 40px;
      left: 40px;
      color: rgba(200, 230, 255, 0.9);
      font-size: 13px;
      border-left: 3px solid #00f0ff;
      padding-left: 20px;
      background: linear-gradient(90deg, rgba(0, 15, 30, 0.85) 0%, rgba(0, 0, 0, 0) 100%);
      padding: 15px 20px;
      backdrop-filter: blur(5px);
      text-transform: uppercase;
      letter-spacing: 1px;
      pointer-events: none;
    }

    .hud h1 {
      margin: 0 0 10px 0;
      font-size: 16px;
      letter-spacing: 3px;
      color: #fff;
      text-shadow: 0 0 10px rgba(0, 240, 255, 0.5);
    }

    .data-row {
      display: flex;
      justify-content: space-between;
      width: 280px;
      margin-bottom: 4px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      padding-bottom: 2px;
    }

    .label {
      color: #6a95b8;
    }

    .val {
      color: #00f0ff;
      font-weight: bold;
    }

    .val.alert {
      color: #ff3366;
      text-shadow: 0 0 8px rgba(255, 51, 102, 0.6);
    }

    .scanner {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 2px;
      background: rgba(0, 240, 255, 0.1);
      animation: scan 4s linear infinite;
      pointer-events: none;
    }

    @keyframes scan {
      0% {
        top: 0%;
      }

      100% {
        top: 100%;
      }
    }

    /* Custom Lil-GUI Theme to match Sci-Fi UI */
    .lil-gui {
      --background-color: rgba(0, 15, 30, 0.9);
      --text-color: #00f0ff;
      --title-background-color: #004466;
      --widget-color: #005577;
      --hover-color: #007799;
      --focus-color: #0099bb;
      --font-family: 'Share Tech Mono', monospace;
      border: 1px solid #00f0ff;
      box-shadow: 0 0 20px rgba(0, 240, 255, 0.2);
      right: 20px !important;
      top: 20px !important;
    }
  </style>

</head>

<body>
  <canvas id="c"></canvas>
  <div class="overlay"></div>
  <div class="scanner"></div>
  <div class="hud">
    <h1>PRIMARY SUBJECT TELEMETRY</h1>
    <div class="data-row"><span class="label">SUBJECT COUNT</span><span class="val" id="hud-count">0</span></div>
    <div class="data-row"><span class="label">STATE</span><span class="val" id="hud-state">--</span></div>
    <div class="data-row"><span class="label">HEART RATE</span><span class="val alert" id="hud-hr">-- BPM</span></div>
    <div class="data-row"><span class="label">RESPIRATION</span><span class="val" id="hud-resp">-- BPM</span></div>
    <div class="data-row"><span class="label">COORD XZ</span><span class="val" id="hud-coord">0.00, 0.00</span></div>
  </div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.151.3';
    import { OrbitControls } from 'https://esm.sh/three@0.151.3/examples/jsm/controls/OrbitControls.js';
    import GUI from 'https://esm.sh/lil-gui@0.18.2';

    // --- 1. CORE SETUP ---
    const canvas = document.querySelector('#c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: "high-performance" });
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.4; // Brighter for lab environment
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0a0c10, 0.012);

    const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 500);
    camera.position.set(0, 20, 50);

    const controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(0, 1.5, 0);
    controls.maxPolarAngle = Math.PI / 2 - 0.02;

    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    pmremGenerator.compileEquirectangularShader();
    const envScene = new THREE.Scene();
    envScene.background = new THREE.Color(0x000000);
    const box1 = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), new THREE.MeshBasicMaterial({ color: 0xffffff }));
    box1.position.set(15, 20, 15); box1.lookAt(0, 0, 0); envScene.add(box1);
    const box2 = new THREE.Mesh(new THREE.PlaneGeometry(30, 15), new THREE.MeshBasicMaterial({ color: 0xddeeff }));
    box2.position.set(-20, 10, -15); box2.lookAt(0, 0, 0); envScene.add(box2);
    scene.environment = pmremGenerator.fromScene(envScene).texture;

    // --- 2. BASE MATERIALS (Realistic Lab Mouse) ---
    const fleshMatBase = new THREE.MeshPhysicalMaterial({
      roughness: 0.6, transmission: 0.15, thickness: 1.5,
      attenuationDistance: 1.0, clearcoat: 0.05,
      sheen: 0.5, sheenColor: new THREE.Color(0xffcccc),
    });
    const clawMat = new THREE.MeshStandardMaterial({
      color: 0xd7cdc2, roughness: 0.55, metalness: 0.08
    });

    // Realistic beady mouse eye: very dark, highly reflective, convex
    const eyeMat = new THREE.MeshPhysicalMaterial({
      color: 0x020202, roughness: 0.0, metalness: 0.05,
      clearcoat: 1.0, clearcoatRoughness: 0.02, envMapIntensity: 4.0,
      sheen: 0.5, sheenColor: new THREE.Color(0x333344),
    });
    // Cornea overlay for realistic eye dome
    const corneaMat = new THREE.MeshPhysicalMaterial({
      color: 0x000000, transparent: true, opacity: 0.12,
      roughness: 0.0, metalness: 0.0,
      clearcoat: 1.0, clearcoatRoughness: 0.0, envMapIntensity: 5.0,
    });

    // --- 3. ORGANIC GEOMETRY & MATH ---
    function deform(geometry, deformFn) {
      const pos = geometry.attributes.position;
      const v = new THREE.Vector3();
      for (let i = 0; i < pos.count; i++) {
        v.fromBufferAttribute(pos, i);
        deformFn(v);
        pos.setXYZ(i, v.x, v.y, v.z);
      }
      geometry.computeVertexNormals();
      return geometry;
    }

    const deformBody = (v) => {
      const zNorm = (v.z + 1) / 2; // 0 = rear, 1 = front

      // Realistic pear/teardrop: wide haunches tapering to narrower shoulders
      const haunchWidth = 1.0 + (1.0 - zNorm) * 0.2; // Wider at rear
      const shoulderTaper = 1.0 - zNorm * 0.35;
      const lateralProfile = shoulderTaper * haunchWidth;

      v.x *= lateralProfile * 1.55;
      v.y *= shoulderTaper * 1.5;
      v.z *= 2.9; // Body length

      // Natural spinal curve: high mid-back hunch, dips at neck and rump
      const spineY = Math.sin(Math.pow(zNorm, 0.7) * Math.PI) * 0.9;
      v.y += spineY;

      // Lateral belly bulge for rounded cross-section
      if (v.y < 0.2 && v.y > -0.5) {
        const bulge = (1.0 - Math.abs(zNorm - 0.4) * 1.5) * 0.12;
        v.x *= 1.0 + Math.max(0, bulge);
      }

      // Flatten the belly for natural ground contact
      if (v.y < 0) v.y *= 0.5;

      // Enhanced rump rounding for better rear-view profile
      if (zNorm < 0.25) {
        v.y += (0.25 - zNorm) * 0.35;
        v.x *= 1.0 + (0.25 - zNorm) * 0.2; // Wider rump
      }

      // Subtle haunch bulge at hind leg attachment points
      if (zNorm > 0.15 && zNorm < 0.4 && Math.abs(v.x) > 0.3) {
        const haunchBulge = (1.0 - Math.abs(zNorm - 0.27) * 5.0);
        if (haunchBulge > 0) {
          v.x *= 1.0 + haunchBulge * 0.12;
          if (v.y < 0) v.y *= 1.0 + haunchBulge * 0.08;
        }
      }
    };

    const deformHead = (v) => {
      const zNorm = (v.z + 1) / 2; // 0 = back of head, 1 = tip of snout

      // Gentle taper: round cranium softly narrowing toward snout
      // Exponent 1.0 = linear (gentler than previous 1.3 which was too sharp)
      const snoutTaper = Math.pow(1.0 - zNorm * 0.6, 1.0);
      v.x *= snoutTaper * 1.15;  // Wider overall
      v.y *= snoutTaper * 0.98;  // Keep more height
      v.z *= 1.4; // Slightly shorter head (less elongated = less pointy)

      // Gentle snout droop
      v.y -= zNorm * 0.12;

      // Full, round cheeks (wider fill zone)
      if (zNorm < 0.5) {
        const cheekFill = (0.5 - zNorm) * 0.4;
        v.x *= 1.0 + cheekFill;
        // Jaw/cheek rounding
        if (v.y < 0) v.x *= 1.0 + cheekFill * 0.4;
      }

      // Soft snout narrowing (much gentler than before)
      if (zNorm > 0.6) {
        const pinch = (zNorm - 0.6) / 0.4;
        v.x *= 1.0 - pinch * 0.35; // Less aggressive narrowing (was 0.55)
        v.y *= 1.0 - pinch * 0.15; // Keep more height (was 0.25)
        v.y -= pinch * 0.04;
      }

      // Rounded cranial dome
      if (zNorm > 0.1 && zNorm < 0.55 && v.y > 0) {
        const domeFactor = 1.0 - Math.abs(zNorm - 0.3) * 2.5;
        v.y += Math.max(0, domeFactor) * 0.2;
      }

      // Subtle orbital ridges
      if (zNorm > 0.3 && zNorm < 0.5 && Math.abs(v.x) > 0.3) {
        v.y += 0.04;
      }
    };

    const deformThigh = (v) => {
      v.x *= 0.6;
      v.y *= 1.2;
      v.z *= 1.2;
      v.z -= v.y * 0.3;
    };

    // Realistic lab mouse ear: large, round, thin, petal-like with translucent membrane
    const deformEar = (v) => {
      const y01 = (v.y + 1.0) * 0.5;
      const x01 = (v.x + 1.0) * 0.5;

      const radial = Math.sqrt(v.x * v.x + v.y * v.y);
      const edge = Math.min(1.0, Math.pow(radial, 1.1));

      // Large, round, petal-like profile (mice have proportionally huge round ears)
      v.x *= 1.3;
      v.y *= 1.25;
      v.z *= 0.06; // Very thin membrane

      // Smooth satellite-dish concavity
      const concave = Math.pow(radial, 1.4) * 0.7;
      v.z -= concave;

      // Thin raised rim around the edge
      const rimWidth = 0.15;
      const rimDist = Math.abs(radial - 0.85);
      if (rimDist < rimWidth) {
        const rimStrength = 1.0 - rimDist / rimWidth;
        v.z += rimStrength * rimStrength * 0.12;
      }

      // Fleshy base attachment (ear joins head with a thick stalk)
      if (y01 < 0.3) {
        const taper = Math.pow(y01 / 0.3, 0.7);
        v.x *= taper;
        v.z += (0.3 - y01) * 0.5; // Fold base inward
        // Thicken the base
        v.z *= 1.0 + (0.3 - y01) * 2.0;
      }

      // Smooth rounded tip (no sharp point - lab mouse ears are round)
      if (y01 > 0.75) {
        const tipRound = 1.0 - (y01 - 0.75) * 2.0;
        v.x *= Math.max(0.15, tipRound);
        v.y *= Math.max(0.6, tipRound);
      }

      // Gentle forward cup (ear angled to catch sound)
      v.z -= (1.0 - y01) * 0.08;
    };

    const bodyGeo = deform(new THREE.SphereGeometry(1, 64, 64), deformBody);
    const headGeo = deform(new THREE.SphereGeometry(1, 48, 48), deformHead);
    const thighGeo = deform(new THREE.SphereGeometry(1, 32, 32), deformThigh);
    const earGeo = deform(new THREE.SphereGeometry(1, 32, 32), deformEar);

    function createPaw(mat, isFore = false, strain = {}) {
      const paw = new THREE.Group();
      const padMat = mat.clone();
      padMat.color.multiplyScalar(strain.padDarken ?? 0.84);
      padMat.transmission = 0.18;
      padMat.thickness = 0.35;
      padMat.roughness = 0.52;

      // Make paws smaller, fleshier, more hand-like
      if (isFore) {
        // Complex front paw (like a tiny hand)
        // Main proximal pad (palm)
        const palm = new THREE.Mesh(new THREE.SphereGeometry(0.08, 16, 16), padMat);
        palm.scale.set(1.1, 0.4, 0.9);
        palm.position.set(0, -0.04, 0.05);
        palm.castShadow = true;
        paw.add(palm);

        // 3 interdigital pads at the base of the toes
        for (let p = 0; p < 3; p++) {
          const iPad = new THREE.Mesh(new THREE.SphereGeometry(0.045, 12, 12), padMat);
          iPad.scale.set(1, 0.5, 1);
          iPad.position.set((p - 1) * 0.05, -0.04, 0.0);
          iPad.castShadow = true;
          paw.add(iPad);
        }
      } else {
        const sole = new THREE.Mesh(new THREE.SphereGeometry(0.16, 20, 20), padMat);
        sole.scale.set(1.1, 0.4, 1.3);
        sole.position.set(0, -0.04, 0.03);
        sole.castShadow = true;
        paw.add(sole);
      }

      const pawSpreadMul = strain.pawSpreadMul ?? 1.0;
      const toeCount = isFore ? 4 : 5;
      const baseSpread = isFore ? 0.12 : 0.10; // Wider toe splay
      const spread = baseSpread * pawSpreadMul;

      const clawMat = new THREE.MeshPhysicalMaterial({ color: 0xcccccc, roughness: 0.3, clearcoat: 0.8 });

      for (let i = 0; i < toeCount; i++) {
        const t = (i - (toeCount - 1) * 0.5) * spread;
        const arc = (Math.abs(i - (toeCount - 1) * 0.5) / (toeCount * 0.5 + 0.01));

        const toe = new THREE.Group();

        // Toe length variation (outer toes shorter)
        let lenMul = 1.0;
        if (isFore && (i === 0 || i === 3)) lenMul = 0.8;
        if (!isFore && (i === 0 || i === 4)) lenMul = 0.75;

        const toeLen = (isFore ? 0.22 : 0.25) * (strain.toeLenMul ?? 1.0) * lenMul;

        const p1Geo = new THREE.CapsuleGeometry(isFore ? 0.025 : 0.034, toeLen, 10, 10);
        const p1 = new THREE.Mesh(p1Geo, mat);
        p1.rotation.x = Math.PI / 2;
        p1.castShadow = true;
        toe.add(p1);

        if (isFore) {
          // Add a prominent knuckle for realistic hand-like digits
          const knuckle = new THREE.Mesh(new THREE.SphereGeometry(0.032, 10, 10), mat);
          knuckle.position.set(0, 0.012, -toeLen * 0.35);
          knuckle.castShadow = true;
          toe.add(knuckle);

          // Angle the tips down slightly for an articulated, grasping shape
          p1.rotation.x = Math.PI / 2 - 0.15;
        }

        let zPos = isFore ? (0.16 - arc * 0.04) : (0.24 - arc * 0.03);

        toe.position.set(t, -0.035 + arc * 0.012, zPos);
        paw.add(toe);

        const toePad = new THREE.Mesh(new THREE.SphereGeometry(isFore ? 0.035 : 0.045, 10, 10), padMat);
        toePad.scale.set(1.15, 0.48, 1.0);
        toePad.position.set(t, -0.12 + arc * 0.008, zPos + (isFore ? 0.09 : 0.08) * lenMul);
        toePad.castShadow = true;
        paw.add(toePad);

        const clawLocalMat = clawMat.clone();
        clawLocalMat.color.set(strain.clawColor ?? 0xd7cdc2);
        const clawLength = isFore ? 0.05 : 0.07;
        const clawGeo = new THREE.ConeGeometry(isFore ? 0.012 : 0.016, clawLength, 8);
        clawGeo.translate(0, -clawLength / 2, 0); // Pinched tip
        const claw = new THREE.Mesh(clawGeo, clawLocalMat);
        claw.rotation.x = Math.PI / 2 + (isFore ? -0.2 : 0);
        claw.position.set(t, -0.06 + arc * 0.004, zPos + (isFore ? 0.13 : 0.17) * lenMul);
        claw.castShadow = true;
        paw.add(claw);
      }
      return paw;
    }

    function createVolumetricWhiskers(colorHex, isLeft) {
      const group = new THREE.Group();
      const mat = new THREE.MeshBasicMaterial({ color: colorHex, transparent: true, opacity: 0.5 });
      const sign = isLeft ? 1 : -1;
      for (let i = 0; i < 18; i++) {
        const curve = new THREE.QuadraticBezierCurve3(
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(sign * 0.6, (Math.random() - 0.5) * 0.3, 0.3),
          new THREE.Vector3(sign * (1.2 + Math.random() * 0.6), (Math.random() - 0.5) * 0.8, 0.4 + Math.random() * 0.6)
        );
        const geo = new THREE.TubeGeometry(curve, 6, 0.005, 4, false);
        group.add(new THREE.Mesh(geo, mat));
      }
      return group;
    }

    // --- 4. PROCEDURAL FUR GENERATOR (Multi-Layer Realistic) ---
    function generateFurLayer(deformFn, count, colorHex, length, isHead, isUndercoat = false) {
      if (count <= 0) return new THREE.Group(); // Handles zero fur case

      // Undercoat: thicker, softer strands. Guard hairs: thinner, tapered
      const radius = isUndercoat ? 0.025 : 0.016;
      const geo = new THREE.ConeGeometry(radius, length, 4);
      geo.translate(0, length / 2, 0);
      geo.rotateX(-Math.PI / 2);

      const mat = new THREE.MeshPhysicalMaterial({
        color: colorHex,
        roughness: isUndercoat ? 0.92 : 0.75,
        clearcoat: isUndercoat ? 0.0 : 0.12,
        sheen: isUndercoat ? 0.7 : 1.2,
        sheenColor: new THREE.Color(0xffffff),
        sheenRoughness: isUndercoat ? 0.7 : 0.35,
      });

      const inst = new THREE.InstancedMesh(geo, mat, count);
      inst.receiveShadow = true;

      // Enable per-instance color for natural variation
      inst.instanceColor = new THREE.InstancedBufferAttribute(
        new Float32Array(count * 3), 3
      );

      const baseColor = new THREE.Color(colorHex);
      const strandColor = new THREE.Color();
      const dummy = new THREE.Object3D();
      const pos = new THREE.Vector3();
      const normal = new THREE.Vector3();

      for (let i = 0; i < count; i++) {
        const u = Math.random(), v = Math.random();
        const theta = u * 2.0 * Math.PI;
        const phi = Math.acos(2.0 * v - 1.0);
        pos.set(Math.sin(phi) * Math.cos(theta), Math.sin(phi) * Math.sin(theta), Math.cos(phi));

        normal.copy(pos).normalize();
        const preDeformZ = pos.z;
        deformFn(pos);
        pos.addScaledVector(normal, isUndercoat ? 0.005 : 0.012);

        // Improved flow direction: fur lies flat along body, naturalistic
        let flowDir;
        if (isHead && preDeformZ > 0.3) {
          // Face fur flows forward and slightly downward
          flowDir = new THREE.Vector3(normal.x * 0.15, -0.2, -1).normalize();
        } else if (isHead) {
          // Back of head, fur flows backward
          flowDir = new THREE.Vector3(normal.x * 0.3, normal.y * 0.2, -1).normalize();
        } else {
          // Body fur flows backward and slightly downward (gravity)
          flowDir = new THREE.Vector3(normal.x * 0.5, normal.y * 0.3 - 0.15, -1).normalize();
        }

        // Undercoat lies flatter, guard hairs stand up more
        if (isUndercoat) {
          flowDir.lerp(new THREE.Vector3(0, 0, -1), 0.3);
          flowDir.normalize();
        }

        dummy.position.copy(pos);
        dummy.lookAt(pos.clone().add(flowDir));

        let scale = 0.5 + Math.random() * 0.7;
        if (isHead && preDeformZ > 0.4) scale *= 0.3; // Very short on snout
        if (isHead && preDeformZ > 0.2 && preDeformZ <= 0.4) scale *= 0.6; // Medium on face
        if (!isHead && preDeformZ < -0.6) scale *= 1.25; // Longer on rump

        // Undercoat is more uniform length, guard hairs vary more
        if (isUndercoat) scale = 0.6 + Math.random() * 0.3;

        // Add slight random curl/jitter for natural imperfection
        const jitter = isUndercoat ? 0.15 : 0.08;
        dummy.rotation.x += (Math.random() - 0.5) * jitter;
        dummy.rotation.y += (Math.random() - 0.5) * jitter;

        dummy.scale.set(scale, scale, scale);
        dummy.updateMatrix();
        inst.setMatrixAt(i, dummy.matrix);

        // Per-strand color variation for realistic natural fur
        strandColor.copy(baseColor);
        const hsl = {};
        strandColor.getHSL(hsl);
        // Vary luminance ±8%, saturation ±5%
        const lumVar = isUndercoat ? 0.06 : 0.08;
        const satVar = 0.05;
        strandColor.setHSL(
          hsl.h + (Math.random() - 0.5) * 0.02,
          Math.max(0, Math.min(1, hsl.s + (Math.random() - 0.5) * satVar)),
          Math.max(0, Math.min(1, hsl.l + (Math.random() - 0.5) * lumVar))
        );
        inst.instanceColor.setXYZ(i, strandColor.r, strandColor.g, strandColor.b);
      }
      return inst;
    }

    // Multi-layer fur: underfur + guard hairs
    function generateMultiLayerFur(deformFn, density, furColor, isHead) {
      const group = new THREE.Group();
      if (density <= 0) return group;

      // Three-layer fur system: vellus (peach fuzz) + undercoat + guard hairs
      const vellusCount = Math.floor((isHead ? 8000 : 15000) * density);
      const underCount = Math.floor((isHead ? 18000 : 35000) * density);
      const guardCount = Math.floor((isHead ? 20000 : 40000) * density);
      const vellusLen = isHead ? 0.03 : 0.05;
      const underLen = isHead ? 0.07 : 0.12;
      const guardLen = isHead ? 0.14 : 0.24;

      // Vellus layer: very short, dense peach-fuzz for complete skin coverage
      group.add(generateFurLayer(deformFn, vellusCount, furColor, vellusLen, isHead, true));
      group.add(generateFurLayer(deformFn, underCount, furColor, underLen, isHead, true));
      group.add(generateFurLayer(deformFn, guardCount, furColor, guardLen, isHead, false));
      return group;
    }

    // Enclosure bounds shared by motion + rendering.
    const ENCLOSURE_W = 36;
    const ENCLOSURE_H = 9;
    const ENCLOSURE_D = 26;
    const ENCLOSURE_PAD = 1.6;
    const ENCLOSURE_HALF_X = ENCLOSURE_W * 0.5 - ENCLOSURE_PAD;
    const ENCLOSURE_HALF_Z = ENCLOSURE_D * 0.5 - ENCLOSURE_PAD;

    // --- NEUROSCIENCE POSE TRACKING CONSTANTS ---
    const POSE_CONNECTIONS = [
      ['snout', 'lear'], ['snout', 'rear'], ['lear', 'neck'], ['rear', 'neck'],
      ['neck', 'spine1'], ['spine1', 'spine2'], ['spine2', 'tailbase'],
      ['neck', 'lforepaw'], ['neck', 'rforepaw'],
      ['spine2', 'lhindpaw'], ['spine2', 'rhindpaw'],
      ['tailbase', 'tailmid'], ['tailmid', 'tailend']
    ];

    const POSE_COLORS = {
      snout: 0xff0055, lear: 0xff5500, rear: 0xff5500, neck: 0x00ffaa,
      spine1: 0x00aaff, spine2: 0x0055ff, tailbase: 0xaa00ff,
      lforepaw: 0xaaff00, rforepaw: 0xaaff00, lhindpaw: 0x00ff00, rhindpaw: 0x00ff00,
      tailmid: 0xff00ff, tailend: 0xff00aa
    };

    // --- 5. EXPERT MOUSE CLASS ---
    class ExpertMouse {
      constructor(params) {
        this.mesh = new THREE.Group();
        this.timeOffset = Math.random() * 1000;
        this.locomotionTime = 0;
        this.guiParams = params;

        // --- PHYSICS STATE ---
        // Position is set directly on this.mesh.position
        // Velocity in world XZ plane
        this.velocity = new THREE.Vector2(0, 0);
        // Accumulated force each frame
        this.force = new THREE.Vector2(0, 0);
        // Heading direction (unit vector)
        this.heading = new THREE.Vector2(0, 1);
        // Physical constants
        this.mass = 0.025 + Math.random() * 0.010; // ~25-35g lab mouse
        this.maxSpeed = 8.0 + Math.random() * 3.0; // Faster default
        this.drag = 2.5;
        // Wander behaviour
        this.wanderAngle = Math.random() * Math.PI * 2;
        this.wanderRate = 0.8 + Math.random() * 0.6;
        this.wanderStrength = 2.5 + Math.random() * 1.5;
        this.burstPhase = Math.random() * Math.PI * 2;
        this.speedMult = 0.8 + Math.random() * 0.5;
        this.dir = Math.random() > 0.5 ? 1 : -1;
        this.wallFollowDir = Math.random() > 0.5 ? 1 : -1;
        // Anti-stuck tracking
        this.lastPos = new THREE.Vector2(0, 0);
        this.stuckTimer = 0;
        // Tail rendering
        this.tailSegLen = 0.22;

        const furColor = params.furColor;
        const skinColor = params.skinColor;
        const density = params.furDensity;
        const chonk = params.chonkiness;
        const eSize = params.earSize;
        const strain = getStrainProfile(params.presets);
        this.motion = {
          gaitAmpMul: strain.gaitAmpMul ?? 1.0,
          headIdleYawMul: strain.headIdleYawMul ?? 1.0,
          headIdlePitchMul: strain.headIdlePitchMul ?? 1.0,
          sniffAmpMul: strain.sniffAmpMul ?? 1.0,
          breathIdleAmp: strain.breathIdleAmp ?? 0.013,
          breathMoveAmp: strain.breathMoveAmp ?? 0.016,
          breathIdleFreq: strain.breathIdleFreq ?? 12.0,
          breathMoveFreq: strain.breathMoveFreq ?? 20.0,
          tailWaveAmpMul: strain.tailWaveAmpMul ?? 1.0,
          tailWaveFreqMul: strain.tailWaveFreqMul ?? 1.0
        };

        // Custom Skin Material
        this.fleshMat = fleshMatBase.clone();
        this.fleshMat.color.set(skinColor);
        // Calculate attenuation based on brightness of skin
        const skinHSL = {}; this.fleshMat.color.getHSL(skinHSL);
        this.fleshMat.attenuationColor.setHSL(skinHSL.h, skinHSL.s, skinHSL.l * 0.5);

        // --- RIGGING HIERARCHY ---
        this.rig = new THREE.Group();
        this.mesh.add(this.rig);

        // BODY (Subject to Chonk scaling)
        this.bodyMesh = new THREE.Mesh(bodyGeo, this.fleshMat);
        this.bodyMesh.scale.set(1, chonk, chonk); // Scales height/width
        this.bodyMesh.castShadow = true;
        this.rig.add(this.bodyMesh);

        this.bodyMesh.add(generateMultiLayerFur(deformBody, density, furColor, false));

        // NECK COLLAR — capsule mesh to seamlessly bridge head and body
        const neckGeo = new THREE.CapsuleGeometry(0.55, 0.8, 12, 12);
        const neckMesh = new THREE.Mesh(neckGeo, this.fleshMat);
        neckMesh.position.set(0, 0.15, 2.2);
        neckMesh.rotation.x = Math.PI / 2 + 0.15; // Slight forward tilt
        neckMesh.scale.set(1.0, 1.0, 0.85); // Slightly flattened
        neckMesh.castShadow = true;
        this.rig.add(neckMesh);
        // Add fur to the neck collar
        const neckFurGroup = new THREE.Group();
        const neckFurCount = Math.floor(4000 * density);
        if (neckFurCount > 0) {
          const neckFurGeo = new THREE.ConeGeometry(0.008, 0.12, 3);
          neckFurGeo.translate(0, 0.06, 0);
          const neckFurMat = new THREE.MeshPhysicalMaterial({
            color: new THREE.Color(furColor),
            roughness: 0.7,
            transparent: true,
            opacity: 0.85
          });
          const neckFurInst = new THREE.InstancedMesh(neckFurGeo, neckFurMat, neckFurCount);
          const neckDummy = new THREE.Object3D();
          const neckNrm = new THREE.Vector3();
          for (let i = 0; i < neckFurCount; i++) {
            // Sample points on a capsule-like surface
            const theta = Math.random() * Math.PI * 2;
            const phi = (Math.random() - 0.5) * Math.PI * 0.8;
            neckNrm.set(
              Math.cos(theta) * Math.cos(phi) * 0.55,
              Math.sin(phi) * 0.4,
              Math.sin(theta) * Math.cos(phi) * 0.55
            );
            neckDummy.position.copy(neckNrm);
            neckDummy.position.y += (Math.random() - 0.5) * 0.6;
            neckNrm.normalize();
            neckDummy.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), neckNrm);
            const s = 0.8 + Math.random() * 0.4;
            neckDummy.scale.set(s, s, s);
            neckDummy.updateMatrix();
            neckFurInst.setMatrixAt(i, neckDummy.matrix);
          }
          neckMesh.add(neckFurInst);
        }

        // BELLY BRIDGE — fills the underside gap between head and body
        const bellyGeo = new THREE.CapsuleGeometry(0.4, 1.2, 8, 8);
        const bellyMesh = new THREE.Mesh(bellyGeo, this.fleshMat);
        bellyMesh.position.set(0, -0.35, 1.8);
        bellyMesh.rotation.x = Math.PI / 2;
        bellyMesh.scale.set(1.1, 1.0, 0.7);
        this.rig.add(bellyMesh);

        // HEAD (Independent of Chonk scaling)
        this.headGroup = new THREE.Group();
        this.headGroup.position.set(0, 0.35 * chonk, 2.7); // Adjust position based on chonk
        this.rig.add(this.headGroup);

        this.head = new THREE.Mesh(headGeo, this.fleshMat);
        this.head.castShadow = true;
        this.headGroup.add(this.head);
        this.head.add(generateMultiLayerFur(deformHead, density, furColor, true));

        // SNOUT & WHISKERS (Realistic wet nose)
        const noseMat = this.fleshMat.clone();
        noseMat.color.set(strain.noseColor ?? skinColor);
        noseMat.roughness = 0.15; // Wet/glossy nose
        noseMat.transmission = 0.2;
        noseMat.thickness = 0.3;
        noseMat.clearcoat = 0.8; // Shiny wet surface
        noseMat.clearcoatRoughness = 0.1;
        noseMat.metalness = 0.0;
        this.snoutTip = new THREE.Mesh(new THREE.SphereGeometry(0.13, 20, 20), noseMat);
        this.snoutTip.scale.set(1.1, 0.8, 1.0); // Wider than tall
        this.snoutTip.position.set(0, -0.18, 1.5);
        this.head.add(this.snoutTip);

        // Nostrils (two small dark indentations)
        const nostrilMat = new THREE.MeshBasicMaterial({ color: 0x111111 });
        const nostrilL = new THREE.Mesh(new THREE.SphereGeometry(0.025, 8, 8), nostrilMat);
        nostrilL.position.set(0.045, -0.01, 0.11);
        this.snoutTip.add(nostrilL);
        const nostrilR = new THREE.Mesh(new THREE.SphereGeometry(0.025, 8, 8), nostrilMat);
        nostrilR.position.set(-0.045, -0.01, 0.11);
        this.snoutTip.add(nostrilR);

        // MOUTH
        const mouthMat = new THREE.MeshBasicMaterial({ color: 0x1a1a1a });
        this.mouth = new THREE.Mesh(new THREE.CapsuleGeometry(0.035, 0.07, 8, 8), mouthMat);
        this.mouth.rotation.z = Math.PI / 2;
        this.mouth.position.set(0, -0.28, 1.38);
        this.head.add(this.mouth);

        const wColor = skinHSL.l > 0.5 ? 0xaaaaaa : 0x444444; // Whiskers match dark/light theme
        this.padL = new THREE.Group(); this.padL.position.set(0.1, -0.05, 1.1); this.head.add(this.padL);
        this.padR = new THREE.Group(); this.padR.position.set(-0.1, -0.05, 1.1); this.head.add(this.padR);
        this.padL.add(createVolumetricWhiskers(wColor, true));
        this.padR.add(createVolumetricWhiskers(wColor, false));

        // EARS & EYES (Realistic lab mouse: large, round, translucent ears)
        const earOuterMat = this.fleshMat.clone();
        earOuterMat.transmission = strain.earOuterTransmission ?? 0.6;
        earOuterMat.thickness = 0.15;
        earOuterMat.roughness = strain.earOuterRoughness ?? 0.4;
        earOuterMat.side = THREE.DoubleSide; // Ears visible from both sides
        const earInnerMat = this.fleshMat.clone();
        earInnerMat.color.offsetHSL(
          0.0,
          strain.earInnerSatOffset ?? 0.12,
          strain.earInnerLightOffset ?? 0.12
        );
        earInnerMat.transmission = strain.earInnerTransmission ?? 0.78;
        earInnerMat.thickness = 0.08;
        earInnerMat.roughness = 0.3;
        earInnerMat.side = THREE.DoubleSide;

        // Ears positioned wide, high, angled outward like satellite dishes
        const earL = new THREE.Mesh(earGeo, earOuterMat);
        earL.position.set(0.62, 0.42 + (strain.earHeightOffset ?? 0.0), -0.35);
        earL.rotation.set(-0.3, -(strain.earYaw ?? 0.75), 0.25);
        earL.scale.set(eSize, eSize, eSize);
        earL.castShadow = true; this.head.add(earL);

        const earLInner = new THREE.Mesh(earGeo, earInnerMat);
        earLInner.scale.set(0.82, 0.85, 0.5);
        earLInner.position.set(0.00, 0.0, -0.05);
        earL.add(earLInner);

        const earR = new THREE.Mesh(earGeo, earOuterMat);
        earR.position.set(-0.62, 0.42 + (strain.earHeightOffset ?? 0.0), -0.35);
        earR.rotation.set(-0.3, (strain.earYaw ?? 0.75), -0.25);
        earR.scale.set(eSize, eSize, eSize);
        earR.castShadow = true; this.head.add(earR);

        const earRInner = new THREE.Mesh(earGeo, earInnerMat);
        earRInner.scale.set(0.82, 0.85, 0.5);
        earRInner.position.set(0.00, 0.0, -0.05);
        earR.add(earRInner);

        // Eyes: beady, protruding, laterally placed (mice are prey animals)
        const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.16, 20, 20), eyeMat);
        eyeL.scale.set(1.0, 0.95, 1.15); // Slightly protruding
        eyeL.position.set(0.50, 0.15, 0.5);
        eyeL.castShadow = true;
        this.head.add(eyeL);

        // Cornea dome for realistic specular highlight
        const corneaL = new THREE.Mesh(new THREE.SphereGeometry(0.165, 20, 20), corneaMat);
        corneaL.scale.set(1.0, 0.95, 1.2);
        corneaL.position.copy(eyeL.position);
        this.head.add(corneaL);

        const eyeR = new THREE.Mesh(new THREE.SphereGeometry(0.16, 20, 20), eyeMat);
        eyeR.scale.set(1.0, 0.95, 1.15);
        eyeR.position.set(-0.50, 0.15, 0.5);
        eyeR.castShadow = true;
        this.head.add(eyeR);

        const corneaR = new THREE.Mesh(new THREE.SphereGeometry(0.165, 20, 20), corneaMat);
        corneaR.scale.set(1.0, 0.95, 1.2);
        corneaR.position.copy(eyeR.position);
        this.head.add(corneaR);

        // LIMBS
        // Hind legs with prominent haunches blending into body
        this.hindL = new THREE.Group();
        this.hindL.position.set(0.55, -0.15, -1.4); // Closer to body for better blending
        this.rig.add(this.hindL);
        this.thighL = new THREE.Mesh(thighGeo, this.fleshMat);
        this.thighL.scale.set(1.15, 1.0, 1.15); // Thicker thighs
        this.hindL.add(this.thighL);
        this.thighL.add(generateFurLayer(deformThigh, Math.floor(6000 * density), furColor, 0.15, false));
        this.shankL = new THREE.Group();
        this.shankL.position.set(0.02, -0.65, 0.14);
        this.thighL.add(this.shankL);
        const shankMeshL = new THREE.Mesh(new THREE.CapsuleGeometry(0.12, 0.6, 8, 8), this.fleshMat);
        shankMeshL.rotation.x = -0.05;
        shankMeshL.position.set(0.0, -0.28, 0.05);
        shankMeshL.castShadow = true;
        this.shankL.add(shankMeshL);
        const heelL = new THREE.Mesh(new THREE.SphereGeometry(0.12, 14, 14), this.fleshMat);
        heelL.scale.set(1.0, 0.9, 1.2);
        heelL.position.set(0.0, -0.6, 0.15);
        heelL.castShadow = true;
        this.shankL.add(heelL);
        const pawBL = createPaw(this.fleshMat, false, strain);
        pawBL.position.set(0.0, -0.7, 0.22);
        this.shankL.add(pawBL);

        this.hindR = new THREE.Group();
        this.hindR.position.set(-0.55, -0.15, -1.4); // Closer to body for better blending
        this.rig.add(this.hindR);
        this.thighR = new THREE.Mesh(thighGeo, this.fleshMat);
        this.thighR.scale.set(1.15, 1.0, 1.15); // Thicker thighs
        this.hindR.add(this.thighR);
        this.thighR.add(generateFurLayer(deformThigh, Math.floor(6000 * density), furColor, 0.15, false));
        this.shankR = new THREE.Group();
        this.shankR.position.set(-0.02, -0.65, 0.14);
        this.thighR.add(this.shankR);
        const shankMeshR = new THREE.Mesh(new THREE.CapsuleGeometry(0.12, 0.6, 8, 8), this.fleshMat);
        shankMeshR.rotation.x = -0.05;
        shankMeshR.position.set(0.0, -0.28, 0.05);
        shankMeshR.castShadow = true;
        this.shankR.add(shankMeshR);
        const heelR = new THREE.Mesh(new THREE.SphereGeometry(0.12, 14, 14), this.fleshMat);
        heelR.scale.set(1.0, 0.9, 1.2);
        heelR.position.set(0.0, -0.6, 0.15);
        heelR.castShadow = true;
        this.shankR.add(heelR);
        const pawBR = createPaw(this.fleshMat, false, strain);
        pawBR.position.set(0.0, -0.7, 0.22);
        this.shankR.add(pawBR);

        this.armL = new THREE.Group(); this.armL.position.set(0.45, -0.15, 1.8); this.rig.add(this.armL);
        // Forearm with fur covering for side-view realism
        const armMeshL = new THREE.Mesh(new THREE.CylinderGeometry(0.16, 0.07, 0.8, 12), this.fleshMat);
        armMeshL.position.y = -0.4; this.armL.add(armMeshL);
        // Fur on forearms (subtle short fur)
        const armFurCountL = Math.floor(1500 * density);
        if (armFurCountL > 0) {
          const armFurGeo = new THREE.ConeGeometry(0.005, 0.06, 3);
          armFurGeo.translate(0, 0.03, 0);
          const armFurMat = new THREE.MeshPhysicalMaterial({ color: new THREE.Color(furColor), roughness: 0.7, transparent: true, opacity: 0.8 });
          const armFurInstL = new THREE.InstancedMesh(armFurGeo, armFurMat, armFurCountL);
          const armDummy = new THREE.Object3D();
          for (let i = 0; i < armFurCountL; i++) {
            const h = (Math.random() - 0.5) * 0.7;
            const ang = Math.random() * Math.PI * 2;
            const r = 0.12 + Math.random() * 0.04;
            armDummy.position.set(Math.cos(ang) * r, h, Math.sin(ang) * r);
            const nrm = new THREE.Vector3(Math.cos(ang), 0.3, Math.sin(ang)).normalize();
            armDummy.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), nrm);
            const s = 0.7 + Math.random() * 0.6;
            armDummy.scale.set(s, s, s);
            armDummy.updateMatrix();
            armFurInstL.setMatrixAt(i, armDummy.matrix);
          }
          armMeshL.add(armFurInstL);
        }
        const pawFL = createPaw(this.fleshMat, true, strain); pawFL.position.set(0, -0.8, 0.08); this.armL.add(pawFL);

        this.armR = new THREE.Group(); this.armR.position.set(-0.45, -0.15, 1.8); this.rig.add(this.armR);
        const armMeshR = new THREE.Mesh(new THREE.CylinderGeometry(0.16, 0.07, 0.8, 12), this.fleshMat);
        armMeshR.position.y = -0.4; this.armR.add(armMeshR);
        if (armFurCountL > 0) {
          const armFurGeoR = new THREE.ConeGeometry(0.005, 0.06, 3);
          armFurGeoR.translate(0, 0.03, 0);
          const armFurMatR = new THREE.MeshPhysicalMaterial({ color: new THREE.Color(furColor), roughness: 0.7, transparent: true, opacity: 0.8 });
          const armFurInstR = new THREE.InstancedMesh(armFurGeoR, armFurMatR, armFurCountL);
          const armDummyR = new THREE.Object3D();
          for (let i = 0; i < armFurCountL; i++) {
            const h = (Math.random() - 0.5) * 0.7;
            const ang = Math.random() * Math.PI * 2;
            const r = 0.12 + Math.random() * 0.04;
            armDummyR.position.set(Math.cos(ang) * r, h, Math.sin(ang) * r);
            const nrm = new THREE.Vector3(Math.cos(ang), 0.3, Math.sin(ang)).normalize();
            armDummyR.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), nrm);
            const s = 0.7 + Math.random() * 0.6;
            armDummyR.scale.set(s, s, s);
            armDummyR.updateMatrix();
            armFurInstR.setMatrixAt(i, armDummyR.matrix);
          }
          armMeshR.add(armFurInstR);
        }
        const pawFR = createPaw(this.fleshMat, true, strain); pawFR.position.set(0, -0.8, 0.08); this.armR.add(pawFR);

        // TAIL (with ring-texture scale wobble for realistic scaly tail)
        this.tailCount = 45;
        const tailMat = this.fleshMat.clone();
        tailMat.roughness = 0.6;
        tailMat.transmission = 0.25;
        tailMat.thickness = 0.4;
        tailMat.clearcoat = 0.15;
        const tGeo = new THREE.CylinderGeometry(0.08, 0.08, 1, 12);
        tGeo.translate(0, 0.5, 0); tGeo.rotateX(Math.PI / 2);
        this.tailInstanced = new THREE.InstancedMesh(tGeo, tailMat, this.tailCount);
        this.tailInstanced.castShadow = true;
        this.tailInstanced.receiveShadow = true;
        this.mesh.add(this.tailInstanced);

        this.dummy = new THREE.Object3D();

        // SKELETON / POSE TRACKING (100x Neuroscience / SLEAP / DLC)
        this.poseNodes = {};
        this.trackingGroup = new THREE.Group();
        this.mesh.add(this.trackingGroup);

        const createTrackingNode = (id, parent, localPos) => {
          const mat = new THREE.MeshBasicMaterial({
            color: POSE_COLORS[id] || 0xffffff,
            depthTest: false,
            transparent: true,
            opacity: 0.9
          });
          const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.12, 12, 12), mat);
          sphere.renderOrder = 999;

          if (parent) {
            sphere.position.copy(localPos);
            parent.add(sphere);
            // We store a reference to the sphere to track its world position later
            this.poseNodes[id] = sphere;
          } else {
            // For nodes that move dynamically (like tail mid/end)
            this.trackingGroup.add(sphere);
            this.poseNodes[id] = sphere;
          }
        };

        createTrackingNode('snout', this.headGroup, new THREE.Vector3(0, -0.15, 1.45));
        createTrackingNode('lear', this.headGroup, new THREE.Vector3(0.55, 0.45, -0.15));
        createTrackingNode('rear', this.headGroup, new THREE.Vector3(-0.55, 0.45, -0.15));

        // Spine follows rig but with local offsets
        createTrackingNode('neck', this.rig, new THREE.Vector3(0, 0.6, 1.8));
        createTrackingNode('spine1', this.rig, new THREE.Vector3(0, 0.9, 0.2));
        createTrackingNode('spine2', this.rig, new THREE.Vector3(0, 0.8, -1.2));
        createTrackingNode('tailbase', this.rig, new THREE.Vector3(0, 0.3, -2.7));

        // Connect paws securely to the rig, not the scaled/animated individual limbs
        // Note: Paws need to ride the actual animated limb to not detach during walk cycles
        createTrackingNode('lforepaw', this.armL, new THREE.Vector3(0, -0.8, 0.08));
        createTrackingNode('rforepaw', this.armR, new THREE.Vector3(0, -0.8, 0.08));
        createTrackingNode('lhindpaw', this.hindL, new THREE.Vector3(0, -0.78, 0.34));
        createTrackingNode('rhindpaw', this.hindR, new THREE.Vector3(0, -0.78, 0.34));

        this.mesh.updateMatrixWorld(true);

        // Turn off frustum culling for the dynamically deformed parts
        // This explicitly prevents the ears/body/limbs from suddenly disappearing
        // when the original undeformed spherical bounds move to the edge of the camera viewport.
        this.mesh.traverse(child => {
          if (child.isMesh || child.isInstancedMesh) {
            child.frustumCulled = false;
          }
        });
        // Dynamic tail nodes
        createTrackingNode('tailmid', null, new THREE.Vector3());
        createTrackingNode('tailend', null, new THREE.Vector3());

        // Skeleton Edges
        const lineMat = new THREE.LineBasicMaterial({
          color: 0x00ffcc,
          depthTest: false,
          transparent: true,
          opacity: 0.7,
          linewidth: 2
        });
        this.skeletonLines = new THREE.LineSegments(
          new THREE.BufferGeometry(),
          lineMat
        );
        this.skeletonLines.renderOrder = 998;
        this.trackingGroup.add(this.skeletonLines);

        // Pre-allocate buffer for lines
        const linePositions = new Float32Array(POSE_CONNECTIONS.length * 6);
        this.skeletonLines.geometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
      }

      update(time, otherMice = [], hudRef = null, dt = 0.016) {
        // Clamp dt to prevent physics explosion on tab switch
        dt = Math.min(dt, 0.05);

        let t = time * 2.0 * this.speedMult + this.timeOffset;

        // --- 1. FORCE ACCUMULATION (Newton's 2nd Law: F = ma) ---
        this.force.set(0, 0);

        // Burst-pause-scurry locomotion (mostly running, brief pauses)
        let burst = Math.sin(t * 1.5 + this.burstPhase);
        burst = 0.7 + 0.3 * Math.max(0, burst); // Always >= 70% drive (fast loops)
        const driveStrength = burst * this.guiParams.wanderForce;

        // --- THIGMOTAXIS: Wall-following behavior (natural mouse behavior) ---
        const px = this.mesh.position.x;
        const pz = this.mesh.position.z;

        // Distance to each wall
        const dRight = ENCLOSURE_HALF_X - px;
        const dLeft = ENCLOSURE_HALF_X + px;
        const dFar = ENCLOSURE_HALF_Z - pz;
        const dNear = ENCLOSURE_HALF_Z + pz;

        // Find nearest wall and distance
        const wallDists = [
          { dist: dRight, normalX: -1, normalZ: 0, tangentX: 0, tangentZ: 1 },
          { dist: dLeft, normalX: 1, normalZ: 0, tangentX: 0, tangentZ: -1 },
          { dist: dFar, normalX: 0, normalZ: -1, tangentX: -1, tangentZ: 0 },
          { dist: dNear, normalX: 0, normalZ: 1, tangentX: 1, tangentZ: 0 },
        ];
        wallDists.sort((a, b) => a.dist - b.dist);
        const nearest = wallDists[0];
        const wallDist = nearest.dist;

        // Wall attraction: pull toward nearest wall (thigmotaxis)
        const wallAttr = this.guiParams.wallAttraction;
        const WALL_PREFER_DIST = 2.0;
        const WALL_ATTRACT_RANGE = 12.0;
        if (wallDist > WALL_PREFER_DIST && wallDist < WALL_ATTRACT_RANGE) {
          const attractStrength = ((wallDist - WALL_PREFER_DIST) / WALL_ATTRACT_RANGE) * wallAttr;
          this.force.x += nearest.normalX * attractStrength * driveStrength;
          this.force.y += nearest.normalZ * attractStrength * driveStrength;
        }

        // ALL-WALLS repulsion (prevents escaping from any wall)
        const WALL_REPULSION_DIST = 2.0;
        const WALL_K = 50.0;
        for (const w of wallDists) {
          if (w.dist < WALL_REPULSION_DIST) {
            const pen = (WALL_REPULSION_DIST - w.dist) / WALL_REPULSION_DIST;
            this.force.x -= w.normalX * pen * pen * WALL_K;
            this.force.y -= w.normalZ * pen * pen * WALL_K;
          }
        }

        // Wall-parallel drive: move along the wall (CW or CCW)
        const tangentX = nearest.tangentX * this.wallFollowDir;
        const tangentZ = nearest.tangentZ * this.wallFollowDir;
        const nearWallFactor = Math.max(0, 1.0 - wallDist / 5.0);
        this.force.x += tangentX * driveStrength * (0.5 + nearWallFactor * 1.5);
        this.force.y += tangentZ * driveStrength * (0.5 + nearWallFactor * 1.5);

        // Small random perturbation for natural variation
        if (!guiParams.isPaused) {
          this.force.x += (Math.sin(t * 2.3) * 0.3 + (Math.random() - 0.5) * 0.2) * driveStrength * 0.3;
          this.force.y += (Math.cos(t * 1.7) * 0.3 + (Math.random() - 0.5) * 0.2) * driveStrength * 0.3;
        }

        // --- ANTI-STUCK: detect and break out of stuck positions ---
        if (!guiParams.isPaused) {
          const dxS = px - this.lastPos.x;
          const dzS = pz - this.lastPos.y;
          const movedDist = Math.sqrt(dxS * dxS + dzS * dzS);
          this.stuckTimer += dt;
          if (this.stuckTimer > 0.8) { // Check every 0.8 seconds
            if (movedDist < 0.5) { // Haven't moved enough
              // Strong random kick to escape
              const kickAngle = Math.random() * Math.PI * 2;
              this.force.x += Math.cos(kickAngle) * 20.0;
              this.force.y += Math.sin(kickAngle) * 20.0;
              // Flip wall-follow direction
              this.wallFollowDir *= -1;
            }
            this.lastPos.set(px, pz);
            this.stuckTimer = 0;
          }
        }

        // --- 3. MOUSE-TO-MOUSE COLLISION (elastic-like repulsion) ---
        const MOUSE_RADIUS = 4.0;
        const COLLISION_K = 40.0; // Repulsion spring constant
        let isColliding = false;
        for (const other of otherMice) {
          if (other === this) continue;
          const dx = this.mesh.position.x - other.mesh.position.x;
          const dz = this.mesh.position.z - other.mesh.position.z;
          const distSq = dx * dx + dz * dz;
          if (distSq < MOUSE_RADIUS * MOUSE_RADIUS && distSq > 0.001) {
            isColliding = true;
            const dist = Math.sqrt(distSq);
            const overlap = MOUSE_RADIUS - dist;
            // Spring repulsion force (Hooke's law)
            const fx = (dx / dist) * overlap * COLLISION_K;
            const fz = (dz / dist) * overlap * COLLISION_K;
            this.force.x += fx;
            this.force.y += fz;
            // Position correction (prevent overlap, conservation of momentum)
            if (overlap > 0) {
              const correction = overlap * 0.5;
              this.mesh.position.x += (dx / dist) * correction;
              this.mesh.position.z += (dz / dist) * correction;
              other.mesh.position.x -= (dx / dist) * correction;
              other.mesh.position.z -= (dz / dist) * correction;
            }
          }
        }

        // --- 4. DRAG FORCE (opposes velocity, F_drag = -c * v) ---
        const dragC = this.guiParams.dragCoeff;
        this.force.x -= this.velocity.x * dragC;
        this.force.y -= this.velocity.y * dragC;

        // --- 5. INTEGRATION (Semi-implicit Euler: v += (F/m)*dt, x += v*dt) ---
        if (!guiParams.isPaused) {
          // a = F / m
          const ax = this.force.x / (this.mass * 1000); // Scale mass for unit consistency
          const az = this.force.y / (this.mass * 1000);
          this.velocity.x += ax * dt;
          this.velocity.y += az * dt;

          // Clamp speed (use GUI maxSpeed)
          const userMaxSpeed = this.guiParams.maxSpeed;
          const curSpeed = this.velocity.length();
          if (curSpeed > userMaxSpeed) {
            this.velocity.multiplyScalar(userMaxSpeed / curSpeed);
          }

          this.mesh.position.x += this.velocity.x * dt;
          this.mesh.position.z += this.velocity.y * dt;

          this.locomotionTime += curSpeed * dt;
        }

        // Hard boundary clamp — absolute containment + random direction flip
        const HARD_MARGIN = 0.5; // Small inset from enclosure edge
        let hitWall = false;
        if (this.mesh.position.x > ENCLOSURE_HALF_X - HARD_MARGIN) {
          this.mesh.position.x = ENCLOSURE_HALF_X - HARD_MARGIN;
          this.velocity.x = -Math.abs(this.velocity.x) * 0.3;
          hitWall = true;
        }
        if (this.mesh.position.x < -ENCLOSURE_HALF_X + HARD_MARGIN) {
          this.mesh.position.x = -ENCLOSURE_HALF_X + HARD_MARGIN;
          this.velocity.x = Math.abs(this.velocity.x) * 0.3;
          hitWall = true;
        }
        if (this.mesh.position.z > ENCLOSURE_HALF_Z - HARD_MARGIN) {
          this.mesh.position.z = ENCLOSURE_HALF_Z - HARD_MARGIN;
          this.velocity.y = -Math.abs(this.velocity.y) * 0.3;
          hitWall = true;
        }
        if (this.mesh.position.z < -ENCLOSURE_HALF_Z + HARD_MARGIN) {
          this.mesh.position.z = -ENCLOSURE_HALF_Z + HARD_MARGIN;
          this.velocity.y = Math.abs(this.velocity.y) * 0.3;
          hitWall = true;
        }
        // Randomly change wall-follow direction when hitting a wall
        if (hitWall && Math.random() < 0.5) {
          this.wallFollowDir *= -1;
        }

        // --- 6. HEADING (smooth turn towards velocity) ---
        const speed = this.velocity.length();
        let isMoving = speed > 0.3;
        if (isMoving) {
          const desiredHeading = new THREE.Vector2(this.velocity.x, this.velocity.y).normalize();
          // Lerp heading towards velocity direction (rotational inertia)
          const turnRate = isColliding ? 0.15 : 0.08;
          this.heading.lerp(desiredHeading, turnRate);
          if (this.heading.lengthSq() > 1e-6) this.heading.normalize();
        }
        this.mesh.rotation.y = Math.atan2(this.heading.x, this.heading.y);

        if (hudRef) {
          hudRef.state.innerText = isMoving ? "SCURRYING // AVOIDANCE" : "ALERT // SNIFFING";
          hudRef.state.style.color = isMoving ? "#00f0ff" : "#ffcc00";
          hudRef.hr.innerText = isMoving ? "540 BPM" : "410 BPM";
          hudRef.resp.innerText = isMoving ? "210 BPM" : (160 + Math.floor(Math.random() * 10)) + " BPM";
          hudRef.coord.innerText = `${this.mesh.position.x.toFixed(2)}, ${this.mesh.position.z.toFixed(2)}`;
        }

        // --- 7. BODY BOUNCE (spring-damper ground reaction) ---
        const speedNorm = Math.min(speed / this.maxSpeed, 1.0); // 0..1
        const bounceFreq = 4.0 + speedNorm * 6.0; // Faster bounce when running
        const bounceAmp = speedNorm * 0.12; // No bounce when still
        this.rig.position.y = 1.3 + Math.abs(Math.sin(this.locomotionTime * bounceFreq)) * bounceAmp;

        // --- 8. GAIT (leg cycle scales with actual speed) ---
        const legCycle = this.locomotionTime * 5.0;
        const gaitAmp = Math.min(speedNorm * 1.2, 1.0) * 0.6 * this.motion.gaitAmpMul;
        this.hindL.rotation.x = isMoving ? Math.sin(legCycle) * gaitAmp : 0.0;
        this.hindR.rotation.x = isMoving ? Math.sin(legCycle + Math.PI) * gaitAmp : 0.0;
        this.armL.rotation.x = isMoving ? Math.sin(legCycle + Math.PI) * gaitAmp * 0.8 : 0.0;
        this.armR.rotation.x = isMoving ? Math.sin(legCycle) * gaitAmp * 0.8 : 0.0;

        // Shank articulation follows thigh with phase offset
        this.shankL.rotation.x = isMoving ? Math.max(0, Math.sin(legCycle + 0.5)) * gaitAmp * 0.4 : 0;
        this.shankR.rotation.x = isMoving ? Math.max(0, Math.sin(legCycle + Math.PI + 0.5)) * gaitAmp * 0.4 : 0;

        if (!isMoving) {
          this.headGroup.rotation.y = Math.sin(time * 6.0) * 0.3 * this.motion.headIdleYawMul;
          this.headGroup.rotation.x = Math.sin(time * 9.0) * 0.15 * this.motion.headIdlePitchMul;
          this.snoutTip.position.y = -0.15 + Math.sin(time * 40.0) * 0.02 * this.motion.sniffAmpMul;
          this.padL.rotation.y = Math.sin(time * 40.0) * 0.1 * this.motion.sniffAmpMul + 0.1;
          this.padR.rotation.y = -Math.sin(time * 40.0) * 0.1 * this.motion.sniffAmpMul - 0.1;
          // Grooming posture
          this.armL.rotation.x = -1.2;
          this.armR.rotation.x = -1.2;
          this.armL.rotation.z = -0.2;
          this.armR.rotation.z = 0.2;
        } else {
          // Head tilts into turns for realism
          const turnAmount = this.velocity.x * this.heading.y - this.velocity.y * this.heading.x; // Cross product
          this.headGroup.rotation.set(Math.sin(time * 2) * 0.08, turnAmount * 0.08, 0);
          this.snoutTip.position.y = -0.15;
          this.padL.rotation.y = -0.3;
          this.padR.rotation.y = 0.3;
        }

        // --- 9. TAIL (procedural with velocity-modulated swing) ---
        let tailBase = new THREE.Vector3(0, -0.2, -2.7);
        tailBase.applyMatrix4(this.rig.matrix);

        // Build tail curve procedurally with physics-based swing
        let tailCurve = [];
        const tailLenMul = this.guiParams.tailLength;
        const segLen = this.tailSegLen * tailLenMul;
        // Velocity-based lateral swing: tail swings opposite to turns
        const lateralVel = this.velocity.x * this.heading.y - this.velocity.y * this.heading.x;
        for (let i = 0; i <= this.tailCount; i++) {
          const p = i / this.tailCount; // 0..1 progress along tail
          // Damped wave amplitude: peaks at middle, softer at ends
          const waveDamp = Math.sin(p * Math.PI) * 0.8 + 0.2;
          // Speed-modulated active wave
          let waveX = Math.sin(time * 3.5 * this.motion.tailWaveFreqMul - i * 0.2) * (i * 0.035 * this.motion.tailWaveAmpMul) * waveDamp;
          // Velocity-based passive swing (tail lags behind turns)
          waveX += lateralVel * p * p * 0.15;
          // Gentle gravity droop
          let waveY = -i * 0.02 * p;
          // Idle sway when still
          if (!isMoving) waveX += Math.sin(i * 0.12 + time * 1.5) * 0.2 * waveDamp;
          // Gravity: tail curves downward but not below a floor threshold
          waveY = Math.max(waveY, -1.3);
          tailCurve.push(new THREE.Vector3(waveX, waveY, -i * segLen));
        }

        // Shift the entire curve so its start aligns with tailBase
        let offset = tailBase.clone().sub(tailCurve[0]);
        for (let i = 0; i <= this.tailCount; i++) {
          tailCurve[i].add(offset);
          // Clamp tail segments above floor level (world Y=0)
          const worldY = tailCurve[i].y + this.mesh.position.y;
          if (worldY < 0.05) {
            tailCurve[i].y += (0.05 - worldY);
          }
        }

        for (let i = 0; i < this.tailCount; i++) {
          let p = i / this.tailCount;
          let radius = 1.0 - p * 0.88;

          // Ring-texture effect: subtle periodic scale wobble
          const ringWobble = 1.0 + Math.sin(i * 2.8) * 0.04;
          radius *= ringWobble;

          let ptA = tailCurve[i];
          let ptB = tailCurve[i + 1];

          this.dummy.position.copy(ptA);
          this.dummy.lookAt(ptB);
          const thickMul = this.guiParams.tailThickness;
          this.dummy.scale.set(radius * thickMul, radius * thickMul, segLen * 1.3); // Overlap segments to hide seams
          this.dummy.updateMatrix();
          this.tailInstanced.setMatrixAt(i, this.dummy.matrix);

          // Track tail mid and tail end for neuroscience skeleton
          let isTailVisible = this.tailInstanced.visible;
          if (i === Math.floor(this.tailCount * 0.4)) {
            this.poseNodes['tailmid'].position.copy(ptB);
            this.poseNodes['tailmid'].visible = guiParams.showTrackingKeypoints && isTailVisible;
          }
          if (i === this.tailCount - 1) {
            this.poseNodes['tailend'].position.copy(ptB);
            this.poseNodes['tailend'].visible = guiParams.showTrackingKeypoints && isTailVisible;
          }
        }
        this.tailInstanced.instanceMatrix.needsUpdate = true;

        // Update tracking visibility dynamically by referencing the GLB global guiParams directly
        this.trackingGroup.visible = guiParams.showTrackingKeypoints;
        for (const key in this.poseNodes) {
          this.poseNodes[key].visible = guiParams.showTrackingKeypoints;
        }

        // Apply live scalar adjustments to body
        const bodyLen = this.guiParams.bodyLength;
        const breathFreq = isMoving ? this.motion.breathMoveFreq : this.motion.breathIdleFreq;
        const breathAmp = isMoving ? this.motion.breathMoveAmp : this.motion.breathIdleAmp;
        let breath = Math.sin(time * breathFreq) * breathAmp;
        this.bodyMesh.scale.x = bodyLen + breath;
        this.bodyMesh.scale.y = this.guiParams.chonkiness;
        this.bodyMesh.scale.z = this.guiParams.chonkiness + breath;

        // Apply live head size adjustments
        const hSize = this.guiParams.headSize;
        this.head.scale.set(hSize, hSize, hSize);

        // Apply live snout length (scale Z of snout tip position)
        this.snoutTip.scale.set(1.1, 0.8, this.guiParams.snoutLength);

        // Apply live leg adjustments
        const legLen = this.guiParams.legLength;
        const legThk = this.guiParams.legThickness;
        this.hindL.scale.set(legThk, legLen, legThk);
        this.hindR.scale.set(legThk, legLen, legThk);
        this.armL.scale.set(legThk, legLen, legThk);
        this.armR.scale.set(legThk, legLen, legThk);

        // Apply live ear size adjustments
        const eSize = this.guiParams.earSize;
        this.head.children.forEach(child => {
          if (child !== this.snoutTip && child !== this.padL && child !== this.padR && child.geometry === earGeo) {
            child.scale.set(eSize, eSize, eSize);
          }
        });

        // Apply live skin color changes
        this.fleshMat.color.set(this.guiParams.skinColor);

        // Before computing edges, ensure all world matrices are fully updated
        // otherwise trailing edges / detaching spheres occur during high animation scales
        this.mesh.updateMatrixWorld(true);

        if (this.trackingGroup.visible) {
          // Update skeleton lines based on world positions mapped back to trackingGroup local space
          const positions = this.skeletonLines.geometry.attributes.position.array;
          let idx = 0;
          const invMat = this.trackingGroup.matrixWorld.clone().invert();
          const ptA = new THREE.Vector3();
          const ptB = new THREE.Vector3();

          for (const [idA, idB] of POSE_CONNECTIONS) {
            const nodeA = this.poseNodes[idA];
            const nodeB = this.poseNodes[idB];

            if (nodeA && nodeB) {
              nodeA.getWorldPosition(ptA);
              nodeB.getWorldPosition(ptB);

              ptA.applyMatrix4(invMat);
              ptB.applyMatrix4(invMat);

              positions[idx++] = ptA.x;
              positions[idx++] = ptA.y;
              positions[idx++] = ptA.z;
              positions[idx++] = ptB.x;
              positions[idx++] = ptB.y;
              positions[idx++] = ptB.z;
            }
          }
          this.skeletonLines.geometry.attributes.position.needsUpdate = true;
        }
      }
    }

    // --- 6. SCENE ASSEMBLY ---
    const floorGeo = new THREE.PlaneGeometry(200, 200);
    const floorMat = new THREE.MeshStandardMaterial({
      color: 0xd8d8d8,  // Light gray lab arena floor
      roughness: 0.65,   // Matte plastic/melamine surface
      metalness: 0.0
    });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    // Enclosure box (transparent acrylic style).
    const enclosureMat = new THREE.MeshPhysicalMaterial({
      color: 0xb9d7ea,
      transparent: true,
      opacity: 0.13,
      roughness: 0.08,
      metalness: 0.0,
      transmission: 0.78,
      thickness: 0.3
    });
    const enclosureBox = new THREE.Mesh(
      new THREE.BoxGeometry(ENCLOSURE_W, ENCLOSURE_H, ENCLOSURE_D),
      enclosureMat
    );
    enclosureBox.position.set(0, ENCLOSURE_H * 0.5, 0);
    enclosureBox.receiveShadow = true;
    scene.add(enclosureBox);

    const enclosureEdges = new THREE.LineSegments(
      new THREE.EdgesGeometry(new THREE.BoxGeometry(ENCLOSURE_W, ENCLOSURE_H, ENCLOSURE_D)),
      new THREE.LineBasicMaterial({ color: 0x58c8ff, transparent: true, opacity: 0.45 })
    );
    enclosureEdges.position.copy(enclosureBox.position);
    scene.add(enclosureEdges);

    const grid = new THREE.GridHelper(100, 50, 0x00f0ff, 0x112233);
    grid.position.y = 0.01;
    grid.material.transparent = true; grid.material.opacity = 0.2;
    scene.add(grid);
    // LIGHTING — Behavioral neuroscience lab illumination
    // Labs use overhead fluorescent/LED panels for bright, even, shadow-free lighting

    // Strong ambient fill (labs are brightly lit for camera tracking)
    const ambientLight = new THREE.AmbientLight(0xf5f0eb, 0.5); // Warm-neutral
    scene.add(ambientLight);

    // Hemisphere light: cool ceiling → warm floor bounce
    const hemiLight = new THREE.HemisphereLight(
      0xe8eef5,  // Sky: cool fluorescent white
      0xf0e8d8,  // Ground: warm reflection from bedding/floor
      0.6
    );
    hemiLight.position.set(0, 20, 0);
    scene.add(hemiLight);

    // Primary overhead panel light (ceiling-mounted LED, ~5000K daylight)
    const panelLight1 = new THREE.DirectionalLight(0xf0f0ff, 0.8);
    panelLight1.position.set(0, 18, 0); // Directly overhead
    panelLight1.castShadow = true;
    panelLight1.shadow.mapSize.width = 2048;
    panelLight1.shadow.mapSize.height = 2048;
    panelLight1.shadow.camera.near = 0.5;
    panelLight1.shadow.camera.far = 30;
    panelLight1.shadow.camera.left = -20;
    panelLight1.shadow.camera.right = 20;
    panelLight1.shadow.camera.top = 15;
    panelLight1.shadow.camera.bottom = -15;
    panelLight1.shadow.bias = -0.001; // Reduce shadow acne
    panelLight1.shadow.normalBias = 0.02;
    scene.add(panelLight1);

    // Secondary overhead panel (offset for even coverage, softer)
    const panelLight2 = new THREE.DirectionalLight(0xf5f0e8, 0.4);
    panelLight2.position.set(8, 16, 5); // Offset to reduce harsh shadows
    panelLight2.castShadow = false; // Only primary casts shadows
    scene.add(panelLight2);

    // Fill light from opposite side (simulates light bouncing off lab walls)
    const fillLight = new THREE.DirectionalLight(0xe8e8f0, 0.3);
    fillLight.position.set(-6, 12, -4);
    fillLight.castShadow = false;
    scene.add(fillLight);

    // --- 7. GUI & LOGIC ---
    const mice = [];
    const hudElements = {
      count: document.getElementById('hud-count'),
      state: document.getElementById('hud-state'),
      hr: document.getElementById('hud-hr'),
      resp: document.getElementById('hud-resp'),
      coord: document.getElementById('hud-coord')
    };

    const guiParams = {
      furColor: '#ffffff',
      skinColor: '#ffd0c8',
      chonkiness: 1.0,
      earSize: 0.85,
      furDensity: 0.85,
      showTrackingKeypoints: true,
      wireframeMode: false,
      isPaused: false,
      addSubject: () => spawnMouse(),
      clearSubjects: () => clearMice(),
      presets: 'BALB/c (White)',
      // Body part controls
      tailLength: 1.0,
      tailThickness: 1.0,
      headSize: 1.0,
      snoutLength: 1.0,
      bodyLength: 1.0,
      legLength: 1.0,
      legThickness: 1.0,
      // Physics / speed controls
      maxSpeed: 15.0,
      dragCoeff: 1.8,
      wanderForce: 10.0,
      wallAttraction: 3.5,
    };

    function getStrainProfile(presetName) {
      if (presetName === 'C57BL/6 (Black)') {
        return {
          earOuterTransmission: 0.65,
          earInnerTransmission: 0.75,
          earInnerSatOffset: 0.10,
          earInnerLightOffset: 0.15,
          earOuterRoughness: 0.32,
          earYaw: 0.96,
          earHeightOffset: 0.0,
          padDarken: 0.88,
          clawColor: 0xcccccc,
          noseColor: '#b48a8a', // Soft pinkish-grey snout
          pawSpreadMul: 1.0,
          toeLenMul: 0.98,
          // Behavioral profile
          gaitAmpMul: 0.92,
          headIdleYawMul: 0.82,
          headIdlePitchMul: 0.88,
          sniffAmpMul: 0.75,
          breathIdleAmp: 0.010,
          breathMoveAmp: 0.012,
          breathIdleFreq: 10.0,
          breathMoveFreq: 18.0,
          tailWaveAmpMul: 0.85,
          tailWaveFreqMul: 0.90
        };
      }
      if (presetName === 'Nude/Hairless') {
        return {
          earOuterTransmission: 0.66,
          earInnerTransmission: 0.82,
          earInnerSatOffset: 0.14,
          earInnerLightOffset: 0.14,
          earOuterRoughness: 0.28,
          earYaw: 0.42,
          earHeightOffset: 0.015,
          padDarken: 0.88,
          clawColor: 0xe1d7cb,
          noseColor: '#ff9ea8',
          pawSpreadMul: 1.04,
          toeLenMul: 1.05,
          // Behavioral profile
          gaitAmpMul: 1.08,
          headIdleYawMul: 1.15,
          headIdlePitchMul: 1.12,
          sniffAmpMul: 1.25,
          breathIdleAmp: 0.018,
          breathMoveAmp: 0.024,
          breathIdleFreq: 13.0,
          breathMoveFreq: 24.0,
          tailWaveAmpMul: 1.18,
          tailWaveFreqMul: 1.12
        };
      }
      // BALB/c default.
      return {
        earOuterTransmission: 0.58,
        earInnerTransmission: 0.76,
        earInnerSatOffset: 0.11,
        earInnerLightOffset: 0.11,
        earOuterRoughness: 0.33,
        earYaw: 0.40,
        earHeightOffset: 0.0,
        padDarken: 0.84,
        clawColor: 0xd7cdc2,
        noseColor: '#f2adb0',
        pawSpreadMul: 1.0,
        toeLenMul: 1.0,
        // Behavioral profile
        gaitAmpMul: 1.0,
        headIdleYawMul: 1.0,
        headIdlePitchMul: 1.0,
        sniffAmpMul: 1.0,
        breathIdleAmp: 0.013,
        breathMoveAmp: 0.016,
        breathIdleFreq: 12.0,
        breathMoveFreq: 20.0,
        tailWaveAmpMul: 1.0,
        tailWaveFreqMul: 1.0
      };
    }

    function applyStrainPreset(name) {
      guiParams.presets = name;
      if (name === 'BALB/c (White)') { guiParams.furColor = '#ffffff'; guiParams.skinColor = '#ffd0c8'; guiParams.furDensity = 0.5; guiParams.earSize = 0.8; }
      if (name === 'C57BL/6 (Black)') { guiParams.furColor = '#18161a'; guiParams.skinColor = '#ebb4b8'; guiParams.furDensity = 0.65; guiParams.earSize = 0.95; }
      if (name === 'CBA (Brown)') { guiParams.furColor = '#6a4b3a'; guiParams.skinColor = '#d0a090'; guiParams.furDensity = 0.55; guiParams.earSize = 0.8; }
      if (name === 'Nude/Hairless') { guiParams.furColor = '#ffd0c8'; guiParams.skinColor = '#ffc0b8'; guiParams.furDensity = 0.0; guiParams.earSize = 0.95; }
    }

    const gui = new GUI({ title: 'GENETICS LAB (GUI)' });

    gui.add(guiParams, 'presets', ['BALB/c (White)', 'C57BL/6 (Black)', 'CBA (Brown)', 'Nude/Hairless']).name('Strains').onChange(v => {
      applyStrainPreset(v);
      gui.controllersRecursive().forEach(c => c.updateDisplay());
    });

    const neuroscienceFolder = gui.addFolder('Neuroscience & Tracking');
    neuroscienceFolder.add(guiParams, 'showTrackingKeypoints').name('Show Pose Skeleton').onChange(v => {
      mice.forEach(m => m.trackingGroup.visible = v);
    });
    neuroscienceFolder.add(guiParams, 'wireframeMode').name('Wireframe Bodies').onChange(v => {
      scene.traverse(child => {
        if (child.isMesh && child.material && child.material !== floorMat && child !== enclosureBox) {
          if (child.geometry && child.geometry.type !== 'ConeGeometry' && child.geometry.type !== 'CylinderGeometry') {
            child.material.wireframe = v;
          }
        }
      });
    });

    const traitFolder = gui.addFolder('Biological Traits');
    traitFolder.addColor(guiParams, 'furColor').name('Fur Pigment');
    traitFolder.addColor(guiParams, 'skinColor').name('Skin Pigment');
    traitFolder.add(guiParams, 'chonkiness', 0.5, 2.0).name('Fatness / Mass');
    traitFolder.add(guiParams, 'earSize', 0.5, 2.0).name('Ear Magnitude');
    traitFolder.add(guiParams, 'furDensity', 0.0, 1.0).name('Fur Density (Perf)').onChange(() => {
      alert("Fur density changes require respawning subjects to take effect.");
    });

    const controlFolder = gui.addFolder('Simulation Controls');
    controlFolder.add(guiParams, 'isPaused').name('Pause Simulation');
    controlFolder.add(guiParams, 'addSubject').name('(+) Spawn Subject');
    controlFolder.add(guiParams, 'clearSubjects').name('(!) Clear All');

    const bodyFolder = gui.addFolder('Body Part Controls');
    bodyFolder.add(guiParams, 'tailLength', 0.2, 2.5, 0.05).name('Tail Length');
    bodyFolder.add(guiParams, 'tailThickness', 0.3, 2.0, 0.05).name('Tail Thickness');
    bodyFolder.add(guiParams, 'headSize', 0.5, 2.0, 0.05).name('Head Size');
    bodyFolder.add(guiParams, 'snoutLength', 0.5, 2.0, 0.05).name('Snout Length');
    bodyFolder.add(guiParams, 'bodyLength', 0.5, 2.0, 0.05).name('Body Length');
    bodyFolder.add(guiParams, 'legLength', 0.5, 2.0, 0.05).name('Leg Length');
    bodyFolder.add(guiParams, 'legThickness', 0.5, 2.0, 0.05).name('Leg Thickness');

    const physicsFolder = gui.addFolder('Physics Controls');
    physicsFolder.add(guiParams, 'maxSpeed', 1.0, 15.0, 0.5).name('Max Speed');
    physicsFolder.add(guiParams, 'dragCoeff', 0.5, 10.0, 0.5).name('Drag / Friction');
    physicsFolder.add(guiParams, 'wanderForce', 0.5, 10.0, 0.5).name('Wander Force');
    physicsFolder.add(guiParams, 'wallAttraction', 0.0, 5.0, 0.25).name('Wall Attraction');

    function spawnMouse() {
      const m = new ExpertMouse(guiParams);
      // Spawn near a wall (thigmotactic start position)
      const wall = Math.floor(Math.random() * 4);
      const wallOffset = 2.0; // Distance from wall
      switch (wall) {
        case 0: // Right wall
          m.mesh.position.x = ENCLOSURE_HALF_X - wallOffset;
          m.mesh.position.z = (Math.random() - 0.5) * ENCLOSURE_HALF_Z * 1.5;
          break;
        case 1: // Left wall
          m.mesh.position.x = -ENCLOSURE_HALF_X + wallOffset;
          m.mesh.position.z = (Math.random() - 0.5) * ENCLOSURE_HALF_Z * 1.5;
          break;
        case 2: // Far wall
          m.mesh.position.x = (Math.random() - 0.5) * ENCLOSURE_HALF_X * 1.5;
          m.mesh.position.z = ENCLOSURE_HALF_Z - wallOffset;
          break;
        case 3: // Near wall
          m.mesh.position.x = (Math.random() - 0.5) * ENCLOSURE_HALF_X * 1.5;
          m.mesh.position.z = -ENCLOSURE_HALF_Z + wallOffset;
          break;
      }
      scene.add(m.mesh);
      mice.push(m);
      hudElements.count.innerText = mice.length;
    }

    function clearMice() {
      mice.forEach(m => scene.remove(m.mesh));
      mice.length = 0;
      hudElements.count.innerText = 0;
      hudElements.state.innerText = "NO SUBJECTS";
      hudElements.hr.innerText = "-- BPM";
      hudElements.resp.innerText = "-- BPM";
      hudElements.coord.innerText = "0.00, 0.00";
    }

    // Spawn initial subjects based on the image
    applyStrainPreset('C57BL/6 (Black)');
    spawnMouse();
    applyStrainPreset('BALB/c (White)');
    gui.controllersRecursive().forEach(c => c.updateDisplay());
    spawnMouse();

    // --- 8. RENDER LOOP ---
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    window.dispatchEvent(new Event('resize'));

    const clock = new THREE.Clock();
    let accumulatedTime = 0;

    function animate() {
      requestAnimationFrame(animate);

      const dt = clock.getDelta();
      // Completely freeze all time-based state when paused
      if (!guiParams.isPaused) {
        accumulatedTime += dt;
      }

      // Pass otherMice array for physical hard constraints and repulsion
      mice.forEach((m, i) => {
        m.update(accumulatedTime, mice, i === 0 ? hudElements : null, dt);
      });

      controls.update();
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>

</html>
